<!doctype html><html><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title data-i18n=appTitle></title>
<link rel=stylesheet href=https://cdn.jsdelivr.net/npm/flatpickr/dist/flatpickr.min.css><link rel=stylesheet href=https://unpkg.com/vditor/dist/index.css><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@yaireo/tagify/dist/tagify.css><style>:root{--bg-color:#f8f9fa;--text-color:#212529;--input-bg:#ffffff;--input-border:#dee2e6;--input-text:#495057;--button-bg:#007bff;--button-text:#ffffff;--button-border:transparent;--hover-bg:#e9ecef;--border-color:#e9ecef;--link-color:#007bff;--status-bg:#f1f3f5;--status-border:#dee2e6;--status-text:#495057;--status-error-bg:#f8d7da;--status-error-text:#721c24;--status-error-border:#f5c6cb;--status-success-bg:#d1e7dd;--status-success-text:#0f5132;--status-success-border:#badbcc;--status-loading-bg:#fff3cd;--status-loading-text:#664d03;--status-loading-border:#ffecb5;--disabled-bg-color:#e9ecef;--disabled-text-color:#6c757d;--dark-disabled-bg-color:#343a40;--dark-disabled-text-color:#6c757d;--active-edit-bg:#e6f7ff;--active-edit-text:#0d6efd}body.dark-mode{--bg-color:#212529;--text-color:#e9ecef;--input-bg:#343a40;--input-border:#495057;--input-text:#f8f9fa;--button-bg:#0d6efd;--button-text:#ffffff;--button-border:transparent;--hover-bg:#495057;--border-color:#495057;--link-color:#6ea8fe;--status-bg:#343a40;--status-border:#495057;--status-text:#e9ecef;--status-error-bg:#5a2c30;--status-error-text:#f8d7da;--status-error-border:#721c24;--status-success-bg:#274a2d;--status-success-text:#d1e7dd;--status-success-border:#155724;--status-loading-bg:#5a4f2c;--status-loading-text:#fff3cd;--status-loading-border:#856404;--disabled-bg-color:#343a40;--disabled-text-color:#6c757d;--active-edit-bg:#1c3b5e;--active-edit-text:#6ea8fe}body{max-width:80rem;margin:0 auto;padding:0 .5rem;background-color:var(--bg-color);color:var(--text-color);font-family:-apple-system,BlinkMacSystemFont,segoe ui,Roboto,Helvetica,Arial,sans-serif,apple color emoji,segoe ui emoji,segoe ui symbol;line-height:1.6}body>div:first-of-type{display:flex;flex-direction:column;min-height:100vh}#fileContentInput{min-height:500px}.hidden{display:none!important}#fileList ul{list-style:none;padding:0;margin:0}#fileList li{padding:8px 10px;cursor:pointer;border-bottom:1px solid var(--border-color);display:flex;justify-content:space-between;align-items:center;gap:8px;transition:background-color .15s ease-in-out}#fileList li:last-child{border-bottom:none}#fileList li:hover{background-color:var(--hover-bg)}#fileList li.dir::before,#fileList li.bundle::before{content:"📂 ";flex-shrink:0;font-size:1.1em}#fileList li.file::before{content:"📄 ";flex-shrink:0;font-size:1.1em}#fileList li.asset::before{content:"📦 ";flex-shrink:0;font-size:1.1em}#fileList li.parent-dir{font-style:italic;color:#6c757d}body.dark-mode #fileList li.parent-dir{color:#adb5bd}#fileList li.no-hover,#fileList li.asset{cursor:default;color:#6c757d}body.dark-mode #fileList li.no-hover,body.dark-mode #fileList li.asset{color:#adb5bd}#fileList li.no-hover:hover,#fileList li.asset:hover{background-color:transparent}#fileList li.error{background-color:var(--status-error-bg);color:var(--status-error-text);padding:10px;cursor:default;border-radius:4px;margin-bottom:5px;border:1px solid var(--status-error-border)}#fileList li.active-edit-item{background-color:var(--active-edit-bg);color:var(--active-edit-text);font-weight:600}#fileList li.active-edit-item:hover{background-color:var(--active-edit-bg)}#fileList li.active-edit-item .file-item-name,#fileList li.active-edit-item .draft-indicator{color:var(--active-edit-text)}.file-item-name{white-space:nowrap;overflow:hidden;text-overflow:ellipsis;flex-grow:1;min-width:0}.draft-indicator{color:#fd7e14;font-size:1em;font-style:normal;margin-left:auto;padding-left:10px;flex-shrink:0}body.dark-mode .draft-indicator{color:#fd7e14}.breadcrumb a{text-decoration:none;color:var(--link-color)}.breadcrumb a:hover{text-decoration:underline}.breadcrumb strong{font-weight:600}#errorStatusBarContainer{margin-top:15px;display:flex;flex-direction:column;gap:5px}.error-status-item{padding:10px 30px 10px 10px;white-space:pre-wrap;word-break:break-all;border:1px solid var(--status-error-border);background-color:var(--status-error-bg);color:var(--status-error-text);position:relative;border-radius:4px}#statusBar{margin-top:10px;padding:10px;white-space:pre-wrap;word-break:break-all;border:1px solid var(--status-border);border-radius:4px;background-color:var(--status-bg);margin-bottom:1rem}.dismiss-error-btn{position:absolute;right:5px;top:50%;transform:translateY(-50%);background:0 0;border:none;font-size:1.5em;cursor:pointer;color:var(--status-error-text);padding:0 5px;line-height:1}body.dark-mode .dismiss-error-btn{color:var(--status-error-text)}#statusBar.status-bar-error{background-color:var(--status-error-bg);color:var(--status-error-text);border-color:var(--status-error-border)}#statusBar.status-bar-success{background-color:var(--status-success-bg);color:var(--status-success-text);border-color:var(--status-success-border)}#statusBar.status-bar-loading{background-color:var(--status-loading-bg);color:var(--status-loading-text);border-color:var(--status-loading-border)}label{display:block;margin-top:10px;margin-bottom:5px;font-weight:600}.flatpickr-input{padding:.5rem .75rem!important;box-sizing:border-box!important}input[type=text],input[type=password],input[type=search],textarea,select{width:100%;box-sizing:border-box;padding:.5rem .75rem;margin-bottom:10px;border:1px solid var(--input-border);background-color:var(--input-bg);color:var(--input-text);border-radius:4px;line-height:1.5;font-size:1rem;height:2.5rem;transition:border-color .15s ease-in-out,box-shadow .15s ease-in-out}input:focus,textarea:focus,select:focus{border-color:#86b7fe;outline:0;box-shadow:0 0 0 .25rem rgba(13,110,253,.25)}textarea{min-height:200px;font-family:Consolas,Monaco,andale mono,ubuntu mono,monospace}button{display:inline-block;font-weight:400;line-height:1.5;color:var(--button-text);text-align:center;text-decoration:none;vertical-align:middle;cursor:pointer;-webkit-user-select:none;-moz-user-select:none;user-select:none;background-color:var(--button-bg);border:1px solid var(--button-border);padding:.5rem .7rem;font-size:1rem;border-radius:4px;transition:opacity .15s ease-in-out}button:hover{opacity:.85}button:disabled{cursor:not-allowed;opacity:.65;background-color:var(--disabled-bg-color);color:var(--disabled-text-color);border-color:var(--input-border)}body.dark-mode button:disabled{background-color:var(--dark-disabled-bg-color);color:var(--dark-disabled-text-color);border-color:var(--input-border)}#saveDraftButton,#publishButton,#deleteFileButton,#cancelEditButton{margin-bottom:8px}#logoutButton{display:block;background-color:#6c757d;color:#fff;border-color:#6c757d;margin-top:15px;margin-bottom:10px;margin-left:auto}hr{margin:1.5rem 0;border:0;border-top:1px solid var(--border-color);opacity:.7}.custom-fm-row{display:flex;gap:5px;margin-bottom:5px;align-items:center}.custom-fm-row input[type=text],.custom-fm-row input[type=checkbox],.custom-fm-row select,.custom-fm-row .tagify{margin-bottom:0}.custom-fm-type{flex:.5}.custom-fm-key{flex:.8}.custom-fm-value-container{flex:2;min-width:0}.custom-fm-value-container input[type=text],.custom-fm-value-container input[type=checkbox],.custom-fm-value-container .tagify{width:100%;box-sizing:border-box}.custom-fm-value-container input[type=checkbox]{width:auto;margin-right:5px}.remove-custom-fm-button{background-color:#dc3545;border-color:#dc3545;color:#fff}h1,h2,h3{color:var(--text-color);margin-top:1.5rem;font-weight:600}p,div,span,li{color:var(--text-color)}code{background-color:var(--hover-bg);padding:.2em .4em;margin:0;font-size:85%;border-radius:3px;font-family:Consolas,Monaco,andale mono,ubuntu mono,monospace;color:var(--text-color)}body.dark-mode code{background-color:#495057}body.dark-mode .flatpickr-calendar{background:#2a2a2a;border-color:var(--border-color);box-shadow:0 0 0 1px var(--border-color)}body.dark-mode .flatpickr-day{color:#adb5bd}body.dark-mode .flatpickr-day:hover,body.dark-mode .flatpickr-day:focus{background:var(--hover-bg);border-color:var(--hover-bg);color:#f8f9fa}body.dark-mode .flatpickr-day.today{border-color:var(--link-color);color:var(--link-color)}body.dark-mode .flatpickr-day.selected,body.dark-mode .flatpickr-day.startRange,body.dark-mode .flatpickr-day.endRange{background:var(--link-color);border-color:var(--link-color);color:#fff}body.dark-mode .flatpickr-month,body.dark-mode .flatpickr-weekday,body.dark-mode .flatpickr-weekdays,body.dark-mode .numInput,body.dark-mode .flatpickr-current-month input.cur-year{color:#ced4da}body.dark-mode .flatpickr-time input,body.dark-mode .flatpickr-time .flatpickr-am-pm{background:#495057;color:#f8f9fa;border-color:var(--input-border)}input:disabled,textarea:disabled,select:disabled{background-color:var(--disabled-bg-color);color:var(--disabled-text-color);cursor:not-allowed;opacity:.7}body.dark-mode input:disabled,body.dark-mode textarea:disabled,body.dark-mode select:disabled{background-color:var(--dark-disabled-bg-color);color:var(--dark-disabled-text-color);opacity:.7}.filename-input-wrapper{display:flex;align-items:center;gap:5px}.filename-input-wrapper input{flex-grow:1;margin-bottom:0;font-family:Consolas,Monaco,andale mono,ubuntu mono,monospace}#fmLastmodValue{margin-left:.5rem;font-size:.9rem;color:#6c757d}body.dark-mode #fmLastmodValue{color:#adb5bd}#fileFilterInput{max-width:300px;margin-right:10px;margin-bottom:0}.file-browser-toolbar{margin:10px 0;display:flex;flex-wrap:wrap;gap:5px;align-items:center}#fileListEmptyMessage{text-align:center;margin-top:15px;color:#6c757d}body.dark-mode #fileListEmptyMessage{color:#adb5bd}.warning-message{font-weight:400;margin:0;font-size:.8em}.pat-warning-box{padding:1rem;margin-bottom:1.5rem;border:1px solid var(--status-loading-border);background-color:var(--status-loading-bg);color:var(--status-loading-text);border-radius:4px}.pat-warning-box strong{color:var(--status-loading-text)}.description-note{font-size:.9em;color:#6c757d;margin-bottom:1rem;line-height:1.5;padding:.7rem;margin-bottom:1.5rem;border:1px solid var(--input-border);border-radius:4px}body.dark-mode .description-note{color:#adb5bd}#draftFilterContainer{display:flex;margin-left:10px;align-items:center;gap:5px}.home-logout-container{display:flex;align-items:center;margin-top:auto;padding-top:1rem;border-top:1px solid var(--border-color);width:100%;box-sizing:border-box}.home-link{text-decoration:none;font-weight:700;font-size:1.2rem;color:inherit}#appVersionInfo{font-size:.9em;color:var(--disabled-text-color);flex-grow:1;text-align:center}#appVersionInfo a{font-weight:700;color:var(--link-color);text-decoration:none}#appVersionInfo a:hover{text-decoration:underline}#appVersionInfo sup{font-size:.5em}#mainLayoutContainer{display:flex;gap:1.5rem;align-items:flex-start}#fileBrowserSection{flex:1 1 100%;max-width:none;display:block;border:none;border-radius:0;background-color:transparent;box-sizing:border-box}#fileList{border:1px solid var(--border-color);border-radius:4px;background-color:var(--input-bg);overflow-y:auto;margin-top:.5rem;margin-bottom:.5rem}#editorSection{flex:1 1 100%;display:none}.tagify{--tag-pad:0.3rem 0.5rem;width:100%;color:var(--input-text);background-color:var(--input-bg);border:1px solid var(--input-border);border-radius:4px}.tagify.tagify--focus{box-shadow:0 0 0 .25rem rgba(13,110,253,.25)}body.dark-mode .tagify{color:var(--input-text);background-color:var(--input-bg)}.tagify__tag>div::before{box-shadow:none}.tagify__input{color:var(--input-text);background-color:var(--input-bg)}.tagify__tag{--tag-remove-btn-color:var(--text-color);background-color:#d3d3d3;display:inline-flex;align-items:center;box-sizing:border-box;font-size:.9em;border-radius:4px}body.dark-mode .tagify__tag{background-color:dimgray}.tagify__tag:hover{opacity:.85}.fm-date-wrapper{display:flex;align-items:center;gap:10px;margin-bottom:10px}.fm-date-wrapper .flatpickr-input{flex-grow:1;margin-bottom:0}.fm-date-wrapper input[type=checkbox]{width:auto;margin-bottom:0}.fm-date-wrapper label{margin-top:0;margin-bottom:0;font-weight:400;font-size:.9em}@media(min-width:64rem){#mainLayoutContainer.split-view #fileBrowserSection{flex:1 1 300px;max-width:380px;min-width:250px}#mainLayoutContainer.split-view #editorSection{flex:3;min-width:0;display:block!important}}@media(max-width:63.999rem){#mainLayoutContainer{flex-direction:column;gap:1rem}#fileBrowserSection{flex-basis:auto;padding:0;width:100%;max-width:none;order:1;margin-bottom:1rem;background-color:transparent;border:none}#fileBrowserSection>h2,#fileBrowserSection>div:not(#fileList):not(#draftFilterContainer),#fileBrowserSection>.file-browser-toolbar{padding-left:10px;padding-right:10px}#fileList{max-height:calc(40vh - 60px);margin-top:0}#editorSection{flex-basis:auto;width:100%;order:2}#mainLayoutContainer.mobile-editor-visible #editorSection{display:block!important}body{padding:0 .5rem}#fileContentInput{min-height:350px}}</style></head><body><div><div id=loginSection class=hidden><h2 data-i18n=login.title></h2><p class=pat-warning-box><strong data-i18n=login.warningTitle></strong>
<span data-i18n=login.warningText><strong data-i18n=login.warningStorage></strong>
<strong data-i18n=login.warningLogout></strong>
<strong data-i18n=login.warningPerms></strong></span></p><label for=patInput data-i18n=login.patLabel></label>
<input type=password id=patInput data-i18n=[placeholder]login.patPlaceholder>
<button id=loginButton data-i18n=login.loginButton></button></div><div id=repoSection class=hidden><h2 data-i18n=repo.title></h2><label for=repoSelect data-i18n=repo.selectLabel></label>
<select id=repoSelect><option value data-i18n=repo.selectDefaultOption></option></select>
<button id=loadRepoButton disabled data-i18n=repo.loadButton></button></div><div id=mainLayoutContainer class=hidden><div id=fileBrowserSection class=hidden><h2 data-i18n=browser.title></h2><div><strong data-i18n=browser.currentRepoLabel></strong>
<span id=currentRepo></span> (
<span data-i18n=browser.branchLabel></span>
<span id=currentBranchName></span>)</div><div class=breadcrumb><strong data-i18n=browser.pathLabel></strong>
<span id=currentPathBreadcrumb>content</span></div><div class=file-browser-toolbar><input type=search id=fileFilterInput placeholder data-i18n=[placeholder]browser.filterPlaceholder><div id=draftFilterContainer class=hidden><input type=checkbox id=draftFilterCheckbox>
<label for=draftFilterCheckbox class=warning-message data-i18n=browser.showOnlyDraftsLabel></label></div></div><div id=fileList><ul></ul></div><div id=fileListEmptyMessage class=hidden data-i18n=browser.filterNoResults></div><button id=createNewFileButton data-i18n=browser.newFileButtonInFolder></button></div><div id=editorSection class=hidden><h2 data-i18n=editor.title></h2><input type=hidden id=currentFileSha>
<input type=hidden id=currentFilePathInput>
<label for=fmTitleInput data-i18n=editor.fm.titleLabel></label>
<input type=text id=fmTitleInput data-i18n=[placeholder]editor.fm.titlePlaceholder>
<label for=fileNameInput id=fileNameLabel data-i18n=editor.fm.fileNameLabel></label><div class=filename-input-wrapper><input type=text id=fileNameInput data-i18n=[placeholder]editor.fm.fileNamePlaceholder></div><hr><h3 data-i18n=editor.fm.baseHeader></h3><p class=description-note data-i18n=editor.fm.baseNote></p><label for=fmDateInput data-i18n=editor.fm.dateLabel></label><div class=fm-date-wrapper><input type=text id=fmDateInput data-i18n=[placeholder]editor.fm.datePlaceholder class=flatpickr-input>
<input type=checkbox id=fmDateAutoCheckbox>
<label for=fmDateAutoCheckbox id=fmDateAutoLabel data-i18n=editor.fm.autoSetToNow></label></div><div id=fmLastmodContainer class=hidden><label for=fmLastmodInput data-i18n=editor.fm.lastmodLabel></label><div class=fm-date-wrapper><input type=text id=fmLastmodInput data-i18n=[placeholder]editor.fm.datePlaceholder class=flatpickr-input>
<input type=checkbox id=fmLastmodAutoCheckbox>
<label for=fmLastmodAutoCheckbox id=fmLastmodAutoLabel data-i18n=editor.fm.autoSetToNow></label></div></div><label for=fmAuthorInput data-i18n=editor.fm.authorLabel></label>
<input type=text id=fmAuthorInput data-i18n=[placeholder]editor.fm.authorPlaceholder>
<label for=fmDescriptionInput data-i18n=editor.fm.descriptionLabel></label>
<input type=text id=fmDescriptionInput data-i18n=[placeholder]editor.fm.descriptionPlaceholder>
<label for=fmTagsInput data-i18n=editor.fm.tagsLabel></label>
<input type=text id=fmTagsInput data-i18n=[placeholder]editor.fm.tagsPlaceholder>
<label for=fmCategoriesInput data-i18n=editor.fm.categoriesLabel></label>
<input type=text id=fmCategoriesInput data-i18n=[placeholder]editor.fm.categoriesPlaceholder><hr><h3 data-i18n=editor.fm.customHeader></h3><p class=description-note data-i18n=editor.fm.customNote></p><div id=customFrontMatterContainer></div><button type=button id=addCustomFieldButton data-i18n=editor.fm.addCustomFieldButton></button><hr><h3 id=fileContentLabel data-i18n=editor.content.fileContentLabel></h3><div id=fileContentInput aria-labelledby=fileContentLabel></div><hr><h3 for=commitMessageInput data-i18n=editor.commitMessageLabel></h3><input type=text id=commitMessageInput data-i18n=[placeholder]editor.commitMessagePlaceholder>
<button id=saveDraftButton data-i18n=editor.saveDraftButton></button>
<button id=publishButton data-i18n=editor.publishButton></button>
<button id=deleteFileButton data-i18n=editor.deleteButton></button>
<button id=cancelEditButton data-i18n=editor.cancelButton></button></div></div><div id=errorStatusBarContainer></div><div id=statusBar></div><div class=home-logout-container><a href=/ id=homeLink class=home-link>🏠</a>
<span id=appVersionInfo><a href=https://github.com/dev4neon target=_blank rel="noopener noreferrer">GiCAHS</a>
<sup>0.1.1</sup>
</span><button id=logoutButton class=hidden data-i18n=logoutButton></button></div></div><script>const UserSettings={DEFAULT_BRANCH:"main",BASE_BROWSE_PATH:"content",ASSET_STRATEGY:"local",GLOBAL_ROOT_DIR:"static",GLOBAL_ASSET_SUBPATH:"uploads",OMIT_GLOBAL_ROOT_DIR_FROM_URL:!0,LOCAL_ASSET_SUBDIR:"",FRONTMATTER_FORMAT:"yaml",VDITOR_EDIT_MODE:"ir",DEFAULT_LANGUAGE:"en",UI_TRANSITION_DELAY_MS:500}</script><script>const resources={en:{translation:{appTitle:"GitHub-integrated Content Administration for Hugo Sites","login.title":"GitHub Login","login.warningTitle":"⚠️","login.warningText":"Using a Personal Access Token (PAT) involves security risks. Use it only in trusted environments for personal use and be careful not to expose it. This token is stored in your browser's local storage and may persist even after closing the browser. On public computers, always log out to delete the token or clear browser data after use.","login.warningStorage":"stored in the browser's local storage","login.warningLogout":"be sure to log out","login.warningPerms":"'repo'","login.patLabel":"Personal Access Token (PAT):","login.patPlaceholder":"Enter GitHub PAT ('repo' permission needed)","login.loginButton":"Login","login.loadingButton":"Logging in...","login.authCompleteButton":"Authenticated","repo.title":"Select Repository","repo.selectLabel":"Repository:","repo.selectDefaultOption":"-- Select Repository --","repo.loadButton":"Open content folder","browser.title":"File Browser","browser.currentRepoLabel":"Current Repo:","browser.branchLabel":"Branch:","browser.pathLabel":"Path:","browser.newFileButtonInFolder":"New File @ __dirName__","browser.loadingFiles":"<center>Loading folder contents...</center>","browser.emptyFolder":"(Folder is empty)","browser.emptyBaseFolder":"(folder is empty or not found)","browser.parentDirLink":".. (Parent folder)","browser.fileTooltip":"Edit file: __path__","browser.dirTooltip":"Open folder: __path__","browser.bundleTooltip":"Open Local Content (Page Bundle) folder: __path__","browser.nonEditableTooltip":"This editor can only edit markdown(.md) files (__name__)","browser.assetTooltip":"Asset file (not editable): __name__","browser.errorLoading":"<center>Could not load folder contents.</center>","browser.errorNotFound":"<center>Path '__path__' not found.</center>","browser.newFileButtonDisabledLeafBundleTooltip":"Cannot create a new file inside a leaf bundle.","browser.filterPlaceholder":"Filter by name...","browser.filterNoResults":"(No matching files or folders found)","browser.showOnlyDraftsLabel":"Drafts only","editor.title":"File Editor","editor.fm.titleLabel":"Title (Used for filename/folder generation):","editor.fm.titlePlaceholder":"Post title","editor.fm.fileNameLabel":"File Name (Includes suffix):","editor.fm.fileNamePlaceholder":"my-new-post.md (Auto-generated from Title)","editor.fm.bundlePathLabel":"Local Content Path (Includes index):","editor.fm.bundlePathPlaceholder":"my-new-content/index.md (Auto-generated from Title)","editor.fm.baseHeader":"Front Matter - Basic Fields","editor.fm.baseNote":"ℹ️ Both YAML and TOML formats are recognized on load. The content will be saved in the format specified in the configuration (currently __format__).","editor.fm.authorLabel":"Author:","editor.fm.authorPlaceholder":"(Optional) Author name","editor.fm.dateLabel":"Date (YYYY-MM-DD HH:MM)):","editor.fm.datePlaceholder":"Select or enter date and time","editor.fm.lastmodLabel":"Lastmod (YYYY-MM-DD HH:MM)):","editor.fm.lastmodPlaceholder":"Select or enter date and time (Optional)","editor.fm.descriptionLabel":"Description:","editor.fm.descriptionPlaceholder":"(Optional) Short description","editor.fm.tagsLabel":"Tags (comma-separated):","editor.fm.tagsPlaceholder":"(Optional) e.g., web, development, github","editor.fm.categoriesLabel":"Categories (comma-separated):","editor.fm.categoriesPlaceholder":"(Optional) e.g., tech, programming","editor.fm.customHeader":"Front Matter - Additional Options","editor.fm.customNote":"⚠️ Ensure custom keys do not conflict with standard fields (title, date, etc.) and are not duplicated below. Saving will be blocked if conflicts or duplicates are found. Select the appropriate type for each custom field.","editor.fm.customKeyPlaceholder":"Key","editor.fm.customValuePlaceholder":"Value","editor.fm.customTypeLabel":"Type:","editor.fm.typeString":"String","editor.fm.typeNumber":"Number","editor.fm.typeBoolean":"Boolean","editor.fm.typeDate":"Date","editor.fm.typeArrayString":"Array (String)","editor.fm.addCustomFieldButton":"Add Custom Field","editor.fm.removeCustomFieldButton":"Remove","editor.fm.removeCustomFieldButtonTooltip":"Delete this field","editor.fm.fileNameDisabledTooltip":"Filename/path cannot be changed for existing files.","editor.fm.typeBooleanTrue":"True","editor.fm.typeBooleanFalse":"False","editor.fm.dateAutoLabel":"Date Auto","editor.fm.lastmodAutoLabel":"Lastmod Auto","editor.fm.autoSetToNow":"Auto (current time)","editor.fm.manualInput":"Manual","editor.content.fileContentLabel":"File Content (Body - Markdown, etc.)","editor.commitMessageLabel":"Commit Message (Auto-generated/editable):","editor.commitMessagePlaceholder":"Auto-generated or enter manually","editor.saveDraftButton":"Draft","editor.publishButton":"Publish","editor.revertToDraftButton":"Unpublish","editor.updateAndPublishButton":"Update","editor.deleteButton":"Delete","editor.cancelButton":"Cancel","commit.create":"Create __path__ via GiCAHS","commit.update":"Update __path__ via GiCAHS","commit.delete":"Delete __path__ via GiCAHS","statusBar.statusPrefix":"Status:","statusBar.waiting":"Waiting...","statusBar.loadingRepo":"Loading '__repo__' repository '__path__'...","statusBar.loadingFolder":"Loading folder '__path__'...","statusBar.loadingFile":"Loading file '__path__'...","statusBar.repoLoaded":"Loaded __count__ repositories. Select a repository to edit.","statusBar.folderLoaded":"Loaded folder '__path__'.","statusBar.fileLoaded":"Loaded '__path__' __fmInfo__. Ready to edit.","statusBar.fileLoadedWithError":"Loaded '__path__' (Front Matter parsing error). Ready to edit.","statusBar.fmInfoYAML":"(Parsed YAML)","statusBar.fmInfoTOML":"(Parsed TOML)","statusBar.fmInfoNone":"(No FM)","statusBar.saving":"Saving changes to '__path__' (__operation__)...","statusBar.opCreateDraft":"Create Draft","statusBar.opPublishNew":"Publish New","statusBar.opUpdateDraft":"Update Draft","statusBar.opPublishUpdate":"Publish Update","statusBar.opRevertToDraft":"Revert to Draft","statusBar.opUpdatePublished":"Update Published","statusBar.deleting":"Deleting '__path__'... Preparing commit...","statusBar.deletingBundle":"Deleting Local Content folder '__path__' and all its contents... Preparing commit...","statusBar.deletingBranchIndex":"Deleting branch index '__path__' and linked assets...","statusBar.deletingLegacyDir":"Identifying related global assets in '__path__' for deletion...","statusBar.legacyDirContentsIdentified":"Marked __count__ related global files/folders in '__path__' for deletion.","statusBar.legacyDirCheckFailed":"Error identifying related global assets in '__path__'. Deletion might be incomplete.","statusBar.saveSuccess":"File '__path__' __operation__ complete (Commit: __commitSha__).","statusBar.deleteSuccess":"'__path__' deleted successfully (Commit: __commitSha__).","statusBar.deleteBranchIndexSuccess":"Branch index '__path__' and linked assets deleted (Commit: __commitSha__).","statusBar.refreshingList":"Refreshing list...","statusBar.navigatingParent":"Navigating to parent folder...","statusBar.newFileReady":"Ready to create a new file in '__path__'.","statusBar.newFileReadyBundle":"Ready to create new Local Content (Page Bundle) in '__path__'.","statusBar.newFileCreationReady":"New file creation @ '__path__'","statusBar.newFileCreationReadyBundle":"New Local Content creation @ '__path__'","statusBar.cancelled":"Edit operation cancelled.","statusBar.logout":"Logged out.","statusBar.authInProgress":"Authenticating with GitHub...","statusBar.authSuccess":"Authentication successful. Loading repository list...","statusBar.autoLoginInProgress":"Attempting auto-login with stored PAT...","statusBar.autoLoginFailed":"Auto-login failed. Please enter your PAT.","statusBar.urlAction":"Processing URL action: __path__...","statusBar.urlActionNew":"URL request: Ready to create new file/bundle in '__path__'.","statusBar.findingFile":"Looking for file '__filename__' in '__dirPath__'...","statusBar.fileFound":"Found file '__filename__'. Loading content...","statusBar.fileNotFound":"404 Error - File '__filename__' not found in '__dirPath__'.","statusBar.parentNotFound":"404 Error - Parent path '__dirPath__' not found. Cannot load file '__filename__'.","statusBar.mdExtAdded":"Warning: '.md' extension automatically added to filename.","statusBar.bundleIndexMdRequired":"Warning: Local Content requires '/index.md' or '/_index.md' suffix.","statusBar.dateSetToNow":"Info: Date automatically set to current time.","statusBar.uploadingImages":"Preparing __count__ files for commit...","statusBar.uploadingImage":"Preparing file: __filename__...","statusBar.uploadComplete":"__count__ files prepared. Creating commit...","statusBar.imagePreviewReady":"__count__ file upload placeholders ready. Will be uploaded on save.","statusBar.uploadPlaceholderReady":"__count__ file upload placeholders ready. Will be uploaded on save.","statusBar.imageUploadError":"Error preparing file '__filename__' for commit.","statusBar.checkingAssocImages":"Identifying associated assets for deletion...","statusBar.gettingImageSha":"Preparing file for commit: __image__...","statusBar.deletingUnusedImage":"Marking unused file for deletion: __image__...","statusBar.imageCleanupSuccess":"__count__ unused files marked for deletion.","statusBar.imageCleanupFailed":"Finished identifying files: __success__ marked for deletion, __count__ failed. Check console.","statusBar.imageCleanupSkipped":"Info: File cleanup skipped __count__ files (already deleted?).","statusBar.cleaningImages":"Identifying unused files for deletion...","statusBar.checkingBundleContents":"Identifying all contents of local content folder '__path__' for deletion...","statusBar.bundleContentsIdentified":"Marked __count__ files/folders in '__path__' for deletion.","statusBar.bundleContentsCheckFailed":"Error identifying local content contents for deletion in '__path__'. Deletion might be incomplete.","statusBar.creatingBlobs":"Creating blobs for __count__ files...","statusBar.creatingTree":"Creating tree object...","statusBar.creatingCommit":"Creating commit...","statusBar.updatingRef":"Updating branch reference...","statusBar.commitFailed":"Commit failed at step: __step__. Check console.","statusBar.searchingContent":"Searching for content matching '__slug__'...","statusBar.searchAttempt":"Searching for '__path__'...","statusBar.contentNotFound":"Could not find content for '__slug__' (tried index.md, _index.md, and .md).","statusBar.infoPrefix":"Info:","statusBar.patChangedLogout":"Stored token changed. Logging out for security. Please log in again.","statusBar.identifyingBranchIndexResources":"Info: Identifying resources for branch index deletion: __filePath__","statusBar.markedFileForDeletion":"Info: Marked file for deletion: __filename__","statusBar.noInitialLinksFound":"Info: No initial links found for this _index.md.","statusBar.noAssociatedAssetsFound":"Info: No associated assets found based on initial links.","statusBar.legacyAssetDirNotFound":"Info: Related global asset dir '__path__' not found.","statusBar.legacyAssetDirEmpty":"Info: Related global asset dir '__path__' empty.","statusBar.loadingStoredRepo":"Loading stored repository '__repo__'...","statusBar.loadingRepoList":"Loading repository list...",logoutButton:"Logout","prompts.confirmDelete":"Are you sure you want to permanently delete the file '__filename__'?","prompts.confirmDeleteBundle":`This is Local Content (Page Bundle)!

Are you sure you want to permanently delete the folder '__bundleName__' and ALL its contents (including images and other assets)?`,"prompts.confirmDeleteBranchBundleIndex":`You are about to delete the branch index file '__filename__'. This may also delete assets linked within this file.

The folder '__bundleName__' and its other contents WILL NOT be deleted.

This action cannot be undone!`,"prompts.confirmDeleteDetail":"This action cannot be undone!","prompts.confirmCancel":"There are unsaved changes. Are you sure you want to cancel without saving?","prompts.cancelAbort":"Cancellation aborted.","prompts.deleteCancelled":"File deletion cancelled.","errors.patRequired":"GitHub PAT is required.","errors.invalidRepo":"Please select a valid repository.","errors.apiError":"API Error: __message__","errors.authFailed":"GitHub authentication failed","errors.repoListFailed":"Failed to load repository list","errors.folderLoadFailed":"Failed to load folder contents (__path__)","errors.fileLoadFailed":"Failed to load file content (__path__)","errors.saveFailed":"Failed to save file","errors.deleteFailed":"Failed to delete","errors.deleteFailedResource":"Failed to delete '__path__'","errors.yamlParseError":"Front Matter (YAML) parsing error: __message__. Original content preserved.","errors.tomlParseError":"Front Matter (TOML) parsing error: __message__. Original content preserved.","errors.yamlFormatError":"Front Matter (YAML) generation error: __message__","errors.tomlFormatError":"Front Matter (TOML) generation error: __message__","errors.networkError":"Network error or unable to connect to GitHub API.","errors.unknownError":"An unexpected error occurred. __message__","errors.titleRequired":"'Title' is required.","errors.invalidFilename":"Valid filename/path required (e.g., name.md or folder/index.md).","errors.commitMsgRequired":"Commit message is required.","errors.invalidDate":"Invalid date format. Use 'YYYY-MM-DD HH:MM' or select from calendar.","errors.invalidCustomFieldType":"Invalid value for selected type for custom field '__key__'.","errors.vditorInitFailed":"Markdown editor (Vditor) initialization failed.","errors.vditorGetValueFailed":"Failed to get content from Vditor.","errors.vditorSetValueFailed":"Failed to set content in Vditor.","errors.imageUploadFailed":"Error preparing file for commit: __message__","errors.folderNotFound":"Resource '__path__' not found.","errors.fileNotFoundInFolder":"File '__filename__' not found within '__dirPath__'.","errors.genericApiError":"__context__ (Code: __code__): __message__","errors.authError":"__context__ (Code: 401): Authentication error. PAT may be invalid/expired.","errors.permissionError":"__context__ (Code: 403): Permission error. PAT may lack 'repo' permission or API rate limit exceeded.","errors.rateLimit":" GitHub API rate limit reached. Try again later.","errors.repoAccessDenied":" PAT lacks repository access (SSO/permissions).","errors.notFoundError":"404 Error: Resource '__path__' not found.","errors.conflictError":"__context__ (Code: 409): Conflict error (possibly SHA mismatch or branch update issue). Refresh and try again.","errors.unprocessableError":"__context__ (Code: 422): Unprocessable Entity. Issue with commit data (tree/blob?). __message__","errors.unexpectedErrorContext":"__context__: Unexpected error. __message__","errors.urlParseFailed":"Error parsing URL path. Starting in default mode.","errors.repoNotSet":"Repository information not set.","errors.missingBlob":"Invalid blob data received from API.","errors.largeFileWarn":"Warning: File size (__sizeMB__ MB) exceeds 1MB. Loading/saving may be slow.","errors.noAuth":"Not authenticated.","errors.missingContext":"Missing auth or repo context.","errors.base64Encode":"Base64 encoding failed.","errors.base64Decode":"Base64 or UTF-8 decoding failed: __message__","errors.invalidDateForFlatpickr":"Warning: Could not parse/convert date '__date__'. Displaying original value.","errors.customKeyConflict":"Warning: Custom key '__key__' conflicts with/duplicates a standard field and will be ignored.","errors.vditorNotReady":"Vditor instance not ready or available.","errors.vditorFocus":"Error focusing Vditor editor.","errors.titleFocus":"Error focusing title input.","errors.vditorTheme":"Error setting Vditor theme dynamically.","errors.vditorDestroy":"Error destroying previous Vditor instance.","errors.appInit":"Error: Application initialization failed.","errors.appLoad":"App Loading Error","errors.appError":"Application error: __message__","errors.scriptError":"Script error. Check console.","errors.blobUrl":"Error creating blob URL.","errors.previewGenFailed":"Error generating placeholder for __filename__.","errors.noFileToUpload":"No file to upload.","errors.notLoggedInForUpload":"File preparation error: Not logged into GitHub.","errors.shaFetchFailed":"Failed to get info for file __path__: __reason__","errors.imageDeleteFailed":"Failed to mark file __path__ for deletion: __reason__","errors.imageUploadFailedGeneric":"File preparation for commit failed. Cannot proceed.","errors.imageUploadFailedGenericWithMessage":"File preparation for commit failed: __message__","errors.noFileToDelete":"No file selected or loaded for deletion.","errors.deleteException":"An unexpected error occurred during the delete commit process.","errors.saveException":"An unexpected error occurred during the save commit process.","errors.fileEditPrepException":"Error preparing to edit file: __path__","errors.fileSearchLoadFailed":"Error searching for file: __path__","errors.folderBrowseException":"Error browsing folder: __path__","errors.browserErrorLoadingSevere":"Severe error loading folder contents. Check console.","errors.urlActionFailed":"Error processing URL action","errors.noAccessibleRepos":"No accessible repositories found.","errors.commitFailed":"Commit process failed: __step__","errors.bundleContentsCheckFailed":"Failed to identify local content contents for deletion in '__path__': __message__","errors.deleteBundleException":"An unexpected error occurred while preparing local content deletion for '__path__'.","errors.contentSearchFailed":"Error searching for content '__slug__': __message__","errors.searchParentDirNotFound":"Parent folder '__dirPath__' not found while searching for '__slug__'.","errors.markdownTransformError":"Error transforming Markdown paths.","errors.markdownRestoreError":"Error restoring Markdown paths.","errors.legacyDirCheckFailed":"Failed to identify related global assets for deletion in '__path__': __message__","errors.contextualNetworkError":"__context__: Network error or unable to connect to GitHub API.","errors.storedRepoLoadFailed":"Failed to load stored repository '__repo__'. Check access or select again.","errors.customKeyConflictSaveBlock":"Custom key '__key__' conflicts with a standard field and cannot be used. Please rename the key.","errors.customKeyDuplicate":"Duplicate custom key '__key__' found. Please remove duplicate fields or rename the key.","errors.lastmodBeforeDate":"Lastmod cannot be earlier than Date. Please correct the dates."}},ko:{translation:{appTitle:"Hugo 사이트용 GitHub 기반 콘텐츠 관리 도구","login.title":"GitHub 로그인","login.warningTitle":"⚠️","login.warningText":"Personal Access Token (PAT) 사용은 보안 위험이 따릅니다. 신뢰하는 환경에서 개인 용도로만 사용하고, 노출되지 않도록 주의하세요. 이 토큰은 브라우저의 로컬 스토리지에 저장되어 브라우저를 닫았다 열어도 유지될 수 있습니다. 공용 컴퓨터 등에서는 사용 후 반드시 로그아웃하여 토큰을 삭제하거나 브라우저 데이터를 정리하세요.","login.warningStorage":"브라우저의 로컬 스토리지에 저장","login.warningLogout":"반드시 로그아웃","login.warningPerms":"'repo'","login.patLabel":"Personal Access Token (PAT):","login.patPlaceholder":"GitHub PAT 입력 (repo 권한 필요)","login.loginButton":"로그인","login.loadingButton":"로그인 중...","login.authCompleteButton":"인증 완료","repo.title":"저장소 선택","repo.selectLabel":"저장소:","repo.selectDefaultOption":"-- 저장소 선택 --","repo.loadButton":"content 폴더 열기","browser.title":"파일 탐색기","browser.currentRepoLabel":"현재 저장소:","browser.branchLabel":"Branch:","browser.pathLabel":"경로:","browser.newFileButtonInFolder":"새 파일 만들기 @ __dirName__","browser.loadingFiles":"<center>폴더 내용 로딩 중...</center>","browser.emptyFolder":"(폴더가 비어 있습니다)","browser.emptyBaseFolder":"(폴더가 비어 있거나 찾을 수 없습니다)","browser.parentDirLink":".. (상위 폴더)","browser.fileTooltip":"파일 수정: __path__","browser.dirTooltip":"폴더 열기: __path__","browser.bundleTooltip":"로컬 컨텐츠 (페이지 번들) 폴더 열기: __path__","browser.nonEditableTooltip":"이 편집기는 마크다운(.md) 파일만 편집 가능 (__name__)","browser.assetTooltip":"에셋 파일 (편집 불가): __name__","browser.errorLoading":"<center>폴더 내용을 불러올 수 없습니다.</center>","browser.errorNotFound":"<center>경로 '__path__'을(를) 찾을 수 없습니다.</center>","browser.newFileButtonDisabledLeafBundleTooltip":"리프 번들 안에는 새 파일을 만들 수 없습니다.","browser.filterPlaceholder":"이름으로 필터링...","browser.filterNoResults":"(일치하는 파일이나 폴더가 없습니다)","browser.showOnlyDraftsLabel":"초안만","editor.title":"파일 편집기","editor.fm.titleLabel":"Title (파일명/폴더명 생성에 사용):","editor.fm.titlePlaceholder":"게시물 제목","editor.fm.fileNameLabel":"파일 이름 (확장자 포함):","editor.fm.fileNamePlaceholder":"my-new-post.md (Title 입력 시 자동 생성)","editor.fm.bundlePathLabel":"로컬 컨텐츠 경로 (index 포함):","editor.fm.bundlePathPlaceholder":"my-new-content/index.md (Title 입력 시 자동 생성)","editor.fm.baseHeader":"Front Matter - 기본 항목","editor.fm.baseNote":"ℹ️ 불러올 때는 YAML 또는 TOML 형식을 인식하며 저장 시에는 설정된 형식(현재 __format__)으로 변환됩니다.","editor.fm.authorLabel":"Author:","editor.fm.authorPlaceholder":"(선택) 작성자","editor.fm.dateLabel":"Date (YYYY-MM-DD HH:MM):","editor.fm.datePlaceholder":"날짜 및 시간 선택 또는 입력","editor.fm.lastmodLabel":"Lastmod (YYYY-MM-DD HH:MM):","editor.fm.lastmodPlaceholder":"날짜 및 시간 선택 또는 입력 (선택 사항)","editor.fm.descriptionLabel":"Description:","editor.fm.descriptionPlaceholder":"(선택) 간단한 설명","editor.fm.tagsLabel":"Tags (쉼표로 구분):","editor.fm.tagsPlaceholder":"(선택) 예: web, development, github","editor.fm.categoriesLabel":"Categories (쉼표로 구분):","editor.fm.categoriesPlaceholder":"(선택) 예: tech, programming","editor.fm.customHeader":"Front Matter -추가 선택","editor.fm.customNote":"⚠️ 사용자 정의 키는 기본 필드('title', 'date' 등)와 충돌하거나, 추가 필드 내에서 중복될 수 없습니다. 충돌 또는 중복이 있으면 저장이 차단됩니다. 각 추가 필드에 대해 올바른 타입을 선택해주세요.","editor.fm.customKeyPlaceholder":"키 (Key)","editor.fm.customValuePlaceholder":"값 (Value)","editor.fm.customTypeLabel":"타입:","editor.fm.typeString":"문자열","editor.fm.typeNumber":"숫자","editor.fm.typeBoolean":"불리언","editor.fm.typeDate":"날짜","editor.fm.typeArrayString":"배열(문자열)","editor.fm.addCustomFieldButton":"추가 필드 입력","editor.fm.removeCustomFieldButton":"삭제","editor.fm.removeCustomFieldButtonTooltip":"이 필드 삭제","editor.fm.fileNameDisabledTooltip":"기존 파일의 이름/경로는 변경할 수 없습니다.","editor.fm.typeBooleanTrue":"참","editor.fm.typeBooleanFalse":"거짓","editor.fm.dateAutoLabel":"Date 자동","editor.fm.lastmodAutoLabel":"Lastmod 자동","editor.fm.autoSetToNow":"자동 (현재 시간)","editor.fm.manualInput":"수동","editor.content.fileContentLabel":"파일 내용 (본문 - Markdown 등)","editor.commitMessageLabel":"커밋 메시지 (자동 생성/편집 가능):","editor.commitMessagePlaceholder":"자동 생성 또는 직접 입력","editor.saveDraftButton":"초안","editor.publishButton":"공개","editor.revertToDraftButton":"비공개","editor.updateAndPublishButton":"공개","editor.deleteButton":"삭제","editor.cancelButton":"취소","commit.create":"GiCAHS: __path__ 생성","commit.update":"GiCAHS: __path__ 업데이트","commit.delete":"GiCAHS: __path__ 삭제","statusBar.statusPrefix":"상태:","statusBar.waiting":"대기 중...","statusBar.loadingRepo":"'__repo__' 저장소 '__path__' 로딩 중...","statusBar.loadingFolder":"폴더 '__path__' 로딩 중...","statusBar.loadingFile":"파일 '__path__' 로딩 중...","statusBar.repoLoaded":"__count__개 저장소 로드 완료. 편집할 저장소를 선택하세요.","statusBar.folderLoaded":"폴더 '__path__' 로드 완료.","statusBar.fileLoaded":"'__path__' 로드 완료 __fmInfo__. 편집 가능.","statusBar.fileLoadedWithError":"'__path__' 로드 완료 (Front Matter 파싱 오류). 편집 가능.","statusBar.fmInfoYAML":"(YAML 파싱됨)","statusBar.fmInfoTOML":"(TOML 파싱됨)","statusBar.fmInfoNone":"(FM 없음)","statusBar.saving":"'__path__' 변경사항 저장 중 (__operation__)...","statusBar.opCreateDraft":"초안 생성","statusBar.opPublishNew":"새로 공개","statusBar.opUpdateDraft":"초안 갱신","statusBar.opPublishUpdate":"공개","statusBar.opRevertToDraft":"초안으로","statusBar.opUpdatePublished":"공개된 글 업데이트","statusBar.deleting":"'__path__' 삭제 중...","statusBar.deletingBundle":"로컬 컨텐츠 폴더 '__path__' 및 모든 내용 삭제 중...","statusBar.deletingBranchIndex":"브랜치 인덱스 '__path__' 및 링크된 에셋 삭제 중...","statusBar.deletingLegacyDir":"'__path__' 내 연관된 전역 에셋 삭제 준비 중...","statusBar.legacyDirContentsIdentified":"'__path__' 내 연관된 전역 파일/폴더 __count__개 삭제 대상으로 표시.","statusBar.legacyDirCheckFailed":"오류 - '__path__' 연관 전역 에셋 식별 실패. 삭제가 불완전할 수 있음.","statusBar.saveSuccess":"파일 '__path__' __operation__ 완료 (Commit: __commitSha__).","statusBar.deleteSuccess":"'__path__' 삭제 완료 (Commit: __commitSha__).","statusBar.deleteBranchIndexSuccess":"브랜치 인덱스 '__path__' 및 링크된 에셋 삭제 완료 (Commit: __commitSha__).","statusBar.refreshingList":"목록 새로고침 중...","statusBar.navigatingParent":"상위 폴더로 이동 중...","statusBar.newFileReady":"현재 폴더('__path__')에 새 파일 생성 준비 완료.","statusBar.newFileReadyBundle":"현재 폴더('__path__')에 새 로컬 컨텐츠(페이지 번들) 생성 준비 완료.","statusBar.newFileCreationReady":"새 파일 작성 @ '__path__'","statusBar.newFileCreationReadyBundle":"새 로컬 컨텐츠 작성 @ '__path__'","statusBar.cancelled":"편집 작업 취소됨.","statusBar.logout":"로그아웃됨.","statusBar.authInProgress":"GitHub 인증 진행 중...","statusBar.authSuccess":"인증 성공. 저장소 목록 로딩 중...","statusBar.autoLoginInProgress":"저장된 PAT로 자동 로그인 시도 중...","statusBar.autoLoginFailed":"자동 로그인 실패. PAT를 다시 입력하세요.","statusBar.urlAction":"URL 작업 처리 중: __path__...","statusBar.urlActionNew":"URL 요청: '__path__' 폴더에 새 파일/번들 생성 준비 완료.","statusBar.findingFile":"'__dirPath__' 폴더에서 '__filename__' 파일 찾는 중...","statusBar.fileFound":"'__filename__' 파일 찾음. 내용 로딩 중...","statusBar.fileNotFound":"404 오류 - '__dirPath__' 폴더 내에서 '__filename__' 파일을 찾을 수 없음.","statusBar.parentNotFound":"404 오류 - 상위 경로 '__dirPath__'를 찾을 수 없음. 파일 '__filename__' 로드 불가.","statusBar.mdExtAdded":"경고: 파일명에 '.md' 확장자가 자동 추가되었습니다.","statusBar.bundleIndexMdRequired":"경고: 로컬 컨텐츠는 '/index.md' 또는 '/_index.md'로 끝나야 합니다.","statusBar.dateSetToNow":"정보: 날짜가 현재 시간으로 자동 설정되었습니다.","statusBar.uploadingImages":"__count__개 파일 커밋 준비 중...","statusBar.uploadingImage":"파일 커밋 준비 중: __filename__...","statusBar.uploadComplete":"__count__개 파일 준비 완료. 커밋 생성 중...","statusBar.imagePreviewReady":"__count__개 파일 업로드 준비 완료. 저장 시 커밋됩니다.","statusBar.uploadPlaceholderReady":"__count__개 파일 업로드 준비 완료. 저장 시 커밋됩니다.","statusBar.imageUploadError":"오류 - '__filename__' 파일 커밋 준비 실패.","statusBar.checkingAssocImages":"삭제할 연관 에셋 식별 중...","statusBar.gettingImageSha":"커밋할 파일 준비 중: __image__...","statusBar.deletingUnusedImage":"미사용 파일 삭제 대상으로 표시 중: __image__...","statusBar.imageCleanupSuccess":"미사용 파일 __count__개 삭제 대상으로 표시 완료.","statusBar.imageCleanupFailed":"파일 식별 완료: __success__개 삭제 표시, __count__개 실패. 콘솔 확인.","statusBar.imageCleanupSkipped":"정보: 파일 정리 중 __count__개 건너뜀 (이미 삭제됨?).","statusBar.cleaningImages":"삭제할 미사용 파일 식별 중...","statusBar.checkingBundleContents":"삭제할 로컬 컨텐츠 폴더 '__path__'의 모든 내용 식별 중...","statusBar.bundleContentsIdentified":"'__path__' 내 파일/폴더 __count__개 삭제 대상으로 표시 완료.","statusBar.bundleContentsCheckFailed":"오류 - '__path__' 로컬 컨텐츠 내용 식별 실패. 삭제가 불완전할 수 있음.","statusBar.creatingBlobs":"__count__개 파일 Blob 생성 중...","statusBar.creatingTree":"Tree 객체 생성 중...","statusBar.creatingCommit":"Commit 객체 생성 중...","statusBar.updatingRef":"브랜치 참조 업데이트 중...","statusBar.commitFailed":"커밋 실패 (단계: __step__). 콘솔 확인 필요.","statusBar.searchingContent":"'__slug__' 컨텐츠 검색 중...","statusBar.searchAttempt":"'__path__' 검색 시도 중...","statusBar.contentNotFound":"'__slug__' 컨텐츠를 찾을 수 없음 (index.md, _index.md, .md 시도함).","statusBar.infoPrefix":"정보:","statusBar.patChangedLogout":"저장된 토큰이 변경되어 로그아웃합니다. 다시 로그인해주세요.","statusBar.identifyingBranchIndexResources":"정보: 브랜치 인덱스 삭제를 위한 리소스 식별 중: __filePath__","statusBar.markedFileForDeletion":"정보: 파일 삭제 대상으로 표시: __filename__","statusBar.noInitialLinksFound":"정보: 이 _index.md에 대한 초기 링크를 찾을 수 없습니다.","statusBar.noAssociatedAssetsFound":"정보: 초기 링크 기반 연관 에셋을 찾을 수 없습니다.","statusBar.legacyAssetDirNotFound":"정보: 연관된 전역 에셋 폴더 '__path__'을(를) 찾을 수 없습니다.","statusBar.legacyAssetDirEmpty":"정보: 연관된 전역 에셋 폴더 '__path__'이(가) 비어 있습니다.","statusBar.loadingStoredRepo":"저장된 저장소 '__repo__' 로딩 중...","statusBar.loadingRepoList":"저장소 목록 로딩 중...",logoutButton:"로그아웃","prompts.confirmDelete":"정말로 '__filename__' 파일을 영구 삭제하시겠습니까?","prompts.confirmDeleteBundle":`로컬 컨텐츠 (페이지 번들)입니다!

정말로 '__bundleName__' 폴더와 그 안의 모든 내용(이미지, 기타 에셋 포함)을 영구 삭제하시겠습니까?`,"prompts.confirmDeleteBranchBundleIndex":`브랜치 인덱스 파일 '__filename__'을(를) 삭제하려고 합니다. 이 파일 내에 링크된 에셋 파일들도 함께 삭제될 수 있습니다.

하지만 '__bundleName__' 폴더와 그 안의 다른 파일/폴더들은 삭제되지 않습니다.

이 작업은 되돌릴 수 없습니다!`,"prompts.confirmDeleteDetail":"이 작업은 되돌릴 수 없습니다!","prompts.confirmCancel":"저장되지 않은 변경 사항이 있습니다. 저장하지 않고 계속하시겠습니까?","prompts.cancelAbort":"취소 작업 중단됨.","prompts.deleteCancelled":"파일 삭제 취소됨.","errors.patRequired":"GitHub PAT를 입력해주세요.","errors.invalidRepo":"유효한 저장소를 선택해주세요.","errors.apiError":"API 오류: __message__","errors.authFailed":"GitHub 인증 실패","errors.repoListFailed":"저장소 목록 로딩 실패","errors.folderLoadFailed":"폴더 내용 로드 실패 (__path__)","errors.fileLoadFailed":"파일 내용 로딩 실패 (__path__)","errors.saveFailed":"파일 저장 실패","errors.deleteFailed":"삭제 실패","errors.deleteFailedResource":"'__path__' 삭제 실패","errors.yamlParseError":"Front Matter (YAML) 파싱 오류: __message__. 원본 내용 유지.","errors.tomlParseError":"Front Matter (TOML) 파싱 오류: __message__. 원본 내용 유지.","errors.yamlFormatError":"Front Matter (YAML) 생성 오류: __message__","errors.tomlFormatError":"Front Matter (TOML) 생성 오류: __message__","errors.networkError":"네트워크 오류 또는 GitHub API 연결 불가.","errors.unknownError":"예상치 못한 오류 발생. __message__","errors.titleRequired":"'Title'은 필수 항목입니다.","errors.invalidFilename":"유효한 파일명/경로 필요 (예: name.md 또는 folder/index.md).","errors.commitMsgRequired":"커밋 메시지가 필요합니다.","errors.invalidDate":"날짜 형식 오류. 'YYYY-MM-DD HH:MM' 형식을 사용하거나 달력에서 선택하세요.","errors.invalidCustomFieldType":"추가 필드 '__key__'의 선택된 타입에 대한 값이 유효하지 않습니다.","errors.vditorInitFailed":"Markdown 편집기(Vditor) 초기화 실패.","errors.vditorGetValueFailed":"Vditor 내용 가져오기 오류.","errors.vditorSetValueFailed":"Vditor 내용 설정 오류.","errors.imageUploadFailed":"파일 커밋 준비 중 오류 발생: __message__","errors.folderNotFound":"리소스 '__path__' 찾을 수 없음.","errors.fileNotFoundInFolder":"'__dirPath__' 폴더 내에서 파일 '__filename__'을(를) 찾을 수 없습니다.","errors.genericApiError":"__context__ (코드: __code__): __message__","errors.authError":"__context__ (코드: 401): 인증 오류. PAT가 유효하지 않거나 만료되었을 수 있습니다.","errors.permissionError":"__context__ (Code: 403): 권한 오류. PAT에 'repo' 권한이 없거나 API 속도 제한일 수 있습니다.","errors.rateLimit":" GitHub API 속도 제한 도달. 잠시 후 다시 시도.","errors.repoAccessDenied":" PAT에 저장소 접근 권한 없음 (SSO/권한).","errors.notFoundError":"404 오류: 리소스 '__path__' 찾을 수 없음.","errors.conflictError":"__context__ (Code: 409): 충돌 오류 (SHA 불일치 또는 브랜치 업데이트 문제). 새로고침 후 재시도.","errors.unprocessableError":"__context__ (Code: 422): 처리 불가 엔티티. 커밋 데이터 오류 (tree/blob?). __message__","errors.unexpectedErrorContext":"__context__: 예상치 못한 오류. __message__","errors.urlParseFailed":"오류: URL 경로 파싱 실패. 기본 모드로 시작합니다.","errors.repoNotSet":"오류: 저장소 정보 없음.","errors.missingBlob":"API로부터 잘못된 blob 데이터를 받았습니다.","errors.largeFileWarn":"경고: 파일 크기(__sizeMB__ MB)가 1MB를 초과합니다. 로딩/저장이 느릴 수 있습니다.","errors.noAuth":"인증되지 않았습니다.","errors.missingContext":"인증 또는 저장소 컨텍스트가 없습니다.","errors.base64Encode":"Base64 인코딩 중 오류 발생.","errors.base64Decode":"Base64 또는 UTF-8 디코딩 중 오류 발생: __message__","errors.invalidDateForFlatpickr":"경고: 날짜 '__date__' 형식을 인식/변환하지 못했습니다. 원본 값을 표시합니다.","errors.customKeyConflict":"경고: 사용자 정의 키 '__key__'가 기본 필드와 충돌/중복되어 무시됩니다.","errors.vditorNotReady":"Vditor 인스턴스가 준비되지 않았거나 사용할 수 없습니다.","errors.vditorFocus":"Vditor 편집기 포커스 중 오류.","errors.titleFocus":"제목 입력 필드 포커스 중 오류.","errors.vditorTheme":"Vditor 테마 동적 설정 중 오류.","errors.vditorDestroy":"이전 Vditor 인스턴스 제거 중 오류.","errors.appInit":"오류: 애플리케이션 초기화 실패.","errors.appLoad":"앱 로드 오류","errors.appError":"애플리케이션 오류: __message__","errors.scriptError":"스크립트 오류. 콘솔 확인.","errors.blobUrl":"Blob URL 생성 오류.","errors.previewGenFailed":"오류: __filename__ 플레이스홀더 생성 실패.","errors.noFileToUpload":"업로드할 파일 없음.","errors.notLoggedInForUpload":"파일 준비 오류: GitHub에 로그인되지 않았습니다.","errors.shaFetchFailed":"파일 __path__ 정보 가져오기 실패: __reason__","errors.imageDeleteFailed":"파일 __path__ 삭제 대상으로 표시 실패: __reason__","errors.imageUploadFailedGeneric":"파일 커밋 준비 실패. 저장을 진행할 수 없습니다.","errors.imageUploadFailedGenericWithMessage":"파일 커밋 준비 실패: __message__","errors.noFileToDelete":"삭제할 파일이 선택되거나 로드되지 않았습니다.","errors.deleteException":"삭제 커밋 과정 중 예상치 못한 오류가 발생했습니다.","errors.saveException":"저장 커밋 과정 중 예상치 못한 오류가 발생했습니다.","errors.fileEditPrepException":"파일 편집 준비 중 오류: __path__","errors.fileSearchLoadFailed":"파일 검색 중 오류: __path__","errors.folderBrowseException":"폴더 탐색 중 오류: __path__","errors.browserErrorLoadingSevere":"폴더 내용 로드 중 심각한 오류 발생. 콘솔 확인.","errors.urlActionFailed":"URL 작업 처리 중 오류 발생","errors.noAccessibleRepos":"접근 가능한 저장소가 없습니다.","errors.commitFailed":"커밋 프로세스 실패: __step__","errors.bundleContentsCheckFailed":"'__path__' 로컬 컨텐츠 내용 삭제 식별 실패: __message__","errors.deleteBundleException":"'__path__' 로컬 컨텐츠 삭제 준비 중 예상치 못한 오류 발생.","errors.contentSearchFailed":"'__slug__' 컨텐츠 검색 오류: __message__","errors.searchParentDirNotFound":"'__slug__' 검색 중 상위 폴더 '__dirPath__' 찾을 수 없음.","errors.markdownTransformError":"마크다운 경로 변환 중 오류.","errors.markdownRestoreError":"마크다운 경로 복원 중 오류.","errors.legacyDirCheckFailed":"오류 - '__path__' 연관 전역 에셋 식별 실패: __message__","errors.contextualNetworkError":"__context__: 네트워크 오류 또는 GitHub API 연결 불가.","errors.storedRepoLoadFailed":"저장된 저장소 '__repo__' 로드 실패. 접근 권한 확인 또는 재선택 필요.","errors.customKeyConflictSaveBlock":"커스텀 키 '__key__'는 기본 필드와 충돌하여 사용할 수 없습니다. 키 이름을 수정해주세요.","errors.customKeyDuplicate":"커스텀 필드에 중복된 키 '__key__'가 있습니다. 중복된 필드를 제거하거나 키 이름을 수정해주세요.","errors.lastmodBeforeDate":"Lastmod는 Date보다 이전일 수 없습니다. 날짜를 수정해주세요."}}}</script><script>window.hugoPermalinkMap={};try{window.hugoPermalinkMap=JSON.parse('{"admin":"admin","archive":"archive","new":"new","posts/a-walk-in-the-rain":"blog/2024/a-walk-in-the-rain-with-an-umbrella","posts/baking-bread-for-the-first-time":"blog/2023/baking-bread-for-the-first-time","posts/cozy-evening-with-book-and-blanket":"blog/2023/a-cozy-evening-with-a-book-and-blanket","posts/creating-a-vision-board-for-goals":"blog/2025/creating-a-vision-board-for-goals","posts/decluttering-digital-files":"blog/2025/decluttering-digital-files","posts/emoji-support":"blog/2025/emoji-support","posts/exploring-new-city-on-foot":"blog/2024/exploring-a-new-city-on-foot","posts/finding-inspriattion-in-nature":"blog/2023/finding-inspiration-in-nature","posts/first-snowfall-of-the-year":"blog/2023/first-snowfall-of-the-year","posts/gardening-updates-spring-is-coming":"blog/2024/gardening-updates-spring-is-coming","posts/important-of-saying-no":"blog/1","posts/learing-from-feeback-even-whe-its-hard":"blog/2024/learning-from-feedback-even-when-its-hard","posts/learning-new-language-challenges":"blog/2024/learning-a-new-language-challenges","posts/listening-to-vinyl-records":"blog/2023/listening-to-vinyl-records","posts/making-homemade-pizza":"blog/2024/making-homemade-pizza","posts/markdown-test-hehe":"blog/2025/markdown-test","posts/morining-meditation-practice":"blog/2024/morning-meditation-practice","posts/placeholder-text":"blog/2025/placeholder-text","posts/planning-th-next-project":"blog/2023/planning-the-next-project","posts/setting-up-a-new-development-environment":"blog/2024/setting-up-a-new-development-environment","posts/the-beauty-of=imperection":"blog/2024/the-beauty-of-imperfection-wabi-sabi","posts/the-benefits-of-walking-barefoot-on-grass":"blog/2024/the-benefits-of-walking-barefoot-on-grass-earthing","posts/the-challenge-of-staying-focused-in-a-distraced-world":"blog/2023/the-challenge-of-staying-focused-in-a-distracted-world","posts/the-importance-of-active-listening":"blog/2024/the-importance-of-active-listening","posts/the-joy-of-rediscovering-old-music":"blog/2024/the-joy-of-rediscovering-old-music","posts/the-power-of-good-nights-sleep":"blog/2023/the-power-of-a-good-nights-sleep","posts/the-satisfaction-of-crossing-things-off-a-todo-list":"blog/2023/the-satisfaction-of-crossing-things-off-a-to-do-list","posts/the-simple-pleasure-of-clean-deks":"blog/2023/the-simple-pleasure-of-a-clean-desk","posts/thoughts-on-creativity-and-inspiration":"blog/2024/thoughts-on-creativity-and-inspiration","posts/trying-mind-mapping-for-ideas":"blog/2024/trying-mind-mapping-for-ideas","posts/trying-out-new-productitity-app":"blog/2024/trying-out-a-new-productivity-app","posts/visit-to-the-art-museum":"blog/2025/a-visit-to-the-art-museum","posts/김치찌개-맛있게-끓이는-법":"blog/2024/%EA%B9%80%EC%B9%98%EC%B0%8C%EA%B0%9C-%EB%A7%9B%EC%9E%88%EA%B2%8C-%EB%81%93%EC%9D%B4%EB%8A%94-%EB%B2%95","posts/나만의-스트레스-해소법":"blog/2024/%EB%82%98%EB%A7%8C%EC%9D%98-%EC%8A%A4%ED%8A%B8%EB%A0%88%EC%8A%A4-%ED%95%B4%EC%86%8C%EB%B2%95","posts/늦가을의-쓸쓸함과-아름다움":"blog/2023/%EB%8A%A6%EA%B0%80%EC%9D%84%EC%9D%98-%EC%93%B8%EC%93%B8%ED%95%A8%EA%B3%BC-%EC%95%84%EB%A6%84%EB%8B%A4%EC%9B%80","posts/동네-서점-탐방기":"blog/2024/%EB%8F%99%EB%84%A4-%EC%84%9C%EC%A0%90-%ED%83%90%EB%B0%A9%EA%B8%B0","posts/따뜻한-뱅쇼-만들기":"blog/2023/%EB%94%B0%EB%9C%BB%ED%95%9C-%EB%B1%85%EC%87%BC-%EB%A7%8C%EB%93%A4%EA%B8%B0","posts/따뜻한-봄날의-자전거-타기":"blog/2022/%EB%94%B0%EB%9C%BB%ED%95%9C-%EB%B4%84%EB%82%A0%EC%9D%98-%EC%9E%90%EC%A0%84%EA%B1%B0-%ED%83%80%EA%B8%B0","posts/멍하니-바라본-하늘":"blog/2023/%EB%A9%8D%ED%95%98%EB%8B%88-%EB%B0%94%EB%9D%BC%EB%B3%B8-%ED%95%98%EB%8A%98","posts/보드게임-하는-밤":"blog/2023/%EB%B3%B4%EB%93%9C%EA%B2%8C%EC%9E%84-%ED%95%98%EB%8A%94-%EB%B0%A4","posts/봄맞이-옷장-정리":"blog/2024/%EB%B4%84%EB%A7%9E%EC%9D%B4-%EC%98%B7%EC%9E%A5-%EC%A0%95%EB%A6%AC","posts/새해-다짐과-목표-설정":"blog/2024/%EC%83%88%ED%95%B4-%EB%8B%A4%EC%A7%90%EA%B3%BC-%EB%AA%A9%ED%91%9C-%EC%84%A4%EC%A0%95","posts/손편지-쓰기":"blog/2023/%EC%86%90%ED%8E%B8%EC%A7%80-%EC%93%B0%EA%B8%B0","posts/시장-구경과-길거리-음식":"blog/2024/the-importance-of-saying-no","posts/오래된-물건에-담긴-이야기":"blog/2023/%EC%98%A4%EB%9E%98%EB%90%9C-%EB%AC%BC%EA%B1%B4%EC%97%90-%EB%8B%B4%EA%B8%B4-%EC%9D%B4%EC%95%BC%EA%B8%B0","posts/오랜만에-만난-친구":"blog/2023/%EC%98%A4%EB%9E%9C%EB%A7%8C%EC%97%90-%EB%A7%8C%EB%82%9C-%EC%B9%9C%EA%B5%AC","posts/운동-다시-시작하기":"blog/2023/%EC%9A%B4%EB%8F%99-%EB%8B%A4%EC%8B%9C-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0","posts/저녁-노을이-아름다운-날":"blog/2023/%EC%A0%80%EB%85%81-%EB%85%B8%EC%9D%84%EC%9D%B4-%EC%95%84%EB%A6%84%EB%8B%A4%EC%9A%B4-%EB%82%A0","posts/저녁-산책길에-만난-고양이":"blog/2023/%EC%A0%80%EB%85%81-%EC%82%B0%EC%B1%85%EA%B8%B8%EC%97%90-%EB%A7%8C%EB%82%9C-%EA%B3%A0%EC%96%91%EC%9D%B4","posts/제주도-여행-준비":"blog/2023/%EC%A0%9C%EC%A3%BC%EB%8F%84-%EC%97%AC%ED%96%89-%EC%A4%80%EB%B9%84","posts/조조영화-보기":"blog/2023/%EC%A1%B0%EC%A1%B0%EC%98%81%ED%99%94-%EB%B3%B4%EA%B8%B0","posts/주말-농장-가꾸기":"blog/2024/%EC%A3%BC%EB%A7%90-%EB%86%8D%EC%9E%A5-%EA%B0%80%EA%BE%B8%EA%B8%B0","posts/주말-대청소-후기":"blog/2023/%EC%A3%BC%EB%A7%90-%EB%8C%80%EC%B2%AD%EC%86%8C-%ED%9B%84%EA%B8%B0","posts/집에서-키우는-반려식물":"blog/2023/%EC%A7%91%EC%97%90%EC%84%9C-%ED%82%A4%EC%9A%B0%EB%8A%94-%EB%B0%98%EB%A0%A4%EC%8B%9D%EB%AC%BC","posts/창밖으로-보이는-풍경":"blog/2024/%EC%B0%BD%EB%B0%96%EC%9C%BC%EB%A1%9C-%EB%B3%B4%EC%9D%B4%EB%8A%94-%ED%92%8D%EA%B2%BD","posts/퇴근길-지하철에서":"blog/2023/%ED%87%B4%EA%B7%BC%EA%B8%B8-%EC%A7%80%ED%95%98%EC%B2%A0%EC%97%90%EC%84%9C","posts/햇살-좋은-날의-공원":"blog/2024/%ED%96%87%EC%82%B4-%EC%A2%8B%EC%9D%80-%EB%82%A0%EC%9D%98-%EA%B3%B5%EC%9B%90","posts/흐린-날의-매력":"blog/2023/%ED%9D%90%EB%A6%B0-%EB%82%A0%EC%9D%98-%EB%A7%A4%EB%A0%A5","test/markdown-syntax":"test/markdown-syntax","test/math-typesetting":"test/math-typesetting","test/placeholder-text":"test/placeholder-text","test/rich-content":"test/rich-content"}')}catch{window.hugoPermalinkMap={}}</script><script type=module>
        import { Octokit } from "https://esm.sh/octokit";
        import { marked } from 'https://esm.sh/marked';
        import Vditor from 'https://esm.sh/vditor';
        import * as jsyaml from 'https://esm.sh/js-yaml@4';
        import * as TOML from 'https://cdn.jsdelivr.net/npm/@iarna/toml@2.2.5/+esm';
        import i18next from 'https://esm.sh/i18next';
        import flatpickr from 'https://esm.sh/flatpickr';
        import { Korean } from 'https://esm.sh/flatpickr/dist/l10n/ko.js';
        import { Mandarin as Chinese } from 'https://esm.sh/flatpickr/dist/l10n/zh.js';
        import { Japanese } from 'https://esm.sh/flatpickr/dist/l10n/ja.js';
        import { Spanish } from 'https://esm.sh/flatpickr/dist/l10n/es.js';
        import { German } from 'https://esm.sh/flatpickr/dist/l10n/de.js';
        import { French } from 'https://esm.sh/flatpickr/dist/l10n/fr.js';
        import { Portuguese } from 'https://esm.sh/flatpickr/dist/l10n/pt.js';
        import { Russian } from 'https://esm.sh/flatpickr/dist/l10n/ru.js';
        import path from 'https://esm.sh/path-browserify';
        import isEqual from 'https://esm.sh/fast-deep-equal';
        import Tagify from 'https://cdn.jsdelivr.net/npm/@yaireo/tagify/+esm';
        const AppConstants = {
            PAT_STORAGE_KEY: 'githubPat',
            SELECTED_REPO_KEY: 'selectedGitHubRepo',
            STANDARD_FM_KEYS: [
                'title', 'author', 'date', 'lastmod', 'description', 'tags', 'categories', 'draft'
            ],
            SUPPORTED_LANGUAGES: [
                { code: 'en', name: 'English', flatpickr: 'en' },
                { code: 'ko', name: 'Korean', flatpickr: 'ko' },
                { code: 'zh', name: '中文 (简体)', flatpickr: 'zh' },
                { code: 'ja', name: '日本語', flatpickr: 'ja' },
                { code: 'es', name: 'Español', flatpickr: 'es' },
                { code: 'de', name: 'Deutsch', flatpickr: 'de' },
                { code: 'fr', name: 'Français', flatpickr: 'fr' },
                { code: 'pt', name: 'Português', flatpickr: 'pt' },
                { code: 'ru', name: 'Русский', flatpickr: 'ru' },
            ],
            ACTIVE_EDIT_CLASS: 'active-edit-item',
            CUSTOM_FM_TYPES: [
                { value: 'string', labelKey: 'editor.fm.typeString', inputType: 'text' },
                { value: 'number', labelKey: 'editor.fm.typeNumber', inputType: 'text', inputMode: 'numeric' },
                { value: 'boolean', labelKey: 'editor.fm.typeBoolean', inputType: 'checkbox' },
                { value: 'date', labelKey: 'editor.fm.typeDate', inputType: 'text', isDate: true },
                { value: 'array', labelKey: 'editor.fm.typeArrayString', inputType: 'text' }
            ],
        };
        const FM_FIELD_CONFIG = [
            { key: 'title', type: 'string', elementId: 'fmTitleInput', required: true },
            { key: 'date', type: 'datetime', elementId: 'fmDateInput', autoCheckboxId: 'fmDateAutoCheckbox', autoLabelId: 'fmDateAutoLabel' },
            { key: 'lastmod', type: 'datetime', elementId: 'fmLastmodInput', autoCheckboxId: 'fmLastmodAutoCheckbox', autoLabelId: 'fmLastmodAutoLabel' },
            { key: 'author', type: 'string', elementId: 'fmAuthorInput' },
            { key: 'description', type: 'string', elementId: 'fmDescriptionInput' },
            { key: 'tags', type: 'array', elementId: 'fmTagsInput' },
            { key: 'categories', type: 'array', elementId: 'fmCategoriesInput' },
        ];
        const PathUtils = {
            normalizePath: (p) => path.normalize(p || '').replace(/\\/g, '/'),
            joinPaths: (...parts) => PathUtils.normalizePath(path.join(...parts.filter(p => p != null && String(p).trim()))),
            getDirname: (p) => PathUtils.normalizePath(path.dirname(p || '')),
            getBasename: (p) => path.basename(p || ''),
            escapeRegex: (string) => string.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&'),
            isPageBundlePath: (filePath) => typeof filePath === 'string' && filePath.toLowerCase().endsWith('/index.md'),
            isBranchBundlePath: (filePath) => typeof filePath === 'string' && filePath.toLowerCase().endsWith('/_index.md'),
            isAnyBundlePath(filePath) {
                return PathUtils.isPageBundlePath(filePath) || PathUtils.isBranchBundlePath(filePath);
            },
            getBundleDir(bundleIndexPath) {
                return PathUtils.isAnyBundlePath(bundleIndexPath) ? PathUtils.getDirname(bundleIndexPath) : null;
            },
            getSlugFromFilename(filePath) {
                const filename = PathUtils.getBasename(filePath);
                if ((filename === 'index.md' || filename === '_index.md') && filePath.includes('/')) {
                    return PathUtils.getBasename(PathUtils.getDirname(filePath));
                } else if (filename.toLowerCase().endsWith('.md')) {
                    return filename.substring(0, filename.length - 3);
                }
                return filename;
            },
            generateFilename(title) {
                if (!title || !title.trim()) {
                    return 'untitled';
                }
                let slug = title.trim();
                slug = slug.replace(/\s+/g, '-');
                slug = slug.replace(/[^\p{L}\p{N}\-_]/gu, '');
                slug = slug.toLowerCase();
                slug = slug.replace(/-+/g, '-');
                slug = slug.replace(/^-+|-+$/g, '');
                if (!slug || slug.length === 0) {
                    slug = 'untitled';
                } else if (slug.length > 100) {
                    slug = slug.substring(0, 100);
                }
                return slug;
            },
            sanitizeFilename(name) {
                const ext = path.extname(name);
                let baseName = path.basename(name, ext);
                baseName = baseName.replace(/\s+/g, '-');
                baseName = baseName.replace(/[^\p{L}\p{N}\-_\.]/gu, '');
                baseName = baseName.toLowerCase();
                baseName = baseName.replace(/-+/g, '-');
                baseName = baseName.replace(/^-+|-+$/g, '');
                if (!baseName || baseName.length === 0) {
                    baseName = 'file';
                } else if (baseName.length > 200) {
                    baseName = baseName.substring(0, 200);
                }
                return baseName + ext;
            },
            calculateWebBasePath(filePath) {
                const normalizedBasePath = PathUtils.normalizePath(UserSettings.BASE_BROWSE_PATH);
                const normalizedFilePath = PathUtils.normalizePath(filePath);
                let webPath = '/';
                const dirPath = PathUtils.getDirname(normalizedFilePath);
                if (dirPath.startsWith(normalizedBasePath) && dirPath.length >= normalizedBasePath.length) {
                    webPath = (dirPath === normalizedBasePath)
                        ? '/'
                        : `/${dirPath.substring(normalizedBasePath.length + 1).replace(/^\/+|\/+$/g, '')}/`.replace(/\/\/+/g, '/');
                } else {
                    const parts = dirPath.split(path.sep).filter(p => p);
                    webPath = (parts.length > 0)
                        ? `/${parts.join('/')}/`.replace(/\/\/+/g, '/')
                        : '/';
                }
                return webPath;
            },
            transformRelativeToAbsolutePaths(markdown, webBasePath, localAssetSubdir = '') {
                if (!markdown || !webBasePath) return markdown;
                const relativePathRegex = /(!?\[[^\]]*\]\()([^)]+)\)/g;
                const normalizedSubdir = PathUtils.normalizePath(localAssetSubdir);
                const subdirPrefix = normalizedSubdir ? normalizedSubdir + '/' : '';
                const basePath = webBasePath.endsWith('/') ? webBasePath : webBasePath + '/';
                try {
                    return markdown.replace(relativePathRegex, (match, prefix, relativePath) => {
                        let actualRelativePath = relativePath.startsWith('./')
                            ? relativePath.substring(2)
                            : relativePath;
                        if (actualRelativePath.startsWith('/') ||
                            actualRelativePath.startsWith('http') ||
                            actualRelativePath.startsWith('blob:') ||
                            actualRelativePath.startsWith('data:')) {
                            return match;
                        }
                        const suffixWithoutFragment = actualRelativePath.split(/[?#]/)[0];
                        const fragment = actualRelativePath.substring(suffixWithoutFragment.length);
                        return `${prefix}${basePath}${subdirPrefix}${suffixWithoutFragment}${fragment})`;
                    });
                } catch (e) {
                    App.handleGenericError(e, 'errors.markdownTransformError', "Path Transformation");
                    return markdown;
                }
            },
            restoreAbsoluteToRelativePaths(markdown, webBasePath, localAssetSubdir = '') {
                if (!markdown || !webBasePath) return markdown;
                const normalizedSubdir = PathUtils.normalizePath(localAssetSubdir);
                const subdirPrefix = normalizedSubdir ? normalizedSubdir + '/' : '';
                const basePath = webBasePath.endsWith('/') ? webBasePath : webBasePath + '/';
                const escapedBasePath = PathUtils.escapeRegex(basePath + subdirPrefix);
                const absolutePathRegex = new RegExp(`(!?\\[[^\\]]*\\]\\()(${escapedBasePath})([^)]+)\\)`, 'g');
                try {
                    return markdown.replace(absolutePathRegex, (match, prefix, matchedBasePath, suffix) => {
                        const suffixWithoutFragment = suffix.split(/[?#]/)[0];
                        const fragment = suffix.substring(suffixWithoutFragment.length);
                        return `${prefix}${suffixWithoutFragment}${fragment})`;
                    });
                } catch (e) {
                    App.handleGenericError(e, 'errors.markdownRestoreError', "Path Restoration");
                    return markdown;
                }
            },
            calculateBaseTagPath(filePath) {
                const normalizedFilePath = PathUtils.normalizePath(filePath);
                const normalizedBasePath = PathUtils.normalizePath(UserSettings.BASE_BROWSE_PATH);
                const dirPath = PathUtils.getDirname(normalizedFilePath);
                const slug = PathUtils.getSlugFromFilename(normalizedFilePath);
                let relativePathToItemDir = '';
                if (dirPath.startsWith(normalizedBasePath + '/')) {
                    relativePathToItemDir = dirPath.substring(normalizedBasePath.length + 1);
                } else if (dirPath !== normalizedBasePath) {
                    relativePathToItemDir = dirPath;
                }
                const webPathComponent = PathUtils.isAnyBundlePath(normalizedFilePath)
                    ? relativePathToItemDir
                    : PathUtils.joinPaths(relativePathToItemDir, slug);
                return ('/' + PathUtils.normalizePath(webPathComponent) + '/').replace(/\/+/g, '/');
            },
            getMapKeyFromFilePath(filePath) {
                const normalizedFilePath = PathUtils.normalizePath(filePath);
                const normalizedBasePath = PathUtils.normalizePath(UserSettings.BASE_BROWSE_PATH);
                let relativePath = normalizedFilePath;
                if (normalizedBasePath === '' && normalizedFilePath.includes('/')) {
                    relativePath = normalizedFilePath;
                } else if (normalizedBasePath !== '' && normalizedFilePath.startsWith(normalizedBasePath + '/')) {
                    relativePath = normalizedFilePath.substring(normalizedBasePath.length + 1);
                } else if (normalizedBasePath !== '' && normalizedFilePath === normalizedBasePath) {
                    return '';
                } else {
                    relativePath = normalizedFilePath.includes('/') ? normalizedFilePath : normalizedFilePath;
                }
                let key = relativePath;
                if (key.toLowerCase().endsWith('/index.md') || key.toLowerCase().endsWith('/_index.md')) {
                    key = PathUtils.getDirname(key);
                } else if (key.toLowerCase().endsWith('.md')) {
                    key = key.substring(0, key.length - 3);
                }
                return PathUtils.normalizePath(key);
            },
            getMimeTypeFromPath(filePath) {
                const ext = (path.extname(filePath) || '').toLowerCase();
                const mimeTypes = {
                    '.jpg': 'image/jpeg', '.jpeg': 'image/jpeg', '.png': 'image/png',
                    '.gif': 'image/gif', '.svg': 'image/svg+xml', '.webp': 'image/webp',
                    '.pdf': 'application/pdf', '.txt': 'text/plain', '.md': 'text/markdown',
                    '.zip': 'application/zip', '.tar': 'application/x-tar', '.gz': 'application/gzip',
                    '.html': 'text/html', '.css': 'text/css', '.js': 'application/javascript',
                    '.json': 'application/json', '.xml': 'application/xml'
                };
                return mimeTypes[ext] || 'application/octet-stream';
            },
        };
        const EncodingUtils = {
            b64EncodeUnicode(str) {
                try {
                    return btoa(unescape(encodeURIComponent(str)));
                } catch (e) {
                    App.handleGenericError(e, 'errors.base64Encode', "Base64 Encode");
                    throw new Error(i18next.t('errors.base64Encode'));
                }
            },
            b64DecodeUnicode(str) {
                try {
                    atob(str);
                    return decodeURIComponent(escape(atob(str)));
                } catch (e) {
                    const message = i18next.t('errors.base64Decode', { message: e.message });
                    App.handleGenericError(e, message, "Base64 Decode", { stringStart: str.substring(0, 50) });
                    throw new Error(message);
                }
            },
        };
        const FrontMatterUtils = {
            parseFrontMatterAndBody(content) {
                const fmResult = { frontMatter: {}, body: content, type: 'none' };
                const yamlRegex = /^\s*---\s*([\s\S]*?)\s*---(\s*[\s\S]*)/;
                const tomlRegex = /^\s*\+\+\+\s*([\s\S]*?)\s*\+\+\+(\s*[\s\S]*)/;
                let match;
                if ((match = content.match(yamlRegex))) {
                    try {
                        const fmContent = match[1].trim();
                        fmResult.frontMatter = fmContent ? jsyaml.load(fmContent) || {} : {};
                        fmResult.body = match[2] ? match[2].trimStart() : '';
                        fmResult.type = 'yaml';
                    } catch (e) {
                        App.handleGenericError(e, i18next.t('errors.yamlParseError', { message: e.message }), "YAML Parsing");
                        fmResult.frontMatter = {};
                        fmResult.body = content;
                        fmResult.type = 'error';
                    }
                } else if ((match = content.match(tomlRegex))) {
                    try {
                        const fmContent = match[1].trim();
                        fmResult.frontMatter = fmContent ? TOML.parse(fmContent) || {} : {};
                        fmResult.body = match[2] ? match[2].trimStart() : '';
                        fmResult.type = 'toml';
                    } catch (e) {
                        App.handleGenericError(e, i18next.t('errors.tomlParseError', { message: e.message }), "TOML Parsing");
                        fmResult.frontMatter = {};
                        fmResult.body = content;
                        fmResult.type = 'error';
                    }
                }
                if (typeof fmResult.frontMatter !== 'object' || fmResult.frontMatter === null) {
                    fmResult.frontMatter = {};
                }
                return fmResult;
            },
            formatFrontMatterAndBody(frontMatterData, bodyContent) {
                const standardFields = {};
                const customFields = {};
                const fmKeysToProcess = AppConstants.STANDARD_FM_KEYS.filter(k => k !== 'draft');
                fmKeysToProcess.forEach(key => {
                    if (frontMatterData[key] !== undefined && frontMatterData[key] !== null) {
                        if (Array.isArray(frontMatterData[key]) && frontMatterData[key].length === 0) {
                        } else if (typeof frontMatterData[key] === 'string' && frontMatterData[key] === '') {
                        } else {
                            standardFields[key] = frontMatterData[key];
                        }
                    }
                });
                if (frontMatterData.draft === true) {
                    standardFields.draft = true;
                }
                if (frontMatterData.custom && typeof frontMatterData.custom === 'object') {
                    for (const key in frontMatterData.custom) {
                        if (Object.hasOwnProperty.call(frontMatterData.custom, key)) {
                            const trimmedKey = key.trim();
                            if (trimmedKey && !standardFields.hasOwnProperty(trimmedKey) && !AppConstants.STANDARD_FM_KEYS.includes(trimmedKey.toLowerCase())) {
                                let value = frontMatterData.custom[key];
                                if (value !== undefined && value !== null && (typeof value !== 'string' || value !== '') && (!Array.isArray(value) || value.length > 0) ) {
                                    customFields[trimmedKey] = value;
                                }
                            }
                        }
                    }
                }
                const finalFrontMatter = { ...standardFields, ...customFields };
                if (Object.keys(finalFrontMatter).length === 0) {
                    return bodyContent.trim();
                }
                const format = UserSettings.FRONTMATTER_FORMAT.toLowerCase();
                try {
                    if (format === 'yaml') {
                        const yamlString = jsyaml.dump(finalFrontMatter, {
                            skipInvalid: true,
                            indent: 2,
                            lineWidth: -1,
                            noRefs: true,
                            sortKeys: (a, b) => {
                                const order = AppConstants.STANDARD_FM_KEYS;
                                const indexA = order.indexOf(a);
                                const indexB = order.indexOf(b);
                                if (indexA !== -1 && indexB !== -1) return indexA - indexB;
                                if (indexA !== -1) return -1;
                                if (indexB !== -1) return 1;
                                return a.localeCompare(b);
                            }
                        });
                        return `---\n${yamlString.trim()}\n---\n\n${bodyContent.trim()}`;
                    } else if (format === 'toml') {
                        const tomlString = TOML.stringify(finalFrontMatter);
                        return `+++\n${tomlString.trim()}\n+++\n\n${bodyContent.trim()}`;
                    } else {
                        const yamlString = jsyaml.dump(finalFrontMatter);
                        return `---\n${yamlString.trim()}\n---\n\n${bodyContent.trim()}`;
                    }
                } catch (e) {
                    const msgKey = format === 'toml' ? 'errors.tomlFormatError' : 'errors.yamlFormatError';
                    const msg = i18next.t(msgKey, { message: e.message });
                    App.handleGenericError(e, msg, format === 'toml' ? "TOML Formatting" : "YAML Formatting");
                    throw new Error(msg);
                }
            },
        };
        const Utils = {
            readFileAsBase64(file) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = () => resolve(reader.result.split(',')[1]);
                    reader.onerror = error => reject(error);
                    reader.readAsDataURL(file);
                });
            },
            delay: (ms) => new Promise(resolve => setTimeout(resolve, ms)),
            cleanUrl: (url) => (typeof url === 'string' ? url.split(/[?#]/)[0] : url),
            base64ToBlob(base64, type = 'application/octet-stream') {
                const byteCharacters = atob(base64);
                const byteNumbers = new Array(byteCharacters.length);
                for (let i = 0; i < byteCharacters.length; i++) {
                    byteNumbers[i] = byteCharacters.charCodeAt(i);
                }
                const byteArray = new Uint8Array(byteNumbers);
                return new Blob([byteArray], { type });
            },
        };
        const AppState = {
            octokit: null,
            owner: null,
            repo: null,
            currentPath: UserSettings.BASE_BROWSE_PATH,
            branch: UserSettings.DEFAULT_BRANCH,
            flatpickrInstance: null,
            flatpickrLastmodInstance: null,
            initialFmData: {},
            initialBodyContent: '',
            currentFileSha: null,
            currentFilePath: null,
            urlActionPath: null,
            pendingUploads: {},
            draftAssets: {},
            currentLang: UserSettings.DEFAULT_LANGUAGE,
            initialUploadLinks: new Set(),
            isEditingPageBundle: false,
            isEditingBranchBundle: false,
            isEditingAnyBundle: false,
            initialSlugOrFilename: '',
            initialDraftState: false,
            initialHasLastmod: false,
            draftPathsSet: new Set(),
            currentView: 'browse',
            isProcessingVditorInput: false,
            setRepo(owner, repo) {
                this.owner = owner;
                this.repo = repo;
                this.currentPath = UserSettings.BASE_BROWSE_PATH;
            },
            setCurrentPath(p) {
                this.currentPath = PathUtils.normalizePath(p);
            },
            setEditingFile(p, sha, fmData, body, initialLinksSet, initialDraft, initialHasLastmod) {
                this.currentFilePath = PathUtils.normalizePath(p);
                this.currentFileSha = sha;
                this.isEditingPageBundle = PathUtils.isPageBundlePath(this.currentFilePath);
                this.isEditingBranchBundle = PathUtils.isBranchBundlePath(this.currentFilePath);
                this.isEditingAnyBundle = this.isEditingPageBundle || this.isEditingBranchBundle;
                this.initialFmData = JSON.parse(JSON.stringify(fmData));
                this.initialBodyContent = body;
                this.initialUploadLinks = initialLinksSet || new Set();
                this.setCurrentPath(PathUtils.getDirname(this.currentFilePath) || UserSettings.BASE_BROWSE_PATH);
                this.clearPendingUploads();
                this.initialSlugOrFilename = PathUtils.getSlugFromFilename(this.currentFilePath);
                this.initialDraftState = initialDraft;
                this.initialHasLastmod = initialHasLastmod;
                this.currentView = 'edit';
            },
            isDraft: (p) => AppState.draftPathsSet.has(PathUtils.normalizePath(p)),
            clearEditingFile() {
                this.currentFilePath = null;
                this.currentFileSha = null;
                this.initialFmData = {};
                this.initialBodyContent = '';
                this.initialUploadLinks.clear();
                this.clearPendingUploads();
                this.clearDraftAssets();
                this.isEditingPageBundle = false;
                this.isEditingBranchBundle = false;
                this.isEditingAnyBundle = false;
                this.initialSlugOrFilename = '';
                this.initialDraftState = false;
                this.initialHasLastmod = false;
                this.currentView = 'browse';
            },
            clearPendingUploads() {
                Object.keys(this.pendingUploads).forEach(urlKey => {
                    if (urlKey.startsWith('blob:')) {
                        try {
                            URL.revokeObjectURL(urlKey);
                        } catch (e) {
                        }
                    }
                });
                this.pendingUploads = {};
            },
            clearDraftAssets() {
                Object.entries(this.draftAssets).forEach(([relativePath, blobUrl]) => {
                    if (blobUrl && typeof blobUrl === 'string' && blobUrl.startsWith('blob:')) {
                        try {
                            URL.revokeObjectURL(blobUrl);
                        } catch (e) {
                        }
                    }
                });
                this.draftAssets = {};
                if (typeof App !== 'undefined' && App.reverseDraftAssetMap) {
                    App.reverseDraftAssetMap = {};
                }
            },
            isCurrentOperationTargetingLocal() {
                return this.currentFileSha
                    ? this.isEditingAnyBundle
                    : UserSettings.ASSET_STRATEGY === 'local';
            },
            isModified(processedFormData) {
                if (!processedFormData || typeof processedFormData !== 'object') {
                    return true;
                }
                if (!this.currentFileSha) {
                    const bodyHasContent = processedFormData.hasOwnProperty('body') && typeof processedFormData.body === 'string' && processedFormData.body.trim() !== '';
                    const dateAutoChanged = processedFormData.dateAutoChecked !== true;
                    let lastmodAutoChanged = false;
                    if (UIManager.elements.fmLastmodContainer && !UIManager.elements.fmLastmodContainer.classList.contains('hidden')) {
                        lastmodAutoChanged = processedFormData.lastmodAutoChecked !== true;
                    }
                    const hasInitialInput = !!processedFormData.title ||
                        !!processedFormData.fullPathValue ||
                        bodyHasContent ||
                        (Array.isArray(processedFormData.custom) && processedFormData.custom.length > 0) ||
                        Object.keys(this.pendingUploads || {}).length > 0 ||
                        dateAutoChanged ||
                        lastmodAutoChanged;
                    return hasInitialInput;
                }
                let modified = false;
                for (const field of FM_FIELD_CONFIG) {
                    const initialValue = this.initialFmData ? this.initialFmData[field.key] : undefined;
                    const currentValue = processedFormData[field.key];
                    let fieldModified = false;
                    if (field.key === 'date' || field.key === 'lastmod') {
                        const autoCheckbox = UIManager.elements[field.autoCheckboxId];
                        let initialAutoState;
                        if (field.key === 'date') {
                            if (this.initialDraftState && !this.initialHasLastmod) {
                                initialAutoState = true;
                            }
                            else if (!this.initialDraftState && !this.initialHasLastmod) {
                                initialAutoState = false;
                            }
                            else if (this.initialHasLastmod) {
                                initialAutoState = false;
                            }
                            else {
                                initialAutoState = true;
                            }
                        } else {
                            initialAutoState = true;
                        }
                        if (autoCheckbox && processedFormData[`${field.key}AutoChecked`] !== initialAutoState) {
                            fieldModified = true;
                        }
                        if (autoCheckbox && !processedFormData[`${field.key}AutoChecked`]) {
                            const initialDateStr = String(initialValue || '').trim();
                            const currentDateStr = String(currentValue || '').trim();
                            if (initialDateStr !== currentDateStr) {
                                fieldModified = true;
                            }
                        }
                    } else {
                        const initialCompareValue = (field.type === 'array' && Array.isArray(initialValue)) ? [...initialValue].sort() : initialValue;
                        const currentCompareValue = (field.type === 'array' && Array.isArray(currentValue)) ? [...currentValue].sort() : currentValue;
                        if (!isEqual(currentCompareValue, initialCompareValue)) {
                            fieldModified = true;
                        }
                    }
                    if (fieldModified) {
                        modified = true;
                        break;
                    }
                }
                if (modified) return true;
                const initialDraftValue = this.initialFmData ? (this.initialFmData.draft === true) : false;
                let currentDraftValue = initialDraftValue;
                if (processedFormData.hasOwnProperty('draft')) {
                     currentDraftValue = processedFormData.draft === true;
                }
                if (initialDraftValue !== currentDraftValue) {
                    return true;
                }
                const currentCustomForCompare = {};
                if (Array.isArray(processedFormData.custom)) {
                    processedFormData.custom.forEach(item => {
                        if (item && item.key) {
                            let valueToCompare;
                            if (item.type === 'array' && Array.isArray(item.value)) {
                                valueToCompare = [...item.value].sort();
                            } else if (item.type === 'boolean') {
                                valueToCompare = item.value === true;
                            } else if (item.type === 'date') {
                                try {
                                    const parsedDate = flatpickr.parseDate(String(item.value), "Y-m-d H:i:S") ||
                                                       flatpickr.parseDate(String(item.value), "Y-m-d H:i");
                                    if (parsedDate && !isNaN(parsedDate.getTime())) {
                                        valueToCompare = parsedDate.toISOString();
                                    } else {
                                        valueToCompare = String(item.value);
                                    }
                                } catch(e) {
                                    valueToCompare = String(item.value);
                                }
                            } else if (item.type === 'number') {
                                const num = parseFloat(String(item.value));
                                valueToCompare = isNaN(num) ? String(item.value) : num;
                            }
                            else {
                                valueToCompare = String(item.value);
                            }
                            currentCustomForCompare[item.key] = { value: valueToCompare, type: item.type };
                        }
                    });
                }
                const initialCustomForCompare = {};
                if (this.initialFmData && typeof this.initialFmData.custom === 'object') {
                    for (const key in this.initialFmData.custom) {
                        if (Object.hasOwnProperty.call(this.initialFmData.custom, key)) {
                            const initialRawValue = this.initialFmData.custom[key];
                            let initialType = 'string';
                            let initialValueToCompare;
                            if (Array.isArray(initialRawValue)) {
                                initialType = 'array';
                                initialValueToCompare = [...initialRawValue].sort();
                            } else if (typeof initialRawValue === 'boolean') {
                                initialType = 'boolean';
                                initialValueToCompare = initialRawValue === true;
                            } else if (typeof initialRawValue === 'number') {
                                initialType = 'number';
                                initialValueToCompare = initialRawValue;
                            }
                            else if (initialRawValue instanceof Date ||
                                       (typeof initialRawValue === 'string' &&
                                       (flatpickr.parseDate(initialRawValue, "Z") ||
                                        flatpickr.parseDate(initialRawValue, "Y-m-d H:i:S") ||
                                        flatpickr.parseDate(initialRawValue, "Y-m-d H:i") ||
                                        flatpickr.parseDate(initialRawValue, "Y-m-d")) &&
                                        !/^\d+$/.test(initialRawValue))) {
                                initialType = 'date';
                                try {
                                   const parsedDate = initialRawValue instanceof Date ? initialRawValue :
                                                      (flatpickr.parseDate(String(initialRawValue), "Z") ||
                                                       flatpickr.parseDate(String(initialRawValue), "Y-m-d H:i:S") ||
                                                       flatpickr.parseDate(String(initialRawValue), "Y-m-d H:i") ||
                                                       flatpickr.parseDate(String(initialRawValue), "Y-m-d"));
                                   if (parsedDate && !isNaN(parsedDate.getTime())) {
                                        initialValueToCompare = parsedDate.toISOString();
                                   } else {
                                        initialValueToCompare = String(initialRawValue);
                                   }
                                } catch(e){
                                    initialValueToCompare = String(initialRawValue);
                                }
                            } else {
                                initialType = 'string';
                                initialValueToCompare = String(initialRawValue);
                            }
                            initialCustomForCompare[key] = { value: initialValueToCompare, type: initialType };
                        }
                    }
                }
                if (!isEqual(currentCustomForCompare, initialCustomForCompare)) {
                    return true;
                }
                let currentBodyForCompare = "";
                let initialBodyForCompare = "";
                if (processedFormData.hasOwnProperty('body') && typeof processedFormData.body === 'string') {
                     currentBodyForCompare = (this.currentFilePath && typeof App.restoreBlobURLsToRelativePathsInBody === 'function')
                        ? App.restoreBlobURLsToRelativePathsInBody(processedFormData.body).trim()
                        : processedFormData.body.trim();
                }
                if (typeof this.initialBodyContent === 'string') {
                    initialBodyForCompare = (this.currentFilePath && typeof App.restoreBlobURLsToRelativePathsInBody === 'function')
                        ? App.restoreBlobURLsToRelativePathsInBody(this.initialBodyContent).trim()
                        : this.initialBodyContent.trim();
                }
                 if (currentBodyForCompare !== initialBodyForCompare) {
                    return true;
                }
                if (Object.keys(this.pendingUploads || {}).length > 0) {
                    return true;
                }
                let currentLinks = new Set();
                if (this.currentFilePath && typeof App.parseManagedUploadLinks === 'function' && processedFormData.hasOwnProperty('body') && typeof processedFormData.body === 'string') {
                    try {
                        const bodyForLinkParsing = App.restoreBlobURLsToRelativePathsInBody(processedFormData.body);
                        currentLinks = App.parseManagedUploadLinks(bodyForLinkParsing, this.currentFilePath);
                    } catch (e) {
                        return true;
                    }
                }
                const initialLinksArray = Array.from(this.initialUploadLinks || new Set()).sort();
                const currentLinksArray = Array.from(currentLinks).sort();
                 if (!isEqual(currentLinksArray, initialLinksArray)) {
                    return true;
                 }
                return false;
            },
            parseUrlQuery() {
                const queryString = location.search.substring(1);
                if (queryString) {
                    this.urlActionPath = queryString;
                    try {
                        this.urlActionPath = decodeURIComponent(this.urlActionPath.replace(/\+/g, ' '));
                    } catch (e) {
                        App.handleGenericError(e, 'errors.urlParseFailed', "URL Query Parsing");
                        this.urlActionPath = null;
                    }
                } else {
                    this.urlActionPath = null;
                }
            }
        };
        const VditorManager = {
            instance: null,
            isReady: false,
            readyPromise: null,
            resolveReady: null,
            pendingFocus: false,
            inputTimeout: null,
            init(elementId, initialValue = '', themeMediaQuery, inputCallback) {
                this.isReady = false;
                this.pendingFocus = false;
                this.readyPromise = new Promise(resolve => { this.resolveReady = resolve; });
                if (this.instance) {
                    try {
                        this.instance.destroy();
                    } catch (e) {
                        App.handleGenericError(e, 'errors.vditorDestroy', "Vditor Destroy");
                    }
                    this.instance = null;
                }
                try {
                    if (typeof Vditor === 'undefined') {
                        throw new Error("Vditor library not loaded.");
                    }
                    const currentIsDark = themeMediaQuery.matches;
                    this.instance = new Vditor(elementId, {
                        value: initialValue,
                        lang: 'en_US',
                        mode: UserSettings.VDITOR_EDIT_MODE,
                        theme: currentIsDark ? 'dark' : 'classic',
                        toolbarConfig: { pin: true },
                        cache: { enable: false },
                        preview: {
                            theme: { current: currentIsDark ? 'dark' : 'light' },
                            transform: (html) => {
                                if (UserSettings.VDITOR_EDIT_MODE === 'ir' || UserSettings.VDITOR_EDIT_MODE === 'wysiwyg') {
                                     return html;
                                }
                                if (AppState.currentFilePath && AppState.isDraft(AppState.currentFilePath) && PathUtils.isAnyBundlePath(AppState.currentFilePath) && UserSettings.ASSET_STRATEGY === 'local') {
                                    try {
                                        const doc = new DOMParser().parseFromString(html, 'text/html');
                                        const processNode = (node, attributeName) => {
                                            let pathValue = node.getAttribute(attributeName);
                                            if (pathValue && !pathValue.startsWith('blob:') && !pathValue.startsWith('http') && !pathValue.startsWith('data:') && !pathValue.startsWith('/') && !pathValue.startsWith('#')) {
                                                const blobUrl = AppState.draftAssets[pathValue];
                                                if (blobUrl) {
                                                    node.setAttribute(attributeName, blobUrl);
                                                } else {
                                                }
                                            }
                                        };
                                        doc.querySelectorAll('img').forEach(img => processNode(img, 'src'));
                                        doc.querySelectorAll('a').forEach(a => processNode(a, 'href'));
                                        const transformedHtml = doc.body.innerHTML;
                                        return transformedHtml;
                                    } catch(e) {
                                        return html;
                                    }
                                }
                                return html;
                            }
                        },
                        upload: {
                            accept: '*',
                            handler: (files) => {
                                if (!AppState.octokit) {
                                    App.handleGenericError(new Error("Not logged in"), 'errors.notLoggedInForUpload', "Vditor Upload");
                                    return i18next.t('errors.notLoggedInForUpload');
                                }
                                if (!files || files.length === 0) {
                                    App.handleGenericError(new Error("No files provided"), 'errors.noFileToUpload', "Vditor Upload");
                                    return i18next.t('errors.noFileToUpload');
                                }
                                let markdownToInsert = "";
                                let fileCount = 0;
                                for (const file of files) {
                                    try {
                                        const blobUrl = URL.createObjectURL(file);
                                        const cleanBlobUrl = Utils.cleanUrl(blobUrl);
                                        AppState.pendingUploads[cleanBlobUrl] = file;
                                        if (file.type.startsWith('image/')) {
                                            markdownToInsert += `![${PathUtils.getBasename(file.name).split('.')[0]}](${blobUrl})\n`;
                                        } else {
                                            markdownToInsert += `[${file.name}](upload-placeholder:${cleanBlobUrl})\n`;
                                        }
                                        fileCount++;
                                    } catch (error) {
                                        App.handleGenericError(error, 'errors.previewGenFailed', "Vditor Upload", { filename: file.name });
                                    }
                                }
                                if (markdownToInsert) {
                                    this.insertValue(markdownToInsert);
                                    UIManager.updateStatus(i18next.t('statusBar.uploadPlaceholderReady', { count: fileCount }), false, true);
                                    App.refreshEditorUIState();
                                }
                                return null;
                            }
                        },
                        input: (value) => {
                            if (AppState.isProcessingVditorInput) return;
                            if (this.inputTimeout) clearTimeout(this.inputTimeout);
                            this.inputTimeout = setTimeout(async () => {
                                AppState.isProcessingVditorInput = true;
                                try {
                                    if (UserSettings.VDITOR_EDIT_MODE === 'ir' &&
                                        AppState.currentFilePath &&
                                        AppState.isDraft(AppState.currentFilePath) &&
                                        PathUtils.isAnyBundlePath(AppState.currentFilePath) &&
                                        UserSettings.ASSET_STRATEGY === 'local' &&
                                        Object.keys(AppState.draftAssets).length > 0) {
                                        const originalContent = this.instance.getValue();
                                        const newContent = App.replaceRelativePathsWithDraftAssetBlobs(originalContent);
                                        if (newContent !== originalContent) {
                                            this.instance.setValue(newContent);
                                        }
                                    }
                                } finally {
                                    AppState.isProcessingVditorInput = false;
                                }
                                if (inputCallback) inputCallback();
                            }, 300);
                        },
                        after: () => {
                            this.isReady = true;
                            if (this.resolveReady) {
                                this.resolveReady();
                                this.resolveReady = null;
                            }
                            this.setTheme(themeMediaQuery.matches ? 'dark' : 'classic', themeMediaQuery.matches ? 'dark' : 'light');
                            if (this.pendingFocus) {
                                this.focus();
                                this.pendingFocus = false;
                            }
                            UIManager.updateAllText();
                            App.refreshEditorUIState();
                        }
                    });
                    return this.readyPromise;
                } catch (error) {
                    App.handleGenericError(error, 'errors.vditorInitFailed', "Vditor Initialization");
                    if (document.getElementById('editorSection')) {
                        document.getElementById('editorSection').classList.add('hidden');
                    }
                    if (this.resolveReady) {
                        this.resolveReady();
                        this.resolveReady = null;
                    }
                    this.isReady = false;
                    throw error;
                }
            },
            async awaitReady() {
                if (this.isReady) return;
                if (this.readyPromise) {
                    try {
                        await this.readyPromise;
                    } catch (e) {
                        App.handleGenericError(e, 'errors.vditorNotReady', "Vditor Await Ready");
                        throw new Error(i18next.t('errors.vditorNotReady'));
                    }
                } else {
                    const error = new Error(i18next.t('errors.vditorNotReady'));
                    App.handleGenericError(error, 'errors.vditorNotReady', "Vditor Await Ready");
                    throw error;
                }
            },
            async getValue() {
                await this.awaitReady();
                if (!this.instance) throw new Error(i18next.t('errors.vditorNotReady'));
                try {
                    return this.instance.getValue();
                } catch (e) {
                    App.handleGenericError(e, 'errors.vditorGetValueFailed', "Vditor Get Value");
                    return AppState.initialBodyContent;
                }
            },
            async setValue(value, renderNow = false) {
                await this.awaitReady();
                if (!this.instance) throw new Error(i18next.t('errors.vditorNotReady'));
                try {
                     if (typeof this.instance.setValue === 'function') {
                        this.instance.setValue(value);
                    }
                } catch (e) {
                    App.handleGenericError(e, 'errors.vditorSetValueFailed', "Vditor Set Value");
                }
            },
            async insertValue(value) {
                await this.awaitReady();
                if (!this.instance) throw new Error(i18next.t('errors.vditorNotReady'));
                try {
                    this.instance.insertValue(value);
                } catch (e) {
                    App.handleGenericError(e, "Error inserting Vditor value", "Vditor Insert Value");
                }
            },
            async focus() {
                if (!this.instance) return;
                if (!this.isReady) {
                    this.pendingFocus = true;
                    return;
                }
                try {
                    this.instance.focus();
                } catch (e) {
                    App.handleGenericError(e, 'errors.vditorFocus', "Vditor Focus");
                }
            },
            async setTheme(vditorTheme, previewTheme) {
                if (!this.instance || !this.isReady) return;
                try {
                    this.instance.setTheme(vditorTheme, previewTheme);
                } catch (e) {
                    App.handleGenericError(e, 'errors.vditorTheme', "Vditor Set Theme");
                }
            },
            destroy() {
                if (this.inputTimeout) clearTimeout(this.inputTimeout);
                if (this.instance) {
                    try {
                        this.instance.destroy();
                    } catch (e) {
                        App.handleGenericError(e, 'errors.vditorDestroy', "Vditor Destroy");
                    }
                }
                this.instance = null;
                this.isReady = false;
                this.readyPromise = null;
                this.resolveReady = null;
                this.pendingFocus = false;
            },
            async enable() {
                await this.awaitReady();
                if (!this.instance) return;
                try {
                    this.instance.enable();
                } catch (e) {
                }
            },
            async disable() {
                if (!this.instance || !this.isReady) return;
                try {
                    this.instance.disabled();
                } catch (e) {
                }
            }
        };
        const UIManager = {
            elements: {},
            customFieldFlatpickrInstances: new Map(),
            tagifyInstances: new Map(),
            init() {
                this.elements = {
                    patInput: document.getElementById('patInput'),
                    loginButton: document.getElementById('loginButton'),
                    logoutButton: document.getElementById('logoutButton'),
                    repoSelect: document.getElementById('repoSelect'),
                    loadRepoButton: document.getElementById('loadRepoButton'),
                    fileListUl: document.querySelector('#fileList ul'),
                    currentRepoSpan: document.getElementById('currentRepo'),
                    currentPathBreadcrumb: document.getElementById('currentPathBreadcrumb'),
                    fileNameInput: document.getElementById('fileNameInput'),
                    fmTitleInput: document.getElementById('fmTitleInput'),
                    fmAuthorInput: document.getElementById('fmAuthorInput'),
                    fmDateInput: document.getElementById('fmDateInput'),
                    fmDateAutoCheckbox: document.getElementById('fmDateAutoCheckbox'),
                    fmDateAutoLabel: document.getElementById('fmDateAutoLabel'),
                    fmLastmodInput: document.getElementById('fmLastmodInput'),
                    fmLastmodAutoCheckbox: document.getElementById('fmLastmodAutoCheckbox'),
                    fmLastmodAutoLabel: document.getElementById('fmLastmodAutoLabel'),
                    fmLastmodContainer: document.getElementById('fmLastmodContainer'),
                    fmDescriptionInput: document.getElementById('fmDescriptionInput'),
                    fmTagsInput: document.getElementById('fmTagsInput'),
                    fmCategoriesInput: document.getElementById('fmCategoriesInput'),
                    fileContentInput: document.getElementById('fileContentInput'),
                    commitMessageInput: document.getElementById('commitMessageInput'),
                    currentFileShaInput: document.getElementById('currentFileSha'),
                    currentFilePathInput: document.getElementById('currentFilePathInput'),
                    saveDraftButton: document.getElementById('saveDraftButton'),
                    publishButton: document.getElementById('publishButton'),
                    deleteFileButton: document.getElementById('deleteFileButton'),
                    cancelEditButton: document.getElementById('cancelEditButton'),
                    createNewFileButton: document.getElementById('createNewFileButton'),
                    statusBar: document.getElementById('statusBar'),
                    errorStatusBarContainer: document.getElementById('errorStatusBarContainer'),
                    loginSection: document.getElementById('loginSection'),
                    repoSection: document.getElementById('repoSection'),
                    fileBrowserSection: document.getElementById('fileBrowserSection'),
                    editorSection: document.getElementById('editorSection'),
                    customFrontMatterContainer: document.getElementById('customFrontMatterContainer'),
                    addCustomFieldButton: document.getElementById('addCustomFieldButton'),
                    currentBranchName: document.getElementById('currentBranchName'),
                    fileNameLabel: document.getElementById('fileNameLabel'),
                    fmBaseNoteElement: document.querySelector('[data-i18n="editor.fm.baseNote"]'),
                    mainLayoutContainer: document.getElementById('mainLayoutContainer'),
                    fileFilterInput: document.getElementById('fileFilterInput'),
                    fileListEmptyMessage: document.getElementById('fileListEmptyMessage'),
                    draftFilterCheckbox: document.getElementById('draftFilterCheckbox'),
                    draftFilterContainer: document.getElementById('draftFilterContainer'),
                };
                FM_FIELD_CONFIG.forEach(field => {
                    this.elements[field.elementId] = document.getElementById(field.elementId);
                    if (field.autoCheckboxId) this.elements[field.autoCheckboxId] = document.getElementById(field.autoCheckboxId);
                    if (field.autoLabelId) this.elements[field.autoLabelId] = document.getElementById(field.autoLabelId);
                });
                this.elements.addCustomFieldButton.addEventListener('click', () => {
                    this.addCustomFieldRow();
                    App.refreshEditorUIState();
                });
                this.setupDateAutoToggle(this.elements.fmDateInput, this.elements.fmDateAutoCheckbox, this.elements.fmDateAutoLabel);
                this.setupDateAutoToggle(this.elements.fmLastmodInput, this.elements.fmLastmodAutoCheckbox, this.elements.fmLastmodAutoLabel);
            },
            setupDateAutoToggle(inputElement, checkboxElement, labelElement) {
                if (!inputElement || !checkboxElement || !labelElement) return;
                const updateState = () => {
                    if (checkboxElement.checked) {
                        inputElement.disabled = true;
                        labelElement.textContent = i18next.t('editor.fm.autoSetToNow');
                    } else {
                        inputElement.disabled = false;
                        labelElement.textContent = i18next.t('editor.fm.manualInput');
                        inputElement.focus();
                    }
                    App.refreshEditorUIState();
                };
                checkboxElement.addEventListener('change', updateState);
                checkboxElement.defaultChecked = true;
                updateState();
            },
            initDateField(element, fieldKey, value, isAutoChecked, isDisabled) {
                if (!element) return;
                let fpInstanceTarget = (fieldKey === 'date') ? 'flatpickrInstance' : 'flatpickrLastmodInstance';
                if (AppState[fpInstanceTarget]) {
                    try { AppState[fpInstanceTarget].destroy(); } catch(e) {}
                    AppState[fpInstanceTarget] = null;
                }
                try {
                    element.readOnly = true;
                    const fp = flatpickr(element, {
                        enableTime: true, time_24hr: true, allowInput: false, dateFormat: "Y-m-d H:i", static: true,
                        onChange: () => App.refreshEditorUIState(),
                        onClose: (selectedDates, dateStr, instance) => {
                            if (selectedDates.length > 0) instance.input.value = flatpickr.formatDate(selectedDates[0], "Y-m-d H:i");
                            App.refreshEditorUIState();
                        }
                    });
                    AppState[fpInstanceTarget] = fp;
                    if (value) {
                        try {
                            let dateInput = (typeof value === 'number') ? new Date(value) : value;
                            let parsedDate = (dateInput instanceof Date)
                                ? dateInput
                                : (flatpickr.parseDate(String(dateInput), "Z") || flatpickr.parseDate(String(dateInput), "Y-m-d H:i:S") || flatpickr.parseDate(String(dateInput), "Y-m-d H:i") || flatpickr.parseDate(String(dateInput), "Y-m-d") || new Date(dateInput));
                            if (parsedDate && !isNaN(parsedDate.getTime())) {
                                fp.setDate(parsedDate, false);
                                element.value = flatpickr.formatDate(parsedDate, "Y-m-d H:i");
                            } else {
                                element.value = String(value);
                                App.handleGenericError(null, 'errors.invalidDateForFlatpickr', "Flatpickr Populate", { date: value });
                            }
                        } catch (e) {
                            element.value = String(value);
                            App.handleGenericError(e, 'errors.invalidDateForFlatpickr', "Flatpickr Populate", { date: value });
                        }
                    } else {
                        fp.clear(false);
                        element.value = '';
                    }
                    const checkbox = this.elements[FM_FIELD_CONFIG.find(f => f.key === fieldKey).autoCheckboxId];
                    const label = this.elements[FM_FIELD_CONFIG.find(f => f.key === fieldKey).autoLabelId];
                    if (checkbox) checkbox.checked = isAutoChecked;
                    if (checkbox && label) {
                        element.disabled = isAutoChecked;
                        label.textContent = isAutoChecked ? i18next.t('editor.fm.autoSetToNow') : i18next.t('editor.fm.manualInput');
                    }
                    if(isDisabled !== undefined) element.disabled = isDisabled;
                } catch (e) {
                    App.handleGenericError(e, 'errors.vditorInitFailed', `Flatpickr Init (${fieldKey})`);
                }
            },
            manageTagifyInstance(inputElement, enable, initialValue = '') {
                const elementId = inputElement.id;
                if (!elementId) {
                    return;
                }
                if (this.tagifyInstances.has(elementId)) {
                    try {
                        this.tagifyInstances.get(elementId).destroy(); } catch (e) { }
                    this.tagifyInstances.delete(elementId);
                }
                if (enable) {
                    if (inputElement.tagName.toLowerCase() !== 'input' && inputElement.tagName.toLowerCase() !== 'textarea') {
                        return;
                    }
                    const tagifyInstance = new Tagify(inputElement, {
                        delimiters: ',',
                    });
                    if (initialValue && String(initialValue).trim() !== '') {
                        try {
                            tagifyInstance.loadOriginalValues(initialValue); } catch (e) { }
                    }
                    this.tagifyInstances.set(elementId, tagifyInstance);
                    tagifyInstance.on('change', (e) => {
                        App.refreshEditorUIState();
                    });
                }
            },
            updateStatus(message, isError = false, isSuccess = false, isLoading = false) {
                const statusBarEl = this.elements.statusBar;
                const errorContainerEl = this.elements.errorStatusBarContainer;
                if (!statusBarEl || !errorContainerEl) return;
                const cleanMessage = message.replace(/^[❌✅⏳ℹ️]\s*(Status|상태):/, '').trim();
                if (isError) {
                    const errorItem = document.createElement('div');
                    errorItem.className = 'error-status-item';
                    const dismissBtn = document.createElement('button');
                    dismissBtn.type = 'button';
                    dismissBtn.className = 'dismiss-error-btn';
                    dismissBtn.innerHTML = '×';
                    dismissBtn.addEventListener('click', (event) => {
                        event.preventDefault();
                        errorItem.remove();
                    });
                    errorItem.appendChild(document.createTextNode(`❌ ${i18next.t('statusBar.statusPrefix')} ${cleanMessage}`));
                    errorItem.appendChild(dismissBtn);
                    errorContainerEl.appendChild(errorItem);
                    statusBarEl.className = 'status-bar';
                    statusBarEl.textContent = `ℹ️ ${i18next.t('statusBar.statusPrefix')} ${i18next.t('statusBar.waiting')}`;
                } else {
                    let emoji = 'ℹ️';
                    statusBarEl.className = 'status-bar';
                    if (isSuccess) {
                        statusBarEl.classList.add('status-bar-success');
                        emoji = '✅';
                    } else if (isLoading) {
                        statusBarEl.classList.add('status-bar-loading');
                        emoji = '⏳';
                    }
                    statusBarEl.textContent = `${emoji} ${i18next.t('statusBar.statusPrefix')} ${cleanMessage}`;
                }
            },
            showSection(sectionName) {
                this.elements.loginSection.classList.add('hidden');
                this.elements.repoSection.classList.add('hidden');
                this.elements.mainLayoutContainer.classList.add('hidden');
                this.elements.mainLayoutContainer.classList.remove('split-view', 'mobile-editor-visible');
                this.removeActiveFileHighlight();
                if (sectionName === 'login') {
                    this.elements.loginSection.classList.remove('hidden');
                } else if (sectionName === 'repo') {
                    this.elements.repoSection.classList.remove('hidden');
                } else if (sectionName === 'main') {
                    this.elements.mainLayoutContainer.classList.remove('hidden');
                    this.setBrowseOnlyState();
                }
                this.toggleLogoutButton(!!AppState.octokit);
                App.updateNewFileButtonUI();
            },
            setBrowseOnlyState() {
                AppState.currentView = 'browse';
                this.elements.mainLayoutContainer.classList.remove('split-view', 'mobile-editor-visible');
                this.elements.fileBrowserSection.classList.remove('hidden');
                this.elements.editorSection.classList.add('hidden');
                this.removeActiveFileHighlight();
                App.setBaseTag(null);
                App.updateNewFileButtonUI();
            },
            setEditState() {
                AppState.currentView = 'edit';
                this.elements.mainLayoutContainer.classList.add('split-view', 'mobile-editor-visible');
                this.elements.fileBrowserSection.classList.remove('hidden');
                this.elements.editorSection.classList.remove('hidden');
                App.updateNewFileButtonUI();
                this.highlightActiveFile(AppState.currentFilePath);
            },
            toggleLogoutButton(show) {
                this.elements.logoutButton.classList.toggle('hidden', !show);
            },
            setLoginLoading(isLoading) {
                this.elements.patInput.disabled = isLoading;
                this.elements.loginButton.disabled = isLoading;
                this.elements.loginButton.textContent = isLoading
                    ? i18next.t('login.loadingButton')
                    : i18next.t('login.loginButton');
                if (isLoading) {
                    this.toggleLogoutButton(false);
                }
            },
            setLoginSuccess(tokenProvided) {
                this.elements.patInput.value = tokenProvided ? '********' : '';
                this.elements.patInput.disabled = true;
                this.elements.loginButton.textContent = i18next.t('login.authCompleteButton');
                this.elements.loginButton.disabled = true;
                this.toggleLogoutButton(true);
            },
            resetLoginScreen(tokenToKeep = '') {
                this.showSection('login');
                this.elements.patInput.disabled = false;
                this.elements.patInput.value = tokenToKeep;
                if (!tokenToKeep) {
                    this.elements.patInput.placeholder = i18next.t('login.patPlaceholder');
                }
                this.elements.loginButton.disabled = false;
                this.elements.loginButton.textContent = i18next.t('login.loginButton');
                this.toggleLogoutButton(false);
                this.elements.repoSelect.innerHTML = `<option value="">${i18next.t('repo.selectDefaultOption')}</option>`;
                this.elements.repoSelect.disabled = true;
                this.elements.loadRepoButton.disabled = true;
                this.elements.currentRepoSpan.textContent = '';
                this.elements.currentBranchName.textContent = UserSettings.DEFAULT_BRANCH;
                this.elements.mainLayoutContainer.classList.add('hidden');
                this.elements.fileBrowserSection.classList.add('hidden');
                this.elements.editorSection.classList.add('hidden');
                if (this.elements.fileListUl) {
                    this.elements.fileListUl.innerHTML = '';
                }
                App.updateNewFileButtonUI();
                this.clearEditorFields(true);
            },
            populateRepoSelect(repos) {
                const select = this.elements.repoSelect;
                select.innerHTML = `<option value="">${i18next.t('repo.selectDefaultOption')}</option>`;
                if (repos && repos.length > 0) {
                    repos.forEach(repo => {
                        const option = document.createElement('option');
                        option.value = `${repo.owner.login}/${repo.name}`;
                        option.textContent = `${repo.full_name} (${repo.private ? 'Private' : 'Public'})`;
                        select.appendChild(option);
                    });
                    select.disabled = false;
                    this.elements.loadRepoButton.disabled = select.value === '';
                } else {
                    select.disabled = true;
                    this.elements.loadRepoButton.disabled = true;
                }
            },
            setRepoLoading(isLoading, repoFullName = '') {
                this.elements.repoSelect.disabled = isLoading;
                this.elements.loadRepoButton.disabled = isLoading || this.elements.repoSelect.value === '';
                if (isLoading && repoFullName) {
                    this.elements.currentRepoSpan.textContent = repoFullName;
                    this.updateBreadcrumb(UserSettings.BASE_BROWSE_PATH);
                }
                App.updateNewFileButtonUI();
            },
            updateBreadcrumb(currentP) {
                const breadcrumb = this.elements.currentPathBreadcrumb;
                breadcrumb.innerHTML = '';
                const normalizedPath = PathUtils.normalizePath(currentP);
                const normalizedBasePath = PathUtils.normalizePath(UserSettings.BASE_BROWSE_PATH);
                const rootLink = document.createElement('a');
                rootLink.href = '#';
                rootLink.textContent = UserSettings.BASE_BROWSE_PATH === '' ? '/' : UserSettings.BASE_BROWSE_PATH;
                rootLink.addEventListener('click', e => {
                    e.preventDefault();
                    App.requestBrowseAction(UserSettings.BASE_BROWSE_PATH || '');
                });
                if (normalizedPath === normalizedBasePath || (normalizedBasePath !== '' && !normalizedPath.startsWith(normalizedBasePath + '/'))) {
                    const strong = document.createElement('strong');
                    strong.appendChild(rootLink);
                    breadcrumb.appendChild(strong);
                } else {
                    breadcrumb.appendChild(rootLink);
                    let relativePath = (normalizedBasePath === '' && normalizedPath !== '')
                        ? normalizedPath
                        : (normalizedPath.startsWith(normalizedBasePath + path.sep)
                            ? normalizedPath.substring(normalizedBasePath.length + 1)
                            : '');
                    const parts = relativePath.split(path.sep).filter(p => p);
                    let accumulatedPath = normalizedBasePath;
                    parts.forEach((part, index) => {
                        accumulatedPath = PathUtils.joinPaths(accumulatedPath, part);
                        breadcrumb.appendChild(document.createTextNode(' / '));
                        if (index === parts.length - 1) {
                            const strong = document.createElement('strong');
                            strong.textContent = part;
                            breadcrumb.appendChild(strong);
                        } else {
                            const link = document.createElement('a');
                            link.href = '#';
                            link.textContent = part;
                            const currentLinkPath = accumulatedPath;
                            link.addEventListener('click', e => {
                                e.preventDefault();
                                App.requestBrowseAction(currentLinkPath);
                            });
                            breadcrumb.appendChild(link);
                        }
                    });
                }
            },
            setFileListLoading(isLoading, currentP) {
                const ul = this.elements.fileListUl;
                ul.innerHTML = isLoading
                    ? `<li><em class="no-hover">⏳ ${i18next.t('browser.loadingFiles')}</em></li>`
                    : '';
                ul.style.pointerEvents = isLoading ? 'none' : 'auto';
                ul.style.opacity = isLoading ? 0.6 : 1.0;
                this.elements.createNewFileButton.disabled = isLoading;
                App.updateNewFileButtonUI();
                if (isLoading) {
                    this.updateBreadcrumb(currentP);
                }
            },
            setNewFileButtonUI(text, title, hidden, disabled) {
                const button = this.elements.createNewFileButton;
                if (!button) return;
                button.textContent = text;
                button.title = title;
                button.classList.toggle('hidden', hidden);
                button.disabled = disabled;
            },
            renderFileList(directoryListing, currentP) {
                const ul = this.elements.fileListUl;
                ul.innerHTML = '';
                this.addParentDirectoryLink(currentP);
                AppState.setCurrentPath(currentP);
                App.updateNewFileButtonUI();
                if (directoryListing.length === 0 && !ul.querySelector('.parent-dir')) {
                    const messageKey = PathUtils.normalizePath(currentP) === PathUtils.normalizePath(UserSettings.BASE_BROWSE_PATH)
                        ? 'browser.emptyBaseFolder'
                        : 'browser.emptyFolder';
                    ul.innerHTML += `<li><em class="no-hover"><center>${i18next.t(messageKey)}</center></em></li>`;
                }
                const indexMdPaths = new Set(
                    directoryListing
                        .filter(i => i.type === 'file' && (PathUtils.isPageBundlePath(i.path) || PathUtils.isBranchBundlePath(i.path)))
                        .map(i => i.path.toLowerCase())
                );
                const bundleDirPaths = new Set([...indexMdPaths].map(p => PathUtils.getDirname(p).toLowerCase()));
                const sortedItems = directoryListing.sort((a, b) => {
                    const priority = (item) => item.type === 'dir' ? 0 : (item.name.toLowerCase().endsWith('.md') ? 1 : 2);
                    return priority(a) - priority(b) || a.name.localeCompare(b.name, navigator.language || 'en', { sensitivity: 'base' });
                });
                sortedItems.forEach(item => {
                    const li = document.createElement('li');
                    const textSpan = document.createElement('span');
                    textSpan.textContent = item.name;
                    textSpan.classList.add('file-item-name');
                    li.appendChild(textSpan);
                    li.dataset.path = item.path;
                    if (item.sha) li.dataset.sha = item.sha;
                    let typeClass = '', tooltipKey = '', clickHandler = null, showDraftIcon = false;
                    const normalizedItemPath = PathUtils.normalizePath(item.path);
                    if (item.type === 'dir') {
                        typeClass = 'dir';
                        tooltipKey = 'browser.dirTooltip';
                        clickHandler = () => App.requestBrowseAction(item.path);
                        if (AppState.draftPathsSet.has(PathUtils.normalizePath(PathUtils.joinPaths(normalizedItemPath, 'index.md'))) ||
                            AppState.draftPathsSet.has(PathUtils.normalizePath(PathUtils.joinPaths(normalizedItemPath, '_index.md')))) {
                            showDraftIcon = true;
                            typeClass = 'bundle';
                            tooltipKey = 'browser.bundleTooltip';
                        } else if (bundleDirPaths.has(normalizedItemPath.toLowerCase())) {
                            typeClass = 'bundle';
                            tooltipKey = 'browser.bundleTooltip';
                        }
                    } else if (item.type === 'file') {
                        if (item.name.toLowerCase().endsWith('.md')) {
                            typeClass = 'file';
                            tooltipKey = 'browser.fileTooltip';
                            clickHandler = () => App.requestEditAction(item.path, item.sha);
                            if (AppState.draftPathsSet.has(normalizedItemPath) && !PathUtils.isAnyBundlePath(normalizedItemPath)) {
                                showDraftIcon = true;
                            }
                        } else {
                            typeClass = 'asset';
                            tooltipKey = 'browser.assetTooltip';
                            li.classList.add('no-hover', 'asset');
                        }
                    } else {
                        return;
                    }
                    li.classList.add(typeClass);
                    li.title = i18next.t(tooltipKey, { path: item.path, name: item.name });
                    if (showDraftIcon) {
                        const draftIndicator = document.createElement('span');
                        draftIndicator.textContent = '📝';
                        draftIndicator.classList.add('draft-indicator');
                        draftIndicator.title = 'Draft';
                        li.appendChild(draftIndicator);
                    }
                    if (clickHandler) {
                        li.addEventListener('click', clickHandler);
                    } else {
                        li.classList.add('no-hover');
                    }
                    ul.appendChild(li);
                });
                if (ul.children.length === 0 || (ul.children.length === 1 && ul.children[0].classList.contains('parent-dir'))) {
                    if (!Array.from(ul.children).some(child => child.querySelector('em.no-hover center'))) {
                        const messageKey = PathUtils.normalizePath(currentP) === PathUtils.normalizePath(UserSettings.BASE_BROWSE_PATH)
                            ? 'browser.emptyBaseFolder'
                            : 'browser.emptyFolder';
                        ul.innerHTML += `<li><em class="no-hover"><center>${i18next.t(messageKey)}</center></em></li>`;
                    }
                }
                if (AppState.currentFilePath) {
                    this.highlightActiveFile(AppState.currentFilePath);
                }
            },
            addParentDirectoryLink(currentDirPath) {
                const ul = this.elements.fileListUl;
                const normalizedCurrent = PathUtils.normalizePath(currentDirPath);
                const normalizedBase = PathUtils.normalizePath(UserSettings.BASE_BROWSE_PATH);
                const parentPath = PathUtils.getDirname(normalizedCurrent);
                let isParentValid = parentPath != null && parentPath !== '.' &&
                    (normalizedBase === '' || parentPath === normalizedBase || parentPath.startsWith(normalizedBase + '/')) &&
                    !(parentPath.length < normalizedBase.length && parentPath !== normalizedBase);
                if (normalizedCurrent !== normalizedBase && isParentValid) {
                    const li = document.createElement('li');
                    const textSpan = document.createElement('span');
                    textSpan.innerHTML = i18next.t('browser.parentDirLink');
                    li.appendChild(textSpan);
                    li.classList.add('parent-dir');
                    li.title = i18next.t('browser.dirTooltip', { path: parentPath || '/' });
                    li.addEventListener('click', () => App.requestBrowseAction(parentPath));
                    ul.insertBefore(li, ul.firstChild);
                }
            },
            highlightActiveFile(filePath) {
                this.removeActiveFileHighlight();
                if (!filePath || !this.elements.fileListUl) return;
                try {
                    const activeItem = this.elements.fileListUl.querySelector(`li[data-path="${CSS.escape(filePath)}"]`);
                    if (activeItem) {
                        activeItem.classList.add(AppConstants.ACTIVE_EDIT_CLASS);
                    }
                } catch (e) {
                }
            },
            removeActiveFileHighlight() {
                if (!this.elements.fileListUl) return;
                const currentlyActive = this.elements.fileListUl.querySelector(`.${AppConstants.ACTIVE_EDIT_CLASS}`);
                if (currentlyActive) {
                    currentlyActive.classList.remove(AppConstants.ACTIVE_EDIT_CLASS);
                }
            },
            clearEditorFields(skipVditor = false) {
                this.elements.fileNameInput.value = '';
                FM_FIELD_CONFIG.forEach(field => {
                    const element = this.elements[field.elementId];
                    if (element) {
                        if (field.type === 'datetime') {
                            const fpInstance = (field.key === 'date') ? AppState.flatpickrInstance : AppState.flatpickrLastmodInstance;
                            if (fpInstance) fpInstance.clear(false);
                            element.value = '';
                            const autoCheckbox = this.elements[field.autoCheckboxId];
                            const autoLabel = this.elements[field.autoLabelId];
                            if (autoCheckbox) autoCheckbox.checked = true;
                            if (autoLabel) autoLabel.textContent = i18next.t('editor.fm.autoSetToNow');
                            element.disabled = true;
                        } else if (field.elementId === 'fmTagsInput' || field.elementId === 'fmCategoriesInput') {
                            this.manageTagifyInstance(element, true, '');
                        } else {
                            element.value = '';
                        }
                    }
                });
                this.elements.customFrontMatterContainer.innerHTML = '';
                this.customFieldFlatpickrInstances.forEach(fp => {
                    try { fp.destroy(); } catch(e) {}
                });
                this.customFieldFlatpickrInstances.clear();
                this.tagifyInstances.forEach((instance, key) => {
                    if (key.startsWith('tagify_custom_')) {
                        try { instance.destroy(); } catch(e) {}
                        this.tagifyInstances.delete(key);
                    }
                });
                if (this.elements.fmLastmodContainer) {
                    this.elements.fmLastmodContainer.classList.add('hidden');
                }
                if (!skipVditor && VditorManager.instance && VditorManager.isReady) {
                    try {
                        VditorManager.setValue('');
                    } catch (e) {
                        App.handleGenericError(e, 'errors.vditorSetValueFailed', "Clear Editor Fields");
                    }
                }
                this.setCommitMessage('', i18next.t('editor.commitMessagePlaceholder'));
                this.elements.currentFileShaInput.value = '';
                this.elements.currentFilePathInput.value = '';
                AppState.clearPendingUploads();
                AppState.clearDraftAssets();
                AppState.initialUploadLinks.clear();
                this.removeActiveFileHighlight();
            },
            setFilenameInputMode(isLocalMode) {
                this.elements.fileNameLabel.textContent = i18next.t(
                    isLocalMode ? 'editor.fm.bundlePathLabel' : 'editor.fm.fileNameLabel'
                );
                this.elements.fileNameInput.placeholder = i18next.t(
                    isLocalMode ? 'editor.fm.bundlePathPlaceholder' : 'editor.fm.fileNamePlaceholder'
                );
            },
            async populateEditor(filePath, parsedFrontMatter, fmType, initialDraft, initialHasLastmod) {
                const displayValue = PathUtils.isAnyBundlePath(filePath)
                    ? `${PathUtils.getSlugFromFilename(filePath)}/${PathUtils.getBasename(filePath)}`
                    : PathUtils.getBasename(filePath);
                this.elements.fileNameInput.value = displayValue;
                if(AppState.flatpickrInstance) { try { AppState.flatpickrInstance.destroy(); AppState.flatpickrInstance = null; } catch(e){} }
                if(AppState.flatpickrLastmodInstance) { try { AppState.flatpickrLastmodInstance.destroy(); AppState.flatpickrLastmodInstance = null; } catch(e){} }
                this.customFieldFlatpickrInstances.forEach(fp => {
                    try { fp.destroy(); } catch(e) {}
                });
                this.customFieldFlatpickrInstances.clear();
                const isB1a = initialDraft && !initialHasLastmod;
                const isB2a = !initialDraft && !initialHasLastmod;
                this.initDateField(this.elements.fmDateInput, 'date', parsedFrontMatter.date, isB1a, isB1a);
                this.elements.fmLastmodContainer.classList.toggle('hidden', isB1a);
                if (!isB1a) {
                    this.initDateField(this.elements.fmLastmodInput, 'lastmod', parsedFrontMatter.lastmod, true, true);
                }
                FM_FIELD_CONFIG.forEach(field => {
                    if (field.key === 'date' || field.key === 'lastmod') return;
                    const element = this.elements[field.elementId];
                    const value = parsedFrontMatter[field.key];
                    if (element) {
                       if (field.type === 'array' && (field.elementId === 'fmTagsInput' || field.elementId === 'fmCategoriesInput')) {
                            let valueForInputElement;
                            let valueForTagify;
                            if (Array.isArray(value)) {
                                valueForInputElement = value.join(', ');
                                valueForTagify = value;
                            } else {
                                valueForInputElement = String(value || '');
                                valueForTagify = String(value || '');
                            }
                            element.value = valueForInputElement;
                            this.manageTagifyInstance(element, true, valueForTagify);
                        } else if (field.type === 'array') {
                            const arrayValue = Array.isArray(value) ? value.join(', ') : (String(value || ''));
                            element.value = arrayValue;
                        } else {
                            element.value = String(value || '');
                        }
                    }
                });
                this.elements.customFrontMatterContainer.innerHTML = '';
                const customFieldPromises = [];
                const standardKeysLower = AppConstants.STANDARD_FM_KEYS.map(k => k.toLowerCase());
                for (const key in parsedFrontMatter) {
                    if (Object.hasOwnProperty.call(parsedFrontMatter, key) && !standardKeysLower.includes(key.toLowerCase())) {
                        let fieldType = null;
                        const fieldValue = parsedFrontMatter[key];
                        if (typeof fieldValue === 'boolean') fieldType = 'boolean';
                        else if (typeof fieldValue === 'number') fieldType = 'number';
                        else if (Array.isArray(fieldValue)) fieldType = 'array';
                        else if (typeof fieldValue === 'string' && (flatpickr.parseDate(fieldValue, "Z") || flatpickr.parseDate(fieldValue, "Y-m-d H:i:S") || flatpickr.parseDate(fieldValue, "Y-m-d")) && !/^\d+$/.test(fieldValue)) fieldType = 'date';
                        else if (fieldValue instanceof Date) fieldType = 'date';
                        else fieldType = 'string';
                        customFieldPromises.push(this.addCustomFieldRow(key, fieldValue, fieldType));
                    }
                }
                await Promise.all(customFieldPromises);
                this.setEditorButtonLabels(true, initialDraft);
                this.highlightActiveFile(filePath);
                let fmInfoKey = fmType === 'yaml' ? 'statusBar.fmInfoYAML'
                            : fmType === 'toml' ? 'statusBar.fmInfoTOML'
                            : (fmType === 'none' ? 'statusBar.fmInfoNone' : '');
                this.updateStatus(i18next.t(
                    fmType === 'error' ? 'statusBar.fileLoadedWithError' : 'statusBar.fileLoaded',
                    { path: filePath, fmInfo: fmInfoKey ? i18next.t(fmInfoKey) : '' }
                ), fmType === 'error', true);
                VditorManager.focus();
            },
            createValueInputElement(typeConfig, value = '') {
                const input = document.createElement('input');
                input.type = typeConfig.inputType;
                input.className = 'custom-fm-value';
                if (typeConfig.inputType === 'text') {
                    input.placeholder = i18next.t('editor.fm.customValuePlaceholder');
                    input.value = String(value ?? '');
                    if (typeConfig.inputMode) {
                        input.inputMode = typeConfig.inputMode;
                    }
                    if (typeConfig.isDate) {
                        input.dataset.isDateField = 'true';
                    }
                } else if (typeConfig.inputType === 'checkbox') {
                    input.checked = typeof value === 'boolean' ? value : String(value).toLowerCase() === 'true';
                }
                input.id = `custom_val_${Date.now()}_${Math.random().toString(36).substr(2, 5)}`;
                return input;
            },
            async updateCustomFieldValueInput(valueContainer, selectedType, currentValue) {
                return new Promise((resolve) => {
                    const oldValInput = valueContainer.querySelector('.custom-fm-value, .tagify');
                    if (oldValInput && oldValInput.id) {
                        if (this.customFieldFlatpickrInstances.has(oldValInput.id)) {
                            this.customFieldFlatpickrInstances.get(oldValInput.id).destroy();
                            this.customFieldFlatpickrInstances.delete(oldValInput.id);
                        }
                        if (oldValInput.tagName?.toLowerCase() === 'input' || oldValInput.tagName?.toLowerCase() === 'textarea' || oldValInput.classList?.contains('tagify')) {
                            const originalInput = oldValInput.classList.contains('tagify') ? oldValInput.querySelector('input, textarea') : oldValInput;
                            if (originalInput) this.manageTagifyInstance(originalInput, false);
                        }
                    }
                    valueContainer.innerHTML = '';
                    const typeConfig = AppConstants.CUSTOM_FM_TYPES.find(t => t.value === selectedType);
                    if (!typeConfig) {
                        resolve();
                        return;
                    }
                    let displayValue = currentValue;
                    let newInput;
                    if (selectedType === 'array') {
                        newInput = document.createElement('input');
                        newInput.type = 'text';
                        newInput.className = 'custom-fm-value';
                        const newGeneratedId = `tagify_custom_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
                        newInput.id = newGeneratedId;
                        displayValue = Array.isArray(currentValue) ? currentValue.join(',') : String(currentValue ?? '');
                        newInput.value = displayValue;
                        valueContainer.appendChild(newInput);
                        requestAnimationFrame(() => {
                            this.manageTagifyInstance(newInput, true, displayValue);
                            resolve();
                        });
                    } else {
                        if (typeConfig.inputType === 'checkbox') {
                            displayValue = (String(currentValue).toLowerCase() === 'true' || currentValue === true);
                        } else if (typeConfig.isDate) {
                            if (currentValue) {
                                try {
                                    const parsedDate = flatpickr.parseDate(String(currentValue), "Y-m-d H:i:S") || flatpickr.parseDate(String(currentValue), "Z") || new Date(currentValue);
                                    displayValue = (parsedDate && !isNaN(parsedDate.getTime())) ? flatpickr.formatDate(parsedDate, "Y-m-d H:i") : String(currentValue);
                                } catch(e) { displayValue = String(currentValue); }
                            } else {
                                displayValue = '';
                            }
                        } else {
                            displayValue = String(currentValue ?? '');
                        }
                        newInput = this.createValueInputElement(typeConfig, displayValue);
                        valueContainer.appendChild(newInput);
                        if (typeConfig.inputType === 'checkbox') {
                            const booleanLabel = document.createElement('span');
                            booleanLabel.className = 'custom-fm-boolean-label';
                            booleanLabel.style.marginLeft = '5px';
                            const updateBooleanLabel = (checked) => {
                                booleanLabel.textContent = checked ? i18next.t('editor.fm.typeBooleanTrue') : i18next.t('editor.fm.typeBooleanFalse');
                            };
                            updateBooleanLabel(newInput.checked);
                            newInput.addEventListener('change', () => {
                                updateBooleanLabel(newInput.checked);
                                App.refreshEditorUIState();
                            });
                            valueContainer.appendChild(booleanLabel);
                        } else if (typeConfig.isDate) {
                            newInput.readOnly = true;
                            const fpInstance = flatpickr(newInput, {
                                enableTime: true, time_24hr: true, allowInput: false, dateFormat: "Y-m-d H:i", static: true,
                                onChange: () => App.refreshEditorUIState(),
                                onClose: (selectedDates, dateStr, instance) => {
                                    if (selectedDates.length > 0) instance.input.value = flatpickr.formatDate(selectedDates[0], "Y-m-d H:i");
                                    App.refreshEditorUIState();
                                }
                            });
                            if (newInput.id) {
                                this.customFieldFlatpickrInstances.set(newInput.id, fpInstance);
                                if (displayValue) fpInstance.setDate(displayValue, true);
                            } else { }
                        }
                        if (newInput && newInput.type !== 'checkbox' && selectedType !== 'array' && !typeConfig.isDate) {
                            newInput.addEventListener('input', () => App.refreshEditorUIState());
                        }
                        resolve();
                    }
                });
            },
            async addCustomFieldRow(key = '', value = '', explicitTypeFromArg = null) {
                const rowDiv = document.createElement('div');
                rowDiv.className = 'custom-fm-row';
                const keyInput = document.createElement('input');
                keyInput.type = 'text';
                keyInput.placeholder = i18next.t('editor.fm.customKeyPlaceholder');
                keyInput.className = 'custom-fm-key';
                keyInput.value = key;
                keyInput.addEventListener('input', () => App.refreshEditorUIState());
                const valueContainer = document.createElement('div');
                valueContainer.className = 'custom-fm-value-container';
                const typeSelect = document.createElement('select');
                typeSelect.className = 'custom-fm-type';
                AppConstants.CUSTOM_FM_TYPES.forEach(typeOpt => {
                    const option = document.createElement('option');
                    option.value = typeOpt.value;
                    option.textContent = i18next.t(typeOpt.labelKey);
                    typeSelect.appendChild(option);
                });
                let inferredType;
                if (explicitTypeFromArg && AppConstants.CUSTOM_FM_TYPES.some(t => t.value === explicitTypeFromArg)) {
                    inferredType = explicitTypeFromArg;
                } else if (value !== undefined && value !== null) {
                    if (typeof value === 'boolean') inferredType = 'boolean';
                    else if (typeof value === 'number') inferredType = 'number';
                    else if (Array.isArray(value)) inferredType = 'array';
                    else if (typeof value === 'string' && (flatpickr.parseDate(value, "Z") || flatpickr.parseDate(value, "Y-m-d H:i:S") || flatpickr.parseDate(value, "Y-m-d")) && !/^\d+$/.test(value)) inferredType = 'date';
                    else if (value instanceof Date) inferredType = 'date';
                    else inferredType = 'string';
                } else {
                    inferredType = 'string';
                }
                typeSelect.value = inferredType;
                rowDiv.appendChild(typeSelect);
                rowDiv.appendChild(keyInput);
                rowDiv.appendChild(valueContainer);
                await this.updateCustomFieldValueInput(valueContainer, typeSelect.value, value);
                typeSelect.addEventListener('change', async (e) => {
                    const newSelectedType = e.target.value;
                    let initialValueForNewType = (newSelectedType === 'boolean') ? false : '';
                    await this.updateCustomFieldValueInput(valueContainer, newSelectedType, initialValueForNewType);
                    App.refreshEditorUIState();
                });
                const removeButton = document.createElement('button');
                removeButton.type = 'button';
                removeButton.textContent = i18next.t('editor.fm.removeCustomFieldButton');
                removeButton.className = 'remove-custom-fm-button';
                removeButton.title = i18next.t('editor.fm.removeCustomFieldButtonTooltip');
                removeButton.addEventListener('click', () => {
                    const valueInputInContainer = valueContainer.querySelector('.custom-fm-value, .tagify');
                    if (valueInputInContainer && valueInputInContainer.id) {
                        if (this.customFieldFlatpickrInstances.has(valueInputInContainer.id)) {
                            this.customFieldFlatpickrInstances.get(valueInputInContainer.id).destroy();
                            this.customFieldFlatpickrInstances.delete(valueInputInContainer.id);
                        }
                        if (valueInputInContainer.tagName?.toLowerCase() === 'input' || valueInputInContainer.tagName?.toLowerCase() === 'textarea' || valueInputInContainer.classList?.contains('tagify')) {
                            const originalInput = valueInputInContainer.classList.contains('tagify') ? valueInputInContainer.querySelector('input, textarea') : valueInputInContainer;
                            if (originalInput) this.manageTagifyInstance(originalInput, false);
                        }
                    }
                    rowDiv.remove();
                    App.refreshEditorUIState();
                });
                rowDiv.appendChild(removeButton);
                this.elements.customFrontMatterContainer.appendChild(rowDiv);
                if (!key) {
                    keyInput.focus();
                }
            },
            getRawEditorFormData() {
                const formData = {
                    custom: [],
                    commitMessage: this.elements.commitMessageInput.value.trim(),
                    fullPathValue: this.elements.fileNameInput.value.trim()
                };
                FM_FIELD_CONFIG.forEach(field => {
                    const element = this.elements[field.elementId];
                    if (element) {
                        if ((field.key === 'tags' || field.key === 'categories') && this.tagifyInstances.has(field.elementId)) {
                            const tagifyInstance = this.tagifyInstances.get(field.elementId);
                            formData[field.key] = tagifyInstance.value.map(tag => tag.value).sort();
                        } else if (field.type === 'datetime') {
                            formData[field.key] = element.value.trim();
                            if (this.elements[field.autoCheckboxId]) {
                                formData[`${field.key}AutoChecked`] = this.elements[field.autoCheckboxId].checked;
                            }
                        }
                         else {
                            formData[field.key] = element.value.trim();
                        }
                    }
                });
                if (!this.elements.customFrontMatterContainer) {
                    return formData;
                }
                this.elements.customFrontMatterContainer.querySelectorAll('.custom-fm-row').forEach((row) => {
                    const keyInput = row.querySelector('.custom-fm-key');
                    const typeSelect = row.querySelector('.custom-fm-type');
                    let valueInputElement = null;
                    if (!keyInput || !typeSelect) {
                        return;
                    }
                    const selectedType = typeSelect.value;
                    if (selectedType === 'array') {
                        valueInputElement = row.querySelector('input.custom-fm-value[id^="tagify_custom_"], textarea.custom-fm-value[id^="tagify_custom_"]');
                    } else if (selectedType === 'boolean') {
                        valueInputElement = row.querySelector('input.custom-fm-value[type="checkbox"]');
                    } else if (selectedType === 'date') {
                        valueInputElement = row.querySelector('input.custom-fm-value[data-is-date-field="true"]');
                        if (!valueInputElement) {
                            valueInputElement = row.querySelector('input.custom-fm-value.flatpickr-input[type="text"]');
                        }
                        if (!valueInputElement) {
                            valueInputElement = row.querySelector('input.custom-fm-value.flatpickr-input[type="hidden"]');
                        }
                        if (!valueInputElement) {
                            valueInputElement = row.querySelector('input.custom-fm-value.flatpickr-input.flatpickr-mobile[type="datetime-local"]');
                        }
                    } else {
                        valueInputElement = row.querySelector('input.custom-fm-value[type="text"]');
                    }
                    if (!valueInputElement) {
                        return;
                    }
                    const key = keyInput.value.trim();
                    const type = selectedType;
                    let valueToPush;
                    if (key) {
                        if (type === 'array') {
                            if (valueInputElement.id && this.tagifyInstances.has(valueInputElement.id)) {
                                const tagifyInstance = this.tagifyInstances.get(valueInputElement.id);
                                valueToPush = tagifyInstance.value
                                    .map(tag => tag.value)
                                    .filter(val => val !== undefined && val !== null && String(val).trim() !== '')
                                    .sort();
                            } else {
                                valueToPush = valueInputElement.value.split(',')
                                    .map(s => s.trim())
                                    .filter(s => s !== '')
                                    .sort();
                            }
                        } else if (type === 'boolean') {
                            valueToPush = valueInputElement.checked;
                        } else {
                            valueToPush = valueInputElement.value;
                        }
                        formData.custom.push({
                            key: key,
                            value: valueToPush,
                            type: type
                        });
                    }
                });
                return formData;
            },
            setCommitMessage(message, placeholder) {
                this.elements.commitMessageInput.value = message;
                this.elements.commitMessageInput.placeholder = placeholder || i18next.t('editor.commitMessagePlaceholder');
            },
            setEditorButtonLabels(isEditing, isDraftInitially) {
                if (isEditing && !isDraftInitially) {
                    this.elements.saveDraftButton.textContent = i18next.t('editor.revertToDraftButton');
                    this.elements.publishButton.textContent = i18next.t('editor.updateAndPublishButton');
                } else {
                    this.elements.saveDraftButton.textContent = i18next.t('editor.saveDraftButton');
                    this.elements.publishButton.textContent = i18next.t('editor.publishButton');
                }
            },
            setEditorActionButtonsState(canSaveDraft, canPublish, canDelete, canCancel) {
                this.elements.saveDraftButton.disabled = !canSaveDraft;
                this.elements.publishButton.disabled = !canPublish;
                this.elements.deleteFileButton.disabled = !canDelete;
                this.elements.cancelEditButton.disabled = !canCancel;
            },
            setEditorSaving(isSaving) {
                this.elements.editorSection.querySelectorAll('input, select, button, textarea, .tagify').forEach(el => {
                    if (el !== this.elements.statusBar && el !== this.elements.errorStatusBarContainer &&
                        el !== this.elements.saveDraftButton && el !== this.elements.publishButton &&
                        el !== this.elements.deleteFileButton && el !== this.elements.cancelEditButton) {
                        if (el.classList.contains('tagify')) {
                             const tagifyInstance = Array.from(this.tagifyInstances.values()).find(inst => inst.DOM.scope === el);
                             if(tagifyInstance) tagifyInstance.setDisabled(isSaving);
                        } else {
                            el.disabled = isSaving;
                        }
                    }
                });
                if (VditorManager.instance) {
                    if (isSaving) VditorManager.disable(); else VditorManager.enable();
                }
                this.elements.saveDraftButton.disabled = isSaving;
                this.elements.publishButton.disabled = isSaving;
                this.elements.deleteFileButton.disabled = isSaving || !AppState.currentFileSha;
                this.elements.cancelEditButton.disabled = isSaving;
                this.elements.addCustomFieldButton.disabled = isSaving;
                this.elements.customFrontMatterContainer.querySelectorAll('.remove-custom-fm-button')
                    .forEach(btn => btn.disabled = isSaving);
            },
            updateAllText() {
                document.querySelectorAll('[data-i18n]').forEach(el => {
                    const key = el.getAttribute('data-i18n');
                    if (!key) return;
                    let translationKey = key, attributeToSet = 'textContent';
                    if (key.startsWith('[placeholder]')) {
                        translationKey = key.substring('[placeholder]'.length);
                        attributeToSet = 'placeholder';
                    } else if (key.startsWith('[title]')) {
                        translationKey = key.substring('[title]'.length);
                        attributeToSet = 'title';
                    } else if (key.startsWith('[html]')) {
                        translationKey = key.substring('[html]'.length);
                        attributeToSet = 'innerHTML';
                    }
                    if (translationKey === 'editor.fm.baseNote' && el) {
                        el.innerHTML = i18next.t(translationKey, { format: UserSettings.FRONTMATTER_FORMAT.toUpperCase() });
                    } else if (translationKey === 'browser.newFileButtonInFolder') {
                        App.updateNewFileButtonUI();
                    } else if (translationKey === 'editor.saveDraftButton' || translationKey === 'editor.publishButton') {
                        this.setEditorButtonLabels(!!AppState.currentFileSha, AppState.initialDraftState);
                    } else if (translationKey === 'editor.fm.autoSetToNow' || translationKey === 'editor.fm.manualInput') {
                        if (el.id === 'fmDateAutoLabel') {
                            el.textContent = this.elements.fmDateAutoCheckbox.checked ? i18next.t('editor.fm.autoSetToNow') : i18next.t('editor.fm.manualInput');
                        } else if (el.id === 'fmLastmodAutoLabel') {
                            el.textContent = this.elements.fmLastmodAutoCheckbox.checked ? i18next.t('editor.fm.autoSetToNow') : i18next.t('editor.fm.manualInput');
                        }
                    }
                    else {
                        try {
                            const translatedText = i18next.t(translationKey);
                            el[attributeToSet] = translatedText;
                        } catch (e) {
                        }
                    }
                });
                if (this.elements.customFrontMatterContainer) {
                    this.elements.customFrontMatterContainer.querySelectorAll('.remove-custom-fm-button').forEach(button => {
                        button.textContent = i18next.t('editor.fm.removeCustomFieldButton');
                        button.title = i18next.t('editor.fm.removeCustomFieldButtonTooltip');
                    });
                    this.elements.customFrontMatterContainer.querySelectorAll('.custom-fm-type option').forEach(option => {
                         const typeConfig = AppConstants.CUSTOM_FM_TYPES.find(t => t.value === option.value);
                         if (typeConfig) option.textContent = i18next.t(typeConfig.labelKey);
                    });
                }
                document.documentElement.lang = AppState.currentLang;
                this.setFilenameInputMode(AppState.isCurrentOperationTargetingLocal());
            },
        };
        const GitHubService = {
            async authenticate(token) {
                AppState.octokit = new Octokit({ auth: token });
                try {
                    const { data: user } = await AppState.octokit.rest.users.getAuthenticated();
                    return { success: true, user };
                } catch (error) {
                    AppState.octokit = null;
                    return { success: false, error };
                }
            },
            async listRepos() {
                if (!AppState.octokit) throw new Error(i18next.t('errors.noAuth'));
                try {
                    const repos = await AppState.octokit.paginate(
                        AppState.octokit.rest.repos.listForAuthenticatedUser,
                        { type: 'all', sort: 'updated', per_page: 100 }
                    );
                    return { success: true, repos };
                } catch (error) {
                    return { success: false, error };
                }
            },
            async getContent(p) {
                if (!AppState.octokit || !AppState.owner || !AppState.repo) {
                    throw new Error(i18next.t('errors.missingContext'));
                }
                try {
                    const { data } = await AppState.octokit.rest.repos.getContent({
                        owner: AppState.owner,
                        repo: AppState.repo,
                        path: p,
                        ref: AppState.branch,
                        headers: { 'If-None-Match': '' }
                    });
                    const contentList = Array.isArray(data) ? data : [data];
                    const items = contentList
                        .map(item => ({
                            name: item.name,
                            path: item.path,
                            sha: item.sha,
                            type: item.type,
                            size: item.size
                        }))
                        .sort((a, b) => {
                            const aIsIndexMd = PathUtils.isPageBundlePath(a.path) || PathUtils.isBranchBundlePath(a.path);
                            const bIsIndexMd = PathUtils.isPageBundlePath(b.path) || PathUtils.isBranchBundlePath(b.path);
                            if (aIsIndexMd && !bIsIndexMd) return -1;
                            if (!aIsIndexMd && bIsIndexMd) return 1;
                            if (a.type !== b.type) return a.type === 'dir' ? -1 : 1;
                            return a.name.localeCompare(b.name, navigator.language || 'en', { sensitivity: 'base' });
                        });
                    return { success: true, items };
                } catch (error) {
                    return { success: false, error, path: p, notFound: error.status === 404 };
                }
            },
            async getFileContent(filePath, fileSha) {
                if (!AppState.octokit || !AppState.owner || !AppState.repo) {
                    throw new Error(i18next.t('errors.missingContext'));
                }
                try {
                    const { data: blobData } = await AppState.octokit.rest.git.getBlob({
                        owner: AppState.owner,
                        repo: AppState.repo,
                        file_sha: fileSha,
                        headers: { 'If-None-Match': '' }
                    });
                    if (!blobData || typeof blobData.content === 'undefined' || blobData.encoding !== 'base64' || !blobData.sha) {
                        throw new Error(i18next.t('errors.missingBlob'));
                    }
                    if (blobData.size > 1048576) {
                        UIManager.updateStatus(i18next.t('errors.largeFileWarn', { sizeMB: (blobData.size / 1048576).toFixed(2) }), false);
                    }
                    const decodedContent = EncodingUtils.b64DecodeUnicode(blobData.content);
                    const { frontMatter, body, type } = FrontMatterUtils.parseFrontMatterAndBody(decodedContent);
                    return { success: true, path: filePath, sha: blobData.sha, frontMatter, body, type };
                } catch (error) {
                    return { success: false, error, path: filePath, sha: fileSha, notFound: error.status === 404 };
                }
            },
            async getRawAssetContent(assetPath) {
                if (!AppState.octokit || !AppState.owner || !AppState.repo) {
                    throw new Error(i18next.t('errors.missingContext'));
                }
                try {
                    const { data } = await AppState.octokit.rest.repos.getContent({
                        owner: AppState.owner,
                        repo: AppState.repo,
                        path: assetPath,
                        ref: AppState.branch,
                        headers: { 'If-None-Match': '' }
                    });
                    if (data.type === 'file' && data.content && data.encoding === 'base64') {
                        return { success: true, content: data.content, path: assetPath, sha: data.sha };
                    }
                    throw new Error('Invalid asset data received from API.');
                } catch (error) {
                    return { success: false, error, path: assetPath, notFound: error.status === 404 };
                }
            },
            async getRef(ref = `heads/${AppState.branch}`) {
                if (!AppState.octokit || !AppState.owner || !AppState.repo) throw new Error(i18next.t('errors.missingContext'));
                try {
                    const { data } = await AppState.octokit.rest.git.getRef({
                        owner: AppState.owner,
                        repo: AppState.repo,
                        ref
                    });
                    return { success: true, sha: data.object.sha, ref: data.ref };
                } catch (error) {
                    return { success: false, error };
                }
            },
            async getCommit(commitSha) {
                if (!AppState.octokit || !AppState.owner || !AppState.repo) throw new Error(i18next.t('errors.missingContext'));
                try {
                    const { data } = await AppState.octokit.rest.git.getCommit({
                        owner: AppState.owner,
                        repo: AppState.repo,
                        commit_sha: commitSha
                    });
                    return { success: true, treeSha: data.tree.sha, commit: data };
                } catch (error) {
                    return { success: false, error };
                }
            },
            async createBlob(content, encoding = 'utf-8') {
                if (!AppState.octokit || !AppState.owner || !AppState.repo) throw new Error(i18next.t('errors.missingContext'));
                try {
                    const { data } = await AppState.octokit.rest.git.createBlob({
                        owner: AppState.owner,
                        repo: AppState.repo,
                        content,
                        encoding
                    });
                    return { success: true, sha: data.sha };
                } catch (error) {
                    return { success: false, error };
                }
            },
            async createTree(baseTreeSha, treeDefinition) {
                if (!AppState.octokit || !AppState.owner || !AppState.repo) throw new Error(i18next.t('errors.missingContext'));
                try {
                    const { data } = await AppState.octokit.rest.git.createTree({
                        owner: AppState.owner,
                        repo: AppState.repo,
                        base_tree: baseTreeSha,
                        tree: treeDefinition
                    });
                    return { success: true, sha: data.sha };
                } catch (error) {
                    return { success: false, error };
                }
            },
            async createCommit(treeSha, parentCommitSha, message) {
                if (!AppState.octokit || !AppState.owner || !AppState.repo) throw new Error(i18next.t('errors.missingContext'));
                try {
                    const { data } = await AppState.octokit.rest.git.createCommit({
                        owner: AppState.owner,
                        repo: AppState.repo,
                        message,
                        tree: treeSha,
                        parents: [parentCommitSha]
                    });
                    return { success: true, sha: data.sha };
                } catch (error) {
                    return { success: false, error };
                }
            },
            async updateRef(commitSha, ref = `heads/${AppState.branch}`) {
                if (!AppState.octokit || !AppState.owner || !AppState.repo) throw new Error(i18next.t('errors.missingContext'));
                try {
                    await AppState.octokit.rest.git.updateRef({
                        owner: AppState.owner,
                        repo: AppState.repo,
                        ref,
                        sha: commitSha,
                        force: false
                    });
                    return { success: true };
                } catch (error) {
                    return { success: false, error };
                }
            },
            async getFolderContentsRecursive(folderPath) {
                if (!AppState.octokit || !AppState.owner || !AppState.repo) {
                    throw new Error(i18next.t('errors.missingContext'));
                }
                let allItems = [];
                const stack = [folderPath];
                const processedPaths = new Set();
                while (stack.length > 0) {
                    const currentPath = stack.pop();
                    if (processedPaths.has(currentPath)) continue;
                    processedPaths.add(currentPath);
                    try {
                        const { data } = await AppState.octokit.rest.repos.getContent({
                            owner: AppState.owner,
                            repo: AppState.repo,
                            path: currentPath,
                            ref: AppState.branch,
                            headers: { 'If-None-Match': '' }
                        });
                        if (Array.isArray(data)) {
                            data.forEach(item => {
                                allItems.push({ path: item.path, sha: item.sha, type: item.type });
                                if (item.type === 'dir') {
                                    stack.push(item.path);
                                }
                            });
                        } else if (data && data.type === 'file') {
                            allItems.push({ path: data.path, sha: data.sha, type: 'file' });
                        }
                    } catch (error) {
                        if (error.status === 404) {
                            return null;
                        } else {
                            throw error;
                        }
                    }
                }
                return allItems;
            },
        };
        const App = {
            elements: {},
            themeMediaQuery: null,
            reverseDraftAssetMap: {},
            init() {
                AppState.currentLang = UserSettings.DEFAULT_LANGUAGE;
                document.documentElement.lang = AppState.currentLang;
                i18next.init({
                    lng: AppState.currentLang,
                    fallbackLng: UserSettings.DEFAULT_LANGUAGE,
                    debug: false,
                    resources: resources,
                    interpolation: { escapeValue: false, prefix: '__', suffix: '__' }
                }).then(() => {
                    UIManager.init();
                    this.elements = UIManager.elements;
                    UIManager.updateAllText();
                    AppState.parseUrlQuery();
                    this.setupThemeHandling();
                    this.setupEventListeners();
                    const localeKey = UserSettings.DEFAULT_LANGUAGE;
                    let localeObj;
                    switch (localeKey) {
                        case 'ko': localeObj = Korean; break;
                        case 'zh': localeObj = Chinese; break;
                        case 'ja': localeObj = Japanese; break;
                        case 'es': localeObj = Spanish; break;
                        case 'de': localeObj = German; break;
                        case 'fr': localeObj = French; break;
                        case 'pt': localeObj = Portuguese; break;
                        case 'ru': localeObj = Russian; break;
                        default: localeObj = flatpickr.l10ns.default; break;
                    }
                    flatpickr.localize(localeObj);
                    const storedPat = localStorage.getItem(AppConstants.PAT_STORAGE_KEY);
                    if (storedPat) {
                        this.autoLogin(storedPat);
                    } else {
                        UIManager.resetLoginScreen();
                        UIManager.updateStatus(i18next.t('statusBar.waiting'));
                    }
                }).catch(err => {
                    this.handleGenericError(err, "i18n init failed.", "App Initialization");
                    document.body.innerHTML = `<h1 style="color: red;">${resources.en.translation['errors.appLoad']}</h1><p>${resources.en.translation['errors.scriptError']}</p><p>i18n init failed.</p>`;
                });
            },
            setBaseTag(href) {
                let baseTag = document.getElementById('dynamic-base-tag');
                const head = document.head;
                if (href) {
                    if (!baseTag) {
                        baseTag = document.createElement('base');
                        baseTag.id = 'dynamic-base-tag';
                        const existingBase = head.querySelector('base');
                        if (existingBase) {
                            head.insertBefore(baseTag, existingBase);
                        } else {
                            head.prepend(baseTag);
                        }
                    }
                    try {
                        const finalHref = href.startsWith('http')
                            ? href
                            : new URL(href, window.location.origin).href;
                        baseTag.href = finalHref.endsWith('/') ? finalHref : finalHref + '/';
                    } catch (e) {
                        this.handleGenericError(e, "Error setting base tag href", "Base Tag Handling", { inputHref: href });
                        if (baseTag) baseTag.remove();
                    }
                } else if (baseTag) {
                    baseTag.remove();
                }
            },
            handleApiError(error, contextMessageKey, details = {}) {
                let userMessage, errorCode = error?.status, shouldLogout = false;
                let messageOptions = {
                    context: i18next.t(contextMessageKey),
                    code: errorCode,
                    message: error?.message || i18next.t('errors.unknownError'),
                    path: details.path || 'N/A',
                    slug: details.slug || 'N/A',
                    dirPath: details.dirPath || 'N/A'
                };
                if (errorCode) {
                    switch (errorCode) {
                        case 401:
                            userMessage = i18next.t('errors.authError', messageOptions);
                            shouldLogout = true;
                            break;
                        case 403:
                            userMessage = i18next.t('errors.permissionError', messageOptions);
                            if (error.message?.toLowerCase().includes("rate limit exceeded")) {
                                userMessage += i18next.t('errors.rateLimit');
                            } else if (error.message?.toLowerCase().includes("resource not accessible") || error.message?.toLowerCase().includes("repository access denied")) {
                                userMessage += i18next.t('errors.repoAccessDenied');
                            }
                            break;
                        case 404:
                            userMessage = i18next.t('errors.notFoundError', messageOptions);
                            break;
                        case 409:
                            userMessage = i18next.t('errors.conflictError', messageOptions);
                            break;
                        case 422:
                            userMessage = i18next.t('errors.unprocessableError', messageOptions);
                            break;
                        default:
                            userMessage = i18next.t('errors.genericApiError', messageOptions);
                    }
                } else if (error?.message?.toLowerCase().includes('fetch') || (error instanceof TypeError && error.message.includes('NetworkError'))) {
                    userMessage = i18next.t('errors.contextualNetworkError', { context: i18next.t(contextMessageKey) });
                } else {
                    userMessage = i18next.t('errors.unexpectedErrorContext', messageOptions);
                }
                UIManager.updateStatus(`${userMessage}`, true);
                UIManager.setEditorSaving(false);
                UIManager.setRepoLoading(false);
                UIManager.setFileListLoading(false, AppState.currentPath);
                if (shouldLogout) {
                    this.handleLogout();
                }
            },
            handleGenericError(error, userMessageOrKey, context = "General Error", details = {}) {
                let message = i18next.exists(userMessageOrKey)
                    ? i18next.t(userMessageOrKey, details)
                    : (userMessageOrKey || i18next.t('errors.unknownError', { message: error?.message || 'Unknown' }));
                UIManager.updateStatus(message, true);
            },
            async loadDraftStatus() {
                AppState.draftPathsSet.clear();
                if (UIManager.elements.draftFilterContainer) {
                    UIManager.elements.draftFilterContainer.classList.add('hidden');
                }
                if (!AppState.octokit || !AppState.owner || !AppState.repo) return;
                const draftFilePath = 'drafts.json';
                try {
                    const { data } = await AppState.octokit.request('GET /repos/{owner}/{repo}/contents/{path}', {
                        owner: AppState.owner,
                        repo: AppState.repo,
                        path: draftFilePath,
                        ref: AppState.branch,
                        headers: { 'If-None-Match': '' }
                    });
                    if (data && data.type === 'file' && data.content) {
                        const decodedContent = EncodingUtils.b64DecodeUnicode(data.content);
                        let draftPaths = null;
                        try {
                            draftPaths = JSON.parse(decodedContent);
                        } catch (parseError) {
                            this.handleGenericError(parseError, i18next.t('errors.apiError', { message: `Failed to parse ${draftFilePath}: ${parseError.message}` }), "Draft Status Parsing");
                            AppState.draftPathsSet.clear();
                            return;
                        }
                        if (Array.isArray(draftPaths)) {
                            AppState.draftPathsSet = new Set(draftPaths.map(p => PathUtils.normalizePath(p)));
                            if (UIManager.elements.draftFilterContainer) {
                                UIManager.elements.draftFilterContainer.classList.remove('hidden');
                            }
                        } else {
                            AppState.draftPathsSet.clear();
                        }
                    } else {
                        AppState.draftPathsSet.clear();
                    }
                } catch (error) {
                    if (error.status !== 404) {
                        this.handleApiError(error, `Failed to load ${draftFilePath}`, { path: draftFilePath });
                    }
                    AppState.draftPathsSet.clear();
                }
            },
            handleLocalLink: (href, markdownFilePath, localAssetSubdir) => {
                const normalizedHref = PathUtils.normalizePath(href);
                const normalizedSubdir = PathUtils.normalizePath(localAssetSubdir);
                const markdownDir = PathUtils.getDirname(markdownFilePath);
                if (normalizedSubdir && (normalizedHref.startsWith(normalizedSubdir + '/') || normalizedHref === normalizedSubdir)) {
                    return PathUtils.joinPaths(markdownDir, normalizedHref);
                } else {
                    let pathSegments = [markdownDir];
                    if (normalizedSubdir) {
                        pathSegments.push(normalizedSubdir);
                    }
                    pathSegments.push(normalizedHref.startsWith('./') ? normalizedHref.substring(2) : normalizedHref);
                    return PathUtils.joinPaths(...pathSegments);
                }
            },
            handleGlobalLink(href, markdownFilePath, globalRootDir, globalAssetSubpath) {
                const normalizedRootDir = PathUtils.normalizePath(globalRootDir);
                const normalizedAssetSubpath = PathUtils.normalizePath(globalAssetSubpath);
                const baseBrowsePath = PathUtils.normalizePath(UserSettings.BASE_BROWSE_PATH);
                const markdownDir = PathUtils.getDirname(markdownFilePath);
                const postSlug = PathUtils.getSlugFromFilename(markdownFilePath);
                let subFolderPath = (markdownDir.startsWith(baseBrowsePath) && markdownDir.length > baseBrowsePath.length && markdownDir !== baseBrowsePath)
                    ? markdownDir.substring(baseBrowsePath.length + 1)
                    : '';
                let webPathPrefix = '/' + PathUtils.normalizePath(PathUtils.joinPaths(
                    UserSettings.OMIT_GLOBAL_ROOT_DIR_FROM_URL ? '' : normalizedRootDir,
                    normalizedAssetSubpath,
                    subFolderPath,
                    postSlug
                )) + '/';
                webPathPrefix = webPathPrefix.replace(/\/+/g, '/');
                return href.startsWith(webPathPrefix)
                    ? PathUtils.normalizePath(PathUtils.joinPaths(
                        normalizedRootDir,
                        normalizedAssetSubpath,
                        subFolderPath,
                        postSlug,
                        PathUtils.getBasename(href)
                    ))
                    : null;
            },
            parseManagedUploadLinks(markdownBody, markdownFilePath = null) {
                const links = new Set();
                if (!markdownBody || typeof marked === 'undefined' || !markdownFilePath) return links;
                const isAssetStrategyLocal = UserSettings.ASSET_STRATEGY === 'local';
                const isEditingBundleFile = PathUtils.isAnyBundlePath(markdownFilePath);
                const markdownLinkRegex = /(!?\[[^\]]*\]\()([^)]+)\)/g;
                let match;
                while ((match = markdownLinkRegex.exec(markdownBody)) !== null) {
                    let href = match[2] ? String(match[2]).trim() : null;
                    if (!href) continue;
                    try {
                        href = Utils.cleanUrl(href);
                        let githubPath = null;
                        const isPotentiallyRelative = !href.startsWith('/') &&
                            !href.startsWith('http') &&
                            !href.startsWith('#') &&
                            !href.startsWith('mailto:') &&
                            !href.includes(':') &&
                            !href.startsWith('blob:') &&
                            !href.startsWith('upload-placeholder:');
                        if (isPotentiallyRelative && isEditingBundleFile) {
                            githubPath = this.handleLocalLink(href, markdownFilePath, UserSettings.LOCAL_ASSET_SUBDIR);
                        } else if (href.startsWith('/') && !isEditingBundleFile && !isAssetStrategyLocal) {
                            githubPath = this.handleGlobalLink(href, markdownFilePath, UserSettings.GLOBAL_ROOT_DIR, UserSettings.GLOBAL_ASSET_SUBPATH);
                        }
                        if (githubPath) {
                            links.add(githubPath);
                        }
                    } catch (e) {
                    }
                }
                return links;
            },
            determineSaveTarget(isUpdate, newSlug, userEnteredPathValue, originalPath, currentDirectoryPath, userSettings) {
                let targetPath, targetFilename, isTargetLocalActual;
                const isConfigAssetStrategyLocal = userSettings.ASSET_STRATEGY === 'local';
                if (isUpdate) {
                    isTargetLocalActual = PathUtils.isAnyBundlePath(originalPath);
                    targetPath = PathUtils.normalizePath(originalPath);
                    targetFilename = PathUtils.getBasename(targetPath);
                } else {
                    isTargetLocalActual = isConfigAssetStrategyLocal;
                    const baseDirForLocal = PathUtils.joinPaths(currentDirectoryPath, newSlug);
                    if (isTargetLocalActual) {
                        let desiredFilename = PathUtils.getBasename(userEnteredPathValue).toLowerCase();
                        if (desiredFilename === 'index.md' || desiredFilename === '_index.md') {
                            targetFilename = desiredFilename;
                        } else {
                            targetFilename = 'index.md';
                        }
                        let dirPartFromUser = PathUtils.getDirname(userEnteredPathValue);
                        const finalBaseDir = (dirPartFromUser && dirPartFromUser !== '.' && dirPartFromUser !== '')
                            ? PathUtils.joinPaths(currentDirectoryPath, dirPartFromUser)
                            : baseDirForLocal;
                        targetPath = PathUtils.normalizePath(PathUtils.joinPaths(finalBaseDir, targetFilename));
                    } else {
                        targetFilename = `${newSlug}.md`;
                        targetPath = PathUtils.normalizePath(PathUtils.joinPaths(currentDirectoryPath, targetFilename));
                    }
                }
                return { targetPath, targetFilename, isTargetLocalActual };
            },
            async identifyResourcesToDelete(filePathToDelete, isBranchBundleIndexDelete, isLeafBundleIndexDelete, initialLinksSet, userSettings, gitHubService) {
                const allPathsToDelete = new Set();
                const addPathToDelete = (p) => { if (p) allPathsToDelete.add(PathUtils.normalizePath(p)); };
                if (isBranchBundleIndexDelete) {
                    UIManager.updateStatus(i18next.t('statusBar.identifyingBranchIndexResources', { filePath: filePathToDelete }), false, false, true);
                    addPathToDelete(filePathToDelete);
                    UIManager.updateStatus(i18next.t('statusBar.markedFileForDeletion', { filename: PathUtils.getBasename(filePathToDelete) }), false, false, true);
                    if (initialLinksSet?.size > 0) {
                        UIManager.updateStatus(i18next.t('statusBar.checkingAssocImages'), false, false, true);
                        let assetCount = 0;
                        initialLinksSet.forEach(assetPath => {
                            addPathToDelete(assetPath);
                            UIManager.updateStatus(i18next.t('statusBar.deletingUnusedImage', { image: PathUtils.getBasename(assetPath) }), false, false, true);
                            assetCount++;
                        });
                        UIManager.updateStatus(i18next.t('statusBar.imageCleanupSuccess', { count: assetCount }), false, assetCount > 0);
                    } else {
                        UIManager.updateStatus(i18next.t('statusBar.noInitialLinksFound'), false, false);
                    }
                } else if (isLeafBundleIndexDelete) {
                    const bundleDir = PathUtils.getDirname(filePathToDelete);
                    if (bundleDir) {
                        UIManager.updateStatus(i18next.t('statusBar.checkingBundleContents', { path: bundleDir }), false, false, true);
                        try {
                            const bundleContents = await gitHubService.getFolderContentsRecursive(bundleDir);
                            if (bundleContents?.length > 0) {
                                bundleContents.forEach(item => addPathToDelete(item.path));
                                UIManager.updateStatus(i18next.t('statusBar.bundleContentsIdentified', { count: bundleContents.length, path: bundleDir }), false, true);
                            } else if (bundleContents === null) {
                                this.handleGenericError(new Error("Folder not found"), i18next.t('statusBar.bundleContentsCheckFailed', { path: bundleDir, message: "Folder not found" }), "Delete Prep");
                                addPathToDelete(filePathToDelete);
                            } else {
                                UIManager.updateStatus(i18next.t('statusBar.bundleContentsIdentified', { count: 0, path: bundleDir }), false, true);
                                addPathToDelete(filePathToDelete);
                            }
                        } catch (error) {
                            this.handleGenericError(error, i18next.t('errors.bundleContentsCheckFailed', { path: bundleDir, message: error.message }), "Delete Prep");
                            throw new Error(i18next.t('errors.deleteBundleException', { path: bundleDir }));
                        }
                    }
                    addPathToDelete(filePathToDelete);
                } else {
                    addPathToDelete(filePathToDelete);
                    const unusedAssetPaths = await this.getFilesToDeleteBasedOnLinks(new Set(), initialLinksSet);
                    if (unusedAssetPaths.length > 0) {
                        UIManager.updateStatus(i18next.t('statusBar.cleaningImages', { count: unusedAssetPaths.length }), false, false, true);
                        unusedAssetPaths.forEach(p => {
                            addPathToDelete(p);
                            UIManager.updateStatus(i18next.t('statusBar.deletingUnusedImage', { image: PathUtils.getBasename(p) }), false, false, true);
                        });
                        UIManager.updateStatus(i18next.t('statusBar.imageCleanupSuccess', { count: unusedAssetPaths.length }), false, true);
                    } else {
                        UIManager.updateStatus(i18next.t('statusBar.noAssociatedAssetsFound'), false, false);
                    }
                    if (userSettings.ASSET_STRATEGY === 'global') {
                        const slugToDelete = PathUtils.getSlugFromFilename(filePathToDelete);
                        const baseBrowsePath = PathUtils.normalizePath(userSettings.BASE_BROWSE_PATH);
                        const contentDir = PathUtils.getDirname(filePathToDelete);
                        let contentRelativeDir = (contentDir.startsWith(baseBrowsePath + '/'))
                            ? contentDir.substring(baseBrowsePath.length + 1)
                            : (contentDir !== baseBrowsePath && contentDir !== '' ? contentDir : '');
                        const globalAssetDirPath = PathUtils.normalizePath(PathUtils.joinPaths(
                            userSettings.GLOBAL_ROOT_DIR,
                            userSettings.GLOBAL_ASSET_SUBPATH,
                            contentRelativeDir,
                            slugToDelete
                        ));
                        if (globalAssetDirPath) {
                            UIManager.updateStatus(i18next.t('statusBar.deletingLegacyDir', { path: globalAssetDirPath }), false, false, true);
                            try {
                                const globalContents = await gitHubService.getFolderContentsRecursive(globalAssetDirPath);
                                if (globalContents?.length > 0) {
                                    globalContents.forEach(item => addPathToDelete(item.path));
                                    UIManager.updateStatus(i18next.t('statusBar.legacyDirContentsIdentified', { count: globalContents.length, path: globalAssetDirPath }), false, true);
                                } else if (globalContents === null) {
                                    UIManager.updateStatus(i18next.t('statusBar.legacyAssetDirNotFound', { path: globalAssetDirPath }), false, false);
                                } else {
                                    UIManager.updateStatus(i18next.t('statusBar.legacyAssetDirEmpty', { path: globalAssetDirPath }), false, false);
                                }
                            } catch (globalError) {
                                this.handleGenericError(globalError, i18next.t('errors.legacyDirCheckFailed', { path: globalAssetDirPath, message: globalError.message }), "Global Asset Deletion Check");
                            }
                        }
                    }
                }
                return allPathsToDelete;
            },
            setupThemeHandling() {
                this.themeMediaQuery = window.matchMedia('(prefers-color-scheme: dark)');
                const applyTheme = (isDark) => {
                    document.body.classList.toggle('dark-mode', isDark);
                    if (VditorManager.instance && VditorManager.isReady) {
                        VditorManager.setTheme(isDark ? 'dark' : 'classic', isDark ? 'dark' : 'light');
                    }
                };
                applyTheme(this.themeMediaQuery.matches);
                this.themeMediaQuery.addEventListener('change', (e) => applyTheme(e.matches));
            },
            initializeVditor(initialValue = '') {
                VditorManager.init('fileContentInput', initialValue, this.themeMediaQuery, () => this.refreshEditorUIState())
                    .catch(error => this.handleGenericError(error, 'errors.vditorInitFailed', "Vditor Initialization"));
            },
            setupEventListeners() {
                this.elements.loginButton.addEventListener('click', () => this.handleLogin());
                this.elements.logoutButton.addEventListener('click', () => this.handleLogout());
                this.elements.repoSelect.addEventListener('change', () => {
                    this.elements.loadRepoButton.disabled = this.elements.repoSelect.value === '';
                });
                this.elements.loadRepoButton.addEventListener('click', () => this.loadSelectedRepo());
                this.elements.createNewFileButton.addEventListener('click', () => this.createNewFile());
                this.elements.saveDraftButton.addEventListener('click', () => this.saveFile('draft'));
                this.elements.publishButton.addEventListener('click', () => this.saveFile('publish'));
                this.elements.deleteFileButton.addEventListener('click', () => this.deleteFile());
                this.elements.cancelEditButton.addEventListener('click', () => this.cancelEdit());
                const editorInputHandler = () => this.refreshEditorUIState();
                this.elements.fmTitleInput.addEventListener('input', () => {
                    if (!AppState.currentFileSha) {
                        const title = this.elements.fmTitleInput.value;
                        const slug = PathUtils.generateFilename(title);
                        const isLocal = AppState.isCurrentOperationTargetingLocal();
                        const fullFilename = slug ? (isLocal ? `${slug}/index.md` : `${slug}.md`) : '';
                        this.elements.fileNameInput.value = fullFilename;
                        UIManager.setFilenameInputMode(isLocal);
                    }
                    this.updateGeneratedCommitMessage();
                    editorInputHandler();
                });
                this.elements.fileNameInput.addEventListener('input', () => {
                    this.updateGeneratedCommitMessage();
                    editorInputHandler();
                });
                this.elements.commitMessageInput.addEventListener('input', editorInputHandler);
                FM_FIELD_CONFIG.forEach(field => {
                    if (this.elements[field.elementId] && field.type !== 'datetime' && field.type !== 'array') {
                        this.elements[field.elementId].addEventListener('input', editorInputHandler);
                    }
                    if (this.elements[field.autoCheckboxId]) {
                        this.elements[field.autoCheckboxId].addEventListener('change', editorInputHandler);
                    }
                });
                this.elements.customFrontMatterContainer.addEventListener('input', (event) => {
                    if (event.target.matches('.custom-fm-key, .custom-fm-value')) {
                        editorInputHandler();
                    }
                });
                 this.elements.customFrontMatterContainer.addEventListener('change', (event) => {
                    if (event.target.matches('.custom-fm-type, .custom-fm-value[type="checkbox"]')) {
                        editorInputHandler();
                    }
                });
                if (this.elements.fileFilterInput) {
                    this.elements.fileFilterInput.addEventListener('input', this.handleFileFilter.bind(this));
                }
                if (this.elements.draftFilterCheckbox) {
                    this.elements.draftFilterCheckbox.addEventListener('change', this.handleFileFilter.bind(this));
                }
                window.addEventListener('storage', (event) => {
                    if (event.key === AppConstants.PAT_STORAGE_KEY && event.newValue === null && AppState.octokit) {
                        UIManager.updateStatus(i18next.t('statusBar.patChangedLogout'), false);
                        this.handleLogout();
                    }
                });
            },
            handleFileFilter() {
                if (!this.elements.fileFilterInput || !this.elements.draftFilterCheckbox || !this.elements.fileListUl || !this.elements.fileListEmptyMessage) return;
                const filterText = this.elements.fileFilterInput.value.toLowerCase().trim();
                const showOnlyDrafts = this.elements.draftFilterCheckbox.checked;
                const listItems = this.elements.fileListUl.querySelectorAll('li');
                let visibleCount = 0;
                let hasItemsOtherThanParent = false;
                listItems.forEach(li => {
                    const isParentLink = li.classList.contains('parent-dir');
                    const isErrorOrLoading = li.classList.contains('error') || li.querySelector('em.no-hover');
                    let shouldBeVisible = false;
                    if (!isParentLink && !isErrorOrLoading) {
                        hasItemsOtherThanParent = true;
                    }
                    if (isParentLink) {
                        shouldBeVisible = true;
                    } else if (isErrorOrLoading) {
                        shouldBeVisible = !showOnlyDrafts;
                    } else {
                        const itemName = (li.querySelector('.file-item-name')?.textContent || '').toLowerCase();
                        const isDraftItem = !!li.querySelector('.draft-indicator');
                        shouldBeVisible = (filterText === '' || itemName.includes(filterText)) &&
                            (!showOnlyDrafts || isDraftItem);
                    }
                    li.style.display = shouldBeVisible ? 'flex' : 'none';
                    if (shouldBeVisible && !isParentLink && !isErrorOrLoading) {
                        visibleCount++;
                    }
                });
                this.elements.fileListEmptyMessage.classList.toggle('hidden', !(
                    (filterText !== '' || showOnlyDrafts) &&
                    hasItemsOtherThanParent &&
                    visibleCount === 0
                ));
            },
            resetFileFilter() {
                if (this.elements.fileFilterInput) {
                    this.elements.fileFilterInput.value = '';
                }
                if (this.elements.draftFilterCheckbox) {
                    this.elements.draftFilterCheckbox.checked = false;
                }
                if (this.elements.fileListEmptyMessage) {
                    this.elements.fileListEmptyMessage.classList.add('hidden');
                }
                if (this.elements.fileListUl) {
                    this.elements.fileListUl.querySelectorAll('li').forEach(li => {
                        li.style.display = 'flex';
                    });
                }
            },
            async proceedAfterLogin() {
                UIManager.updateStatus(i18next.t('statusBar.authSuccess'), false, true);
                const storedRepo = localStorage.getItem(AppConstants.SELECTED_REPO_KEY);
                if (storedRepo && storedRepo.includes('/')) {
                    UIManager.updateStatus(i18next.t('statusBar.loadingStoredRepo', { repo: storedRepo }), false, false, true);
                    const [owner, repo] = storedRepo.split('/');
                    AppState.setRepo(owner, repo);
                    this.elements.currentBranchName.textContent = AppState.branch;
                    this.elements.currentRepoSpan.textContent = storedRepo;
                    UIManager.showSection('main');
                    try {
                        await this.loadDraftStatus();
                        if (AppState.urlActionPath) {
                            UIManager.updateStatus(i18next.t('statusBar.urlAction', { path: AppState.urlActionPath }), false, false, true);
                            await this.handleUrlAction(AppState.urlActionPath);
                        } else {
                            UIManager.updateStatus(i18next.t('statusBar.loadingRepo', { repo: storedRepo, path: UserSettings.BASE_BROWSE_PATH }), false, false, true);
                            await this.browsePath(UserSettings.BASE_BROWSE_PATH);
                        }
                        return;
                    } catch (error) {
                        this.handleGenericError(error, i18next.t('errors.storedRepoLoadFailed', { repo: storedRepo }), "Stored Repo Load");
                        localStorage.removeItem(AppConstants.SELECTED_REPO_KEY);
                        AppState.owner = null;
                        AppState.repo = null;
                        UIManager.showSection('repo');
                    }
                } else {
                    UIManager.updateStatus(i18next.t('statusBar.loadingRepoList'), false, false, true);
                    const repoResult = await GitHubService.listRepos();
                    if (repoResult.success) {
                        UIManager.populateRepoSelect(repoResult.repos);
                        UIManager.setLoginSuccess(true);
                        UIManager.showSection('repo');
                        UIManager.updateStatus(
                            repoResult.repos.length > 0
                                ? i18next.t('statusBar.repoLoaded', { count: repoResult.repos.length })
                                : i18next.t('errors.noAccessibleRepos'),
                            !repoResult.repos.length,
                            repoResult.repos.length > 0
                        );
                    } else {
                        this.handleApiError(repoResult.error, i18next.t('errors.repoListFailed'));
                        UIManager.setLoginSuccess(true);
                        UIManager.showSection('repo');
                    }
                }
                UIManager.setRepoLoading(false);
            },
            async handleLogin() {
                const token = this.elements.patInput.value.trim();
                if (!token) {
                    this.handleGenericError(null, 'errors.patRequired', "Login");
                    this.elements.patInput.focus();
                    return;
                }
                UIManager.setLoginLoading(true);
                UIManager.updateStatus(i18next.t('statusBar.authInProgress'), false, false, true);
                const authResult = await GitHubService.authenticate(token);
                if (authResult.success) {
                    UIManager.setLoginSuccess(true);
                    localStorage.setItem(AppConstants.PAT_STORAGE_KEY, token);
                    await this.proceedAfterLogin();
                } else {
                    localStorage.removeItem(AppConstants.PAT_STORAGE_KEY);
                    AppState.octokit = null;
                    this.handleApiError(authResult.error, i18next.t('errors.authFailed'));
                    UIManager.resetLoginScreen();
                    UIManager.setLoginLoading(false);
                }
            },
            async autoLogin(token) {
                UIManager.setLoginLoading(true);
                UIManager.updateStatus(i18next.t('statusBar.autoLoginInProgress'), false, false, true);
                this.elements.patInput.value = '********';
                const authResult = await GitHubService.authenticate(token);
                if (authResult.success) {
                    UIManager.setLoginSuccess(true);
                    await this.proceedAfterLogin();
                } else {
                    this.handleApiError(authResult.error, i18next.t('errors.authFailed'));
                    localStorage.removeItem(AppConstants.PAT_STORAGE_KEY);
                    UIManager.resetLoginScreen();
                    UIManager.updateStatus(i18next.t('statusBar.autoLoginFailed'), true);
                }
            },
            handleLogout() {
                this.setBaseTag(null);
                localStorage.removeItem(AppConstants.PAT_STORAGE_KEY);
                localStorage.removeItem(AppConstants.SELECTED_REPO_KEY);
                AppState.octokit = null;
                AppState.owner = null;
                AppState.repo = null;
                AppState.urlActionPath = null;
                UIManager.removeActiveFileHighlight();
                AppState.clearEditingFile();
                if (VditorManager.instance) {
                    VditorManager.destroy();
                }
                UIManager.resetLoginScreen();
                UIManager.updateStatus(i18next.t('statusBar.logout'), false, true);
                history.replaceState(null, '', location.pathname);
            },
            async loadSelectedRepo() {
                this.setBaseTag(null);
                UIManager.removeActiveFileHighlight();
                const selectedRepoFullName = this.elements.repoSelect.value;
                if (!selectedRepoFullName || !selectedRepoFullName.includes('/')) {
                    this.handleGenericError(null, 'errors.invalidRepo', "Load Repo");
                    return;
                }
                if (!AppState.octokit) {
                    this.handleLogout();
                    return;
                }
                const [owner, repo] = selectedRepoFullName.split('/');
                AppState.setRepo(owner, repo);
                this.elements.currentBranchName.textContent = AppState.branch;
                this.elements.currentRepoSpan.textContent = selectedRepoFullName;
                UIManager.setRepoLoading(true, selectedRepoFullName);
                localStorage.setItem(AppConstants.SELECTED_REPO_KEY, selectedRepoFullName);
                UIManager.showSection('main');
                await this.loadDraftStatus();
                if (AppState.urlActionPath) {
                    await this.handleUrlAction(AppState.urlActionPath);
                } else {
                    UIManager.updateStatus(i18next.t('statusBar.loadingRepo', { repo: selectedRepoFullName, path: UserSettings.BASE_BROWSE_PATH }), false, false, true);
                    await this.browsePath(UserSettings.BASE_BROWSE_PATH);
                }
            },
            async handleUrlAction(actionPath) {
                if (!AppState.owner || !AppState.repo) {
                    this.handleGenericError(null, 'errors.repoNotSet', "URL Action");
                    UIManager.showSection('repo');
                    UIManager.setRepoLoading(false);
                    return;
                }
                const normalizedActionPath = PathUtils.normalizePath(actionPath);
                const fullBasePath = PathUtils.normalizePath(UserSettings.BASE_BROWSE_PATH);
                UIManager.removeActiveFileHighlight();
                try {
                    if (normalizedActionPath === 'new' || normalizedActionPath.endsWith('/new')) {
                        let targetPath = fullBasePath;
                        if (normalizedActionPath !== 'new') {
                            targetPath = PathUtils.normalizePath(PathUtils.joinPaths(fullBasePath, PathUtils.getDirname(normalizedActionPath)));
                        }
                        UIManager.updateStatus(i18next.t('statusBar.urlActionNew', { path: targetPath }), false, true);
                        AppState.setCurrentPath(targetPath);
                        this.createNewFile();
                    } else {
                        UIManager.updateStatus(i18next.t('statusBar.searchingContent', { slug: normalizedActionPath }), false, false, true);
                        await this.findAndEditContentBySlug(normalizedActionPath);
                    }
                } catch (error) {
                    this.handleGenericError(error, i18next.t('errors.urlActionFailed'), "URL Action Handling");
                    await this.browsePath(AppState.currentPath || UserSettings.BASE_BROWSE_PATH);
                } finally {
                    AppState.urlActionPath = null;
                    history.replaceState(null, '', location.pathname);
                    UIManager.setRepoLoading(false);
                }
            },
            async findAndEditContentBySlug(baseSlug) {
                const fullBasePath = PathUtils.normalizePath(UserSettings.BASE_BROWSE_PATH);
                const normalizedSlug = PathUtils.normalizePath(baseSlug);
                const pathsToTry = [
                    PathUtils.joinPaths(fullBasePath, normalizedSlug, 'index.md'),
                    PathUtils.joinPaths(fullBasePath, normalizedSlug, '_index.md'),
                    PathUtils.joinPaths(fullBasePath, normalizedSlug + '.md')
                ];
                let foundFile = null;
                let fallbackPath = PathUtils.joinPaths(fullBasePath, normalizedSlug);
                if (!fallbackPath.startsWith(fullBasePath)) {
                    fallbackPath = fullBasePath;
                }
                for (const filePath of pathsToTry) {
                    const dirPath = PathUtils.getDirname(filePath);
                    UIManager.updateStatus(i18next.t('statusBar.searchAttempt', { path: filePath }), false, false, true);
                    const dirResult = await GitHubService.getContent(dirPath);
                    if (dirResult.success) {
                       if(PathUtils.normalizePath(dirPath) !== PathUtils.normalizePath(fallbackPath) && !fallbackPath.startsWith(PathUtils.normalizePath(dirPath))) {
                           fallbackPath = dirPath;
                       }
                       const fileInDir = dirResult.items.find(item => item.type === 'file' && PathUtils.normalizePath(item.path) === PathUtils.normalizePath(filePath));
                        if (fileInDir) {
                            foundFile = fileInDir;
                            break;
                        }
                    } else if (!dirResult.notFound) {
                        throw dirResult.error;
                    }
                }
                if (foundFile) {
                    UIManager.updateStatus(i18next.t('statusBar.fileFound', { filename: PathUtils.getBasename(foundFile.path) }), false, false, true);
                    await this.editFile(foundFile.path, foundFile.sha);
                } else {
                    UIManager.updateStatus(i18next.t('statusBar.contentNotFound', { slug: baseSlug }), true);
                    await this.browsePath(fallbackPath);
                }
            },
            async requestBrowseAction(targetPath) {
                 if (AppState.currentView === 'edit' && VditorManager.isReady) {
                    const processedFormData = await this.getProcessedEditorFormData();
                    if (AppState.isModified(processedFormData)) {
                        if (confirm(i18next.t('prompts.confirmCancel'))) {
                            UIManager.removeActiveFileHighlight();
                            await this.browsePath(targetPath);
                        } else {
                           UIManager.updateStatus(i18next.t('prompts.cancelAbort'));
                        }
                    } else {
                        UIManager.removeActiveFileHighlight();
                        await this.browsePath(targetPath);
                    }
                } else {
                    UIManager.removeActiveFileHighlight();
                    await this.browsePath(targetPath);
                }
            },
             async requestEditAction(filePath, fileSha) {
                 if (AppState.currentView === 'edit' && VditorManager.isReady) {
                     const processedFormData = await this.getProcessedEditorFormData();
                     if (AppState.isModified(processedFormData)) {
                         if (confirm(i18next.t('prompts.confirmCancel'))) {
                            UIManager.removeActiveFileHighlight();
                            await this.editFile(filePath, fileSha);
                        } else {
                            UIManager.updateStatus(i18next.t('prompts.cancelAbort'));
                        }
                    } else {
                        UIManager.removeActiveFileHighlight();
                        await this.editFile(filePath, fileSha);
                    }
                } else {
                    await this.editFile(filePath, fileSha);
                }
            },
            async refreshFileBrowserForPath(p) {
                if (!AppState.octokit) { this.handleLogout(); return; }
                let normalizedPath = PathUtils.normalizePath(p || UserSettings.BASE_BROWSE_PATH);
                const normalizedBasePath = PathUtils.normalizePath(UserSettings.BASE_BROWSE_PATH);
                if (normalizedPath !== normalizedBasePath && !normalizedPath.startsWith(normalizedBasePath + '/')) {
                    normalizedPath = normalizedBasePath;
                }
                AppState.setCurrentPath(normalizedPath);
                UIManager.updateBreadcrumb(normalizedPath);
                UIManager.setFileListLoading(true, normalizedPath);
                try {
                    const result = await GitHubService.getContent(normalizedPath);
                    UIManager.setFileListLoading(false, normalizedPath);
                    if (result.success) {
                        UIManager.renderFileList(result.items, normalizedPath);
                    } else {
                        const errorMsgKey = result.notFound ? 'browser.errorNotFound' : 'browser.errorLoading';
                        const errorMsg = i18next.t(errorMsgKey, { path: normalizedPath });
                        UIManager.renderFileList([], normalizedPath);
                        if (this.elements.fileListUl) {
                            this.elements.fileListUl.innerHTML += `<li class="error no-hover">❌ ${errorMsg}</li>`;
                        }
                    }
                } catch (error) {
                    UIManager.setFileListLoading(false, normalizedPath);
                    this.handleGenericError(error, i18next.t('errors.folderBrowseException', { path: normalizedPath }), "Refresh File Browser", { path: normalizedPath });
                    UIManager.renderFileList([], normalizedPath);
                    if (this.elements.fileListUl) {
                        this.elements.fileListUl.innerHTML += `<li class="error no-hover">❌ ${i18next.t('errors.browserErrorLoadingSevere')}</li>`;
                    }
                } finally {
                    App.updateNewFileButtonUI();
                    this.resetFileFilter();
                }
            },
            async browsePath(p) {
                if (!AppState.octokit) {
                    this.handleLogout();
                    return;
                }
                UIManager.setEditorSaving(false);
                UIManager.removeActiveFileHighlight();
                AppState.clearEditingFile();
                UIManager.setBrowseOnlyState();
                await this.refreshFileBrowserForPath(p);
                UIManager.updateStatus(i18next.t('statusBar.folderLoaded', { path: `${AppState.owner}/${AppState.repo}/${AppState.currentPath}` }), false, true);
                UIManager.setRepoLoading(false);
            },
            async editFile(filePath, fileSha) {
                if (!AppState.octokit) {
                    this.handleLogout();
                    return;
                }
                UIManager.removeActiveFileHighlight();
                AppState.clearEditingFile();
                UIManager.updateStatus(i18next.t('statusBar.loadingFile', { path: filePath }), false, false, true);
                this.elements.createNewFileButton.disabled = true;
                if (this.elements.fileListUl) {
                    this.elements.fileListUl.style.pointerEvents = 'none';
                    this.elements.fileListUl.style.opacity = 0.6;
                }
                UIManager.setEditorSaving(false);
                try {
                    const result = await GitHubService.getFileContent(filePath, fileSha);
                    if (result.success) {
                        await this.initializeEditorForFile(result);
                        UIManager.setEditState();
                        this.elements.createNewFileButton.disabled = false;
                        if (this.elements.fileListUl) {
                            this.elements.fileListUl.style.pointerEvents = 'auto';
                            this.elements.fileListUl.style.opacity = 1.0;
                        }
                        const fileDir = PathUtils.getDirname(filePath) || UserSettings.BASE_BROWSE_PATH;
                        await this.refreshFileBrowserForPath(fileDir);
                    } else {
                        this.handleApiError(result.error, i18next.t('errors.fileLoadFailed', { path: result.path }), { path: result.path, sha: result.sha });
                        UIManager.setBrowseOnlyState();
                        await this.browsePath(PathUtils.getDirname(filePath) || AppState.currentPath || UserSettings.BASE_BROWSE_PATH);
                        this.elements.createNewFileButton.disabled = false;
                        if (this.elements.fileListUl) {
                            this.elements.fileListUl.style.pointerEvents = 'auto';
                            this.elements.fileListUl.style.opacity = 1.0;
                        }
                    }
                } catch (error) {
                    this.elements.createNewFileButton.disabled = false;
                    if (this.elements.fileListUl) {
                        this.elements.fileListUl.style.pointerEvents = 'auto';
                        this.elements.fileListUl.style.opacity = 1.0;
                    }
                    this.handleGenericError(error, i18next.t('errors.fileEditPrepException', { path: filePath }), "Edit File Prep", { path: filePath });
                    UIManager.setBrowseOnlyState();
                    await this.browsePath(PathUtils.getDirname(filePath) || AppState.currentPath || UserSettings.BASE_BROWSE_PATH);
                } finally {
                    UIManager.setRepoLoading(false);
                }
            },
            async initializeEditorForFile(fileData) {
                const { path: filePath, sha: fileSha, frontMatter: parsedFrontMatter, body: rawBody, type: fmType } = fileData;
                AppState.clearDraftAssets();
                this.reverseDraftAssetMap = {};
                AppState.setCurrentPath(PathUtils.normalizePath(PathUtils.getDirname(filePath) || UserSettings.BASE_BROWSE_PATH));
                let currentBodyForEditor = rawBody;
                if (PathUtils.isAnyBundlePath(filePath)) {
                    const isDraftBundle = AppState.isDraft(filePath);
                    if (isDraftBundle && UserSettings.ASSET_STRATEGY === 'local') {
                        this.setBaseTag(null);
                        const assetRelativePaths = new Set();
                        const mdLinkRegex = /(!?\[[^\]]*\]\()(?!(?:[a-z]+:|\/|#|blob:))([^")\s]+)((?:["'](?:[^"']*)["'])?\))/g;
                        let match;
                        while ((match = mdLinkRegex.exec(rawBody)) !== null) {
                            if (match[2]) {
                                const cleanRelativePath = match[2].split(/[?#]/)[0];
                                assetRelativePaths.add(cleanRelativePath);
                            }
                        }
                        for (const relativeAssetPath of assetRelativePaths) {
                            const fullAssetPathInRepo = PathUtils.joinPaths(PathUtils.getDirname(filePath), relativeAssetPath);
                            try {
                                const assetContentResult = await GitHubService.getRawAssetContent(fullAssetPathInRepo);
                                if (assetContentResult.success && assetContentResult.content) {
                                    const mimeType = PathUtils.getMimeTypeFromPath(fullAssetPathInRepo);
                                    const assetBlob = Utils.base64ToBlob(assetContentResult.content, mimeType);
                                    const blobUrl = URL.createObjectURL(assetBlob);
                                    AppState.draftAssets[relativeAssetPath] = blobUrl;
                                    this.reverseDraftAssetMap[blobUrl] = relativeAssetPath;
                                }
                            } catch (assetError) {
                            this.handleGenericError(assetError, `Failed to load draft asset: ${relativeAssetPath}`, "Draft Asset Load");
                            }
                        }
                        if (UserSettings.VDITOR_EDIT_MODE === 'ir' || UserSettings.VDITOR_EDIT_MODE === 'wysiwyg') {
                        currentBodyForEditor = this.replaceRelativePathsWithDraftAssetBlobs(rawBody);
                        }
                    } else if (!isDraftBundle) {
                        try {
                            const mapKey = PathUtils.getMapKeyFromFilePath(filePath);
                            let webPathForBase = (window.hugoPermalinkMap && typeof window.hugoPermalinkMap === 'object' && window.hugoPermalinkMap.hasOwnProperty(mapKey))
                                ? ('/' + PathUtils.normalizePath(window.hugoPermalinkMap[mapKey]) + '/').replace(/\/+/g, '/')
                                : PathUtils.calculateBaseTagPath(filePath);
                            this.setBaseTag(new URL(webPathForBase, window.location.origin).href);
                        } catch (e) {
                            this.handleGenericError(e, "Error setting base href", "Base Tag", { filePath });
                            this.setBaseTag(null);
                        }
                    } else {
                        this.setBaseTag(null);
                    }
                } else {
                    this.setBaseTag(null);
                }
                try {
                    if (!VditorManager.instance) {
                        await VditorManager.init('fileContentInput', currentBodyForEditor, this.themeMediaQuery, () => this.refreshEditorUIState());
                    } else {
                        await VditorManager.setValue(currentBodyForEditor);
                    }
                    await VditorManager.awaitReady();
                } catch (initError) {
                    this.handleGenericError(initError, 'errors.vditorInitFailed', "Vditor Init (Edit)");
                    await this.browsePath(PathUtils.getDirname(filePath) || AppState.currentPath || UserSettings.BASE_BROWSE_PATH);
                    return;
                }
                const initialDraftStateFromFM = parsedFrontMatter.draft === true;
                const initialHasLastmodFromFM = parsedFrontMatter.hasOwnProperty('lastmod') && parsedFrontMatter.lastmod != null && String(parsedFrontMatter.lastmod).trim() !== '';
                await UIManager.populateEditor(filePath, parsedFrontMatter, fmType, initialDraftStateFromFM, initialHasLastmodFromFM);
                const initialVditorBodyContent = await VditorManager.getValue();
                const initialLinks = this.parseManagedUploadLinks(this.restoreBlobURLsToRelativePathsInBody(initialVditorBodyContent), filePath);
                const initialFmDataForState = this.prepareInitialFmDataForState(parsedFrontMatter);
                AppState.setEditingFile(filePath, fileSha, initialFmDataForState, rawBody, initialLinks, initialDraftStateFromFM, initialHasLastmodFromFM);
                UIManager.setFilenameInputMode(AppState.isEditingAnyBundle);
                this.elements.fileNameInput.disabled = true;
                this.elements.fileNameInput.title = i18next.t('editor.fm.fileNameDisabledTooltip');
                this.updateGeneratedCommitMessage();
                await this.refreshEditorUIState();
                let fmInfoKey = fmType === 'yaml' ? 'statusBar.fmInfoYAML'
                            : fmType === 'toml' ? 'statusBar.fmInfoTOML'
                            : (fmType === 'none' ? 'statusBar.fmInfoNone' : '');
                UIManager.updateStatus(i18next.t(
                    fmType === 'error' ? 'statusBar.fileLoadedWithError' : 'statusBar.fileLoaded',
                    { path: filePath, fmInfo: fmInfoKey ? i18next.t(fmInfoKey) : '' }
                ), fmType === 'error', true);
                VditorManager.focus();
            },
            prepareInitialFmDataForState(parsedFrontMatter) {
                const initialFmData = { custom: {} };
                FM_FIELD_CONFIG.forEach(field => {
                    const value = parsedFrontMatter[field.key];
                    if (field.type === 'datetime') {
                        let dateString = '';
                        if (value) {
                            try {
                                let dateInput = (typeof value === 'number') ? new Date(value) : value;
                                let parsedDate = (dateInput instanceof Date)
                                    ? dateInput
                                    : (flatpickr.parseDate(String(dateInput), "Z") || flatpickr.parseDate(String(dateInput), "Y-m-d H:i:S") || flatpickr.parseDate(String(dateInput), "Y-m-d H:i") || flatpickr.parseDate(String(dateInput), "Y-m-d") || new Date(dateInput));
                                if (parsedDate && !isNaN(parsedDate.getTime())) {
                                    dateString = flatpickr.formatDate(parsedDate, "Y-m-d H:i");
                                } else {
                                    dateString = String(value);
                                }
                            } catch (e) { dateString = String(value); }
                        }
                        initialFmData[field.key] = dateString;
                    } else if (field.type === 'array') {
                        initialFmData[field.key] = (Array.isArray(value) ? value.map(String) : (value ? String(value).split(',').map(t => t.trim()) : []))
                            .filter(t => t)
                            .sort();
                    } else {
                        initialFmData[field.key] = value || '';
                    }
                });
                const standardKeysLower = AppConstants.STANDARD_FM_KEYS.map(k => k.toLowerCase());
                for (const key in parsedFrontMatter) {
                    if (Object.hasOwnProperty.call(parsedFrontMatter, key) && !standardKeysLower.includes(key.toLowerCase())) {
                        let val = parsedFrontMatter[key];
                        if (Array.isArray(val)) {
                            initialFmData.custom[key] = val.map(String).filter(Boolean).sort();
                        } else {
                            initialFmData.custom[key] = val;
                        }
                    }
                }
                initialFmData.draft = parsedFrontMatter.draft === true;
                return initialFmData;
            },
            async createNewFile() {
                if (!AppState.octokit) {
                    this.handleLogout();
                    return;
                }
                AppState.clearDraftAssets();
                this.reverseDraftAssetMap = {};
                UIManager.removeActiveFileHighlight();
                this.elements.createNewFileButton.disabled = true;
                const isLocalMode = AppState.isCurrentOperationTargetingLocal();
                UIManager.setFilenameInputMode(isLocalMode);
                this.elements.fileNameInput.disabled = false;
                this.elements.fileNameInput.title = '';
                this.setBaseTag(null);
                UIManager.updateStatus(i18next.t(
                    isLocalMode ? 'statusBar.newFileCreationReadyBundle' : 'statusBar.newFileCreationReady',
                    { path: AppState.currentPath }
                ), false, false, true);
                UIManager.setEditState();
                UIManager.clearEditorFields(true);
                UIManager.initDateField(UIManager.elements.fmDateInput, 'date', '', true, true);
                UIManager.elements.fmLastmodContainer.classList.add('hidden');
                UIManager.initDateField(UIManager.elements.fmLastmodInput, 'lastmod', '', true, true);
                ['fmTagsInput', 'fmCategoriesInput'].forEach(elId => {
                    const inputEl = UIManager.elements[elId];
                    if (inputEl) UIManager.manageTagifyInstance(inputEl, true, '');
                });
                AppState.initialDraftState = false;
                AppState.initialHasLastmod = false;
                try {
                    if (!VditorManager.instance) {
                        await VditorManager.init('fileContentInput', ' ', this.themeMediaQuery, () => this.refreshEditorUIState());
                    } else {
                        await VditorManager.setValue(' ');
                    }
                    await VditorManager.awaitReady();
                    UIManager.setEditorButtonLabels(false, false);
                    this.updateGeneratedCommitMessage();
                    this.refreshEditorUIState();
                    UIManager.setEditorSaving(false);
                    try {
                        this.elements.fmTitleInput.focus();
                    } catch(e) {
                        this.handleGenericError(e, 'errors.titleFocus', "Create New File Focus");
                    }
                    await this.refreshFileBrowserForPath(AppState.currentPath);
                } catch (error) {
                    UIManager.setEditorSaving(false);
                    this.handleGenericError(error, 'errors.vditorInitFailed', "Vditor Init (New)");
                    await this.browsePath(AppState.currentPath || UserSettings.BASE_BROWSE_PATH);
                }
            },
            async getProcessedEditorFormData() {
                const rawData = UIManager.getRawEditorFormData();
                const processedData = {
                    custom: [],
                    commitMessage: rawData.commitMessage,
                    fullPathValue: rawData.fullPathValue,
                    date: rawData.date,
                    dateAutoChecked: rawData.dateAutoChecked,
                    lastmod: rawData.lastmod,
                    lastmodAutoChecked: rawData.lastmodAutoChecked,
                    title: rawData.title,
                    author: rawData.author,
                    description: rawData.description,
                    tags: rawData.tags,
                    categories: rawData.categories
                };
                rawData.custom.forEach(customItem => {
                    if (customItem.type === 'array') {
                        processedData.custom.push({
                            ...customItem,
                            value: Array.isArray(customItem.value) ? [...customItem.value] : []
                        });
                    } else {
                        processedData.custom.push(customItem);
                    }
                });
                try {
                    processedData.body = await VditorManager.getValue();
                } catch (e) {
                    this.handleGenericError(e, "Failed to get Vditor content", "Get Form Data");
                    processedData.body = AppState.initialBodyContent;
                }
                const fullPath = rawData.fullPathValue;
                if (PathUtils.isAnyBundlePath(fullPath)) {
                     processedData.slugOrFilename = PathUtils.getSlugFromFilename(fullPath);
                 } else if (fullPath.toLowerCase().endsWith('.md')) {
                    processedData.slugOrFilename = fullPath.substring(0, fullPath.lastIndexOf('.')).split('/').pop();
                } else {
                    processedData.slugOrFilename = fullPath.split('/').pop();
                }
                return processedData;
            },
            updateGeneratedCommitMessage() {
                const rawData = UIManager.getRawEditorFormData();
                const isUpdate = !!AppState.currentFileSha;
                let displayPath = rawData.fullPathValue;
                if (!displayPath && rawData.title) {
                    const slug = PathUtils.generateFilename(Array.isArray(rawData.title) ? rawData.title[0] : rawData.title);
                    displayPath = AppState.isCurrentOperationTargetingLocal()
                        ? `${slug}/index.md`
                        : `${slug}.md`;
                }
                const commitKey = displayPath ? (isUpdate ? 'commit.update' : 'commit.create') : '';
                const msg = commitKey ? i18next.t(commitKey, { path: displayPath }) : '';
                UIManager.setCommitMessage(msg, msg
                    ? `${i18next.t('editor.commitMessagePlaceholder')} (e.g., ${msg})`
                    : i18next.t('editor.commitMessagePlaceholder')
                );
            },
            async refreshEditorUIState() {
                requestAnimationFrame(async () => {
                    const dateInputElement = UIManager.elements.fmDateInput;
                    const dateCheckboxElement = UIManager.elements.fmDateAutoCheckbox;
                    const lastmodInputElement = UIManager.elements.fmLastmodInput;
                    const lastmodCheckboxElement = UIManager.elements.fmLastmodAutoCheckbox;
                    if (dateInputElement && dateCheckboxElement) {
                        const shouldBeDisabled = dateCheckboxElement.checked;
                        if (dateInputElement.disabled !== shouldBeDisabled) {
                            dateInputElement.disabled = shouldBeDisabled;
                        }
                        const dateLabelElement = UIManager.elements.fmDateAutoLabel;
                        if (dateLabelElement) {
                            dateLabelElement.textContent = dateCheckboxElement.checked ? i18next.t('editor.fm.autoSetToNow') : i18next.t('editor.fm.manualInput');
                        }
                    }
                    if (lastmodInputElement && lastmodCheckboxElement && !UIManager.elements.fmLastmodContainer.classList.contains('hidden')) {
                        const shouldBeDisabled = lastmodCheckboxElement.checked;
                        if (lastmodInputElement.disabled !== shouldBeDisabled) {
                            lastmodInputElement.disabled = shouldBeDisabled;
                        }
                        const lastmodLabelElement = UIManager.elements.fmLastmodAutoLabel;
                        if (lastmodLabelElement) {
                            lastmodLabelElement.textContent = lastmodCheckboxElement.checked ? i18next.t('editor.fm.autoSetToNow') : i18next.t('editor.fm.manualInput');
                        }
                    }
                    if (!document.getElementById('fileContentInput') || !VditorManager.isReady) {
                        UIManager.setEditorActionButtonsState(false, false, !!AppState.currentFileSha, true);
                        return;
                    }
                    const formData = await this.getProcessedEditorFormData();
                    const isEditing = !!AppState.currentFileSha;
                    const hasChanges = AppState.isModified(formData);
                    let canSaveDraft, canPublish;
                    if (isEditing) {
                        canSaveDraft = AppState.initialDraftState ? hasChanges : true;
                        canPublish = AppState.initialDraftState ? true : hasChanges;
                    } else {
                        const hasRequiredFields = !!formData.title && !!formData.fullPathValue;
                        canSaveDraft = hasRequiredFields;
                        canPublish = hasRequiredFields;
                    }
                    UIManager.setEditorActionButtonsState(canSaveDraft, canPublish, isEditing, true );
                });
            },
            updateNewFileButtonUI() {
                const dirName = PathUtils.getBasename(AppState.currentPath) || UserSettings.BASE_BROWSE_PATH;
                const text = i18next.t('browser.newFileButtonInFolder', { dirName });
                let title = '', hidden = false, disabled = false;
                const isBrowserVisible = UIManager.elements.fileBrowserSection && !UIManager.elements.fileBrowserSection.classList.contains('hidden');
                const isEditing = AppState.currentView === 'edit';
                const isFileListLoading = UIManager.elements.fileListUl?.querySelector('em.no-hover');
                hidden = (isEditing && !window.matchMedia("(max-width: 63.999rem)").matches) || !!isFileListLoading;
                disabled = hidden;
                if (!hidden && UIManager.elements.fileListUl) {
                    const isLeafBundle = Array.from(UIManager.elements.fileListUl.querySelectorAll('li.file'))
                        .some(li => li.dataset.path && PathUtils.isPageBundlePath(li.dataset.path));
                    if (isLeafBundle && UserSettings.ASSET_STRATEGY === 'local') {
                         hidden = true;
                         disabled = true;
                         title = i18next.t('browser.newFileButtonDisabledLeafBundleTooltip');
                    }
                }
                UIManager.setNewFileButtonUI(text, title, hidden, disabled);
            },
            replaceRelativePathsWithDraftAssetBlobs(markdownContent) {
                if (!markdownContent || Object.keys(AppState.draftAssets).length === 0) {
                    return markdownContent;
                }
                let newContent = markdownContent;
                const mdLinkRegex = /(!?\[[^\]]*\]\()(?!(?:[a-z]+:|\/|#|blob:))([^")\s]+)((?:["'](?:[^"']*)["'])?\))/g;
                newContent = newContent.replace(mdLinkRegex, (match, prefix, relativePath, suffix) => {
                    const cleanRelativePath = relativePath.split(/[?#]/)[0];
                    const blobUrl = AppState.draftAssets[cleanRelativePath];
                    if (blobUrl) {
                        const fragment = relativePath.substring(cleanRelativePath.length);
                        const replacement = `${prefix}${blobUrl}${fragment}${suffix}`;
                        return replacement;
                    }
                    return match;
                });
                return newContent;
            },
            restoreBlobURLsToRelativePathsInBody(markdownContent) {
                if (!markdownContent || Object.keys(this.reverseDraftAssetMap).length === 0) {
                    return markdownContent;
                }
                let newContent = markdownContent;
                for (const blobUrl in this.reverseDraftAssetMap) {
                    if (Object.hasOwnProperty.call(this.reverseDraftAssetMap, blobUrl)) {
                        const relativePath = this.reverseDraftAssetMap[blobUrl];
                        const escapedBlobUrl = PathUtils.escapeRegex(blobUrl);
                        const regex = new RegExp(`(!?\\[[^\\]]*\\]\\()${escapedBlobUrl}([^)]*)(\\))`, 'g');
                        newContent = newContent.replace(regex, (match, prefix, fragment, suffix) => {
                            const replacement = `${prefix}${relativePath}${fragment}${suffix}`;
                            return replacement;
                        });
                    }
                }
                return newContent;
            },
            async prepareUploads(markdownBody, postSlug, markdownDirPath, isTargetLocalActual) {
                const uploadsToCommit = [];
                let updatedBody = markdownBody;
                const markdownLinkRegex = /(!?\[[^\]]*?\]\()((?:upload-placeholder:)?blob:http[^)]+)\)/g;
                const matches = Array.from(markdownBody.matchAll(markdownLinkRegex));
                if (matches.length === 0) {
                    return { updatedBody: markdownBody, uploadsToCommit };
                }
                UIManager.updateStatus(i18next.t('statusBar.uploadingImages', { count: matches.length }), false, false, true);
                const processedPendingKeys = new Set();
                for (const match of matches) {
                    const markdownPrefix = match[1];
                    const originalUrlInMarkdown = match[2];
                    const isPlaceholder = originalUrlInMarkdown.startsWith('upload-placeholder:');
                    const blobPart = isPlaceholder ? originalUrlInMarkdown.substring('upload-placeholder:'.length) : originalUrlInMarkdown;
                    const keyForPendingUploads = Utils.cleanUrl(blobPart);
                    const fileObject = AppState.pendingUploads[keyForPendingUploads];
                    if (!fileObject) {
                        continue;
                    }
                    let finalPathForMarkdownDisplay;
                    if (!processedPendingKeys.has(keyForPendingUploads)) {
                        UIManager.updateStatus(i18next.t('statusBar.uploadingImage', { filename: fileObject.name }), false, false, true);
                        try {
                            const sanitizedFullName = PathUtils.sanitizeFilename(fileObject.name);
                            const ext = path.extname(sanitizedFullName);
                            const baseNameOnly = path.basename(sanitizedFullName, ext);
                            const unixTimestampInMilliseconds = Date.now();
                            const uniqueFilename = `${unixTimestampInMilliseconds}.${baseNameOnly}${ext}`;
                            let githubFilePath;
                            if (isTargetLocalActual) {
                                const normalizedLocalAssetSubdir = PathUtils.normalizePath(UserSettings.LOCAL_ASSET_SUBDIR);
                                githubFilePath = PathUtils.joinPaths(markdownDirPath, normalizedLocalAssetSubdir, uniqueFilename);
                                finalPathForMarkdownDisplay = PathUtils.joinPaths(normalizedLocalAssetSubdir, uniqueFilename);
                            } else {
                                const normalizedGlobalRootDir = PathUtils.normalizePath(UserSettings.GLOBAL_ROOT_DIR);
                                const normalizedGlobalAssetSubpath = PathUtils.normalizePath(UserSettings.GLOBAL_ASSET_SUBPATH);
                                const baseBrowsePath = PathUtils.normalizePath(UserSettings.BASE_BROWSE_PATH);
                                const normalizedMarkdownDir = PathUtils.normalizePath(markdownDirPath);
                                let subFolderPath = (normalizedMarkdownDir.startsWith(baseBrowsePath + '/') && normalizedMarkdownDir.length > baseBrowsePath.length && normalizedMarkdownDir !== baseBrowsePath)
                                    ? normalizedMarkdownDir.substring(baseBrowsePath.length + 1)
                                    : (normalizedMarkdownDir === baseBrowsePath ? '' : normalizedMarkdownDir) ;
                                githubFilePath = PathUtils.normalizePath(PathUtils.joinPaths(
                                    normalizedGlobalRootDir,
                                    normalizedGlobalAssetSubpath,
                                    subFolderPath,
                                    postSlug,
                                    uniqueFilename
                                ));
                                finalPathForMarkdownDisplay = '/' + PathUtils.normalizePath(PathUtils.joinPaths(
                                    UserSettings.OMIT_GLOBAL_ROOT_DIR_FROM_URL ? '' : normalizedGlobalRootDir,
                                    normalizedGlobalAssetSubpath,
                                    subFolderPath,
                                    postSlug,
                                    uniqueFilename
                                )).replace(/\/\/+/g, '/');
                            }
                            const base64Content = await Utils.readFileAsBase64(fileObject);
                            uploadsToCommit.push({
                                path: githubFilePath,
                                content: base64Content,
                                encoding: 'base64'
                            });
                            processedPendingKeys.add(keyForPendingUploads);
                            fileObject.finalPath = finalPathForMarkdownDisplay;
                        } catch (error) {
                            this.handleGenericError(error, i18next.t('errors.imageUploadFailed', { filename: fileObject.name, message: error.message || 'Unknown' }), "Upload Prep");
                            throw new Error(i18next.t('errors.imageUploadFailedGenericWithMessage', { message: error.message || 'Unknown' }));
                        }
                    } else {
                        finalPathForMarkdownDisplay = fileObject.finalPath;
                    }
                    if (typeof finalPathForMarkdownDisplay === 'undefined') {
                        continue;
                    }
                    let finalLinkContentForMarkdown;
                    if (!isPlaceholder) {
                        const fragment = blobPart.substring(keyForPendingUploads.length);
                        finalLinkContentForMarkdown = finalPathForMarkdownDisplay + fragment;
                    } else {
                        finalLinkContentForMarkdown = finalPathForMarkdownDisplay;
                    }
                    const replacementRegex = new RegExp(PathUtils.escapeRegex(originalUrlInMarkdown), 'g');
                    updatedBody = updatedBody.replace(replacementRegex, finalLinkContentForMarkdown);
                }
                for (const key in AppState.pendingUploads) {
                    if (AppState.pendingUploads[key].finalPath) {
                        delete AppState.pendingUploads[key].finalPath;
                    }
                }
                UIManager.updateStatus(i18next.t('statusBar.uploadComplete', { count: uploadsToCommit.length }), false, true);
                return { updatedBody, uploadsToCommit };
            },
            async getFilesToDeleteBasedOnLinks(currentLinksSet, initialLinksSet) {
                if (!initialLinksSet || initialLinksSet.size === 0) {
                    return [];
                }
                return Array.from(initialLinksSet).filter(initialLinkPath => !currentLinksSet.has(initialLinkPath));
            },
            async executeCommit(commitMessage, filesToCommit, filesToDeletePaths) {
                try {
                     UIManager.updateStatus(i18next.t('statusBar.creatingBlobs', { count: filesToCommit.length }), false, false, true);
                     const blobResults = await Promise.all(filesToCommit.map(async file => {
                        const result = await GitHubService.createBlob(file.content, file.encoding || 'utf-8');
                        if (!result.success) throw result.error;
                        return { path: file.path, sha: result.sha, mode: '100644', type: 'blob' };
                    }));
                    UIManager.updateStatus(i18next.t('statusBar.creatingTree'), false, false, true);
                    const refResult = await GitHubService.getRef();
                    if (!refResult.success) throw refResult.error;
                    const commitResult = await GitHubService.getCommit(refResult.sha);
                    if (!commitResult.success) throw commitResult.error;
                    const treeDefinition = blobResults.map(b => ({
                        path: b.path, mode: b.mode, type: b.type, sha: b.sha
                    }));
                    filesToDeletePaths.forEach(p => treeDefinition.push({
                        path: p, mode: '100644', type: 'blob', sha: null
                    }));
                    const treeResult = await GitHubService.createTree(commitResult.treeSha, treeDefinition);
                    if (!treeResult.success) throw treeResult.error;
                    UIManager.updateStatus(i18next.t('statusBar.creatingCommit'), false, false, true);
                    const newCommitResult = await GitHubService.createCommit(treeResult.sha, refResult.sha, commitMessage);
                    if (!newCommitResult.success) throw newCommitResult.error;
                    UIManager.updateStatus(i18next.t('statusBar.updatingRef'), false, false, true);
                    const updateRefResult = await GitHubService.updateRef(newCommitResult.sha);
                    if (!updateRefResult.success) throw updateRefResult.error;
                    return { success: true, commitSha: newCommitResult.sha };
                } catch (error) {
                    let step = 'Unknown';
                    if (error.message?.includes('Blob')) step = 'Blob Creation';
                    else if (error.message?.includes('Ref')) step = 'Get/Update Reference';
                    else if (error.message?.includes('Commit')) step = 'Get/Create Commit';
                    else if (error.message?.includes('Tree')) step = 'Tree Creation';
                    this.handleApiError(error, i18next.t('errors.commitFailed', { step: step }), { step });
                    return { success: false, error, step };
                }
            },
            validateSaveInputs(formData) {
                if (!formData.title) {
                    this.handleGenericError(null, 'errors.titleRequired', "Save Validation");
                    this.elements.fmTitleInput.focus();
                    return false;
                }
                if (!formData.fullPathValue ||
                    (!formData.fullPathValue.endsWith('.md') && !PathUtils.isAnyBundlePath(formData.fullPathValue)) ||
                    (PathUtils.isAnyBundlePath(formData.fullPathValue) && !formData.slugOrFilename) ||
                    formData.fullPathValue.includes('//') ||
                    formData.fullPathValue.startsWith('/')
                ) {
                    this.handleGenericError(null, 'errors.invalidFilename', "Save Validation");
                    this.elements.fileNameInput.focus();
                    return false;
                }
                if (!formData.commitMessage) {
                    this.handleGenericError(null, 'errors.commitMsgRequired', "Save Validation");
                    this.elements.commitMessageInput.focus();
                    return false;
                }
                const customKeyInputs = this.elements.customFrontMatterContainer.querySelectorAll('.custom-fm-key');
                const standardKeysLower = AppConstants.STANDARD_FM_KEYS.map(k => k.toLowerCase());
                const seenKeys = new Set();
                for (const keyInput of customKeyInputs) {
                    const key = keyInput.value.trim();
                    const keyLower = key.toLowerCase();
                    if (!key) continue;
                    if (standardKeysLower.includes(keyLower)) {
                        this.handleGenericError(null, i18next.t('errors.customKeyConflictSaveBlock', { key: key }), "Custom Field Validation");
                        keyInput.focus();
                        return false;
                    }
                    if (seenKeys.has(keyLower)) {
                        this.handleGenericError(null, i18next.t('errors.customKeyDuplicate', { key: key }), "Custom Field Validation");
                        keyInput.focus();
                        return false;
                    }
                    seenKeys.add(keyLower);
                }
                for (const customField of formData.custom) {
                    const { key, value, type } = customField;
                    if (type === 'number') {
                        if (String(value).trim() !== '' && isNaN(parseFloat(String(value)))) {
                            this.handleGenericError(null, i18next.t('errors.invalidCustomFieldType', { key: key }), "Save Validation");
                            const row = Array.from(customKeyInputs).find(k => k.value.trim() === key)?.closest('.custom-fm-row');
                            row?.querySelector('.custom-fm-value')?.focus();
                            return false;
                        }
                    } else if (type === 'date') {
                         if (String(value).trim() !== '' && isNaN(new Date(String(value).replace(' ', 'T')).getTime()) && !flatpickr.parseDate(String(value), "Y-m-d H:i:S")) {
                            this.handleGenericError(null, i18next.t('errors.invalidCustomFieldType', { key: key }), "Save Validation");
                            const row = Array.from(customKeyInputs).find(k => k.value.trim() === key)?.closest('.custom-fm-row');
                            row?.querySelector('.custom-fm-value')?.focus();
                            return false;
                        }
                    }
                }
                return true;
            },
            getValidatedDateISO(dateStr, isAutoChecked, originalDateStrIfManualAndUnchanged, fieldName = "Date") {
                let dateToProcess;
                if (isAutoChecked) {
                    dateToProcess = new Date();
                } else {
                    if (String(dateStr || '').trim() === '' && originalDateStrIfManualAndUnchanged) {
                        dateStr = originalDateStrIfManualAndUnchanged;
                    }
                    if (String(dateStr || '').trim() === '') {
                        this.handleGenericError(null, 'errors.invalidDate', `${fieldName} Validation (Empty)`);
                        return null;
                    }
                    try {
                        const parsedDate = flatpickr.parseDate(dateStr, "Y-m-d H:i") || new Date(dateStr.replace(' ', 'T'));
                        if (!parsedDate || isNaN(parsedDate.getTime())) {
                            throw new Error("Invalid date format from input");
                        }
                        dateToProcess = parsedDate;
                    } catch (e) {
                        this.handleGenericError(e, 'errors.invalidDate', `${fieldName} Validation (Format)`);
                        return null;
                    }
                }
                dateToProcess.setSeconds(0, 0);
                return dateToProcess.toISOString();
            },
            prepareFrontMatterForSave(formData, saveType, isUpdate) {
                const frontMatterData = { custom: {} };
                let dateValueISO, lastmodValueISO;
                const originalDateValue = AppState.currentFileSha ? AppState.initialFmData.date : null;
                const originalLastmodValue = AppState.currentFileSha ? AppState.initialFmData.lastmod : null;
                dateValueISO = this.getValidatedDateISO(formData.date, formData.dateAutoChecked, originalDateValue, "Date");
                if (!dateValueISO) return null;
                frontMatterData.date = dateValueISO;
                if (formData.dateAutoChecked && saveType !== 'draft') {
                    UIManager.updateStatus(i18next.t('statusBar.dateSetToNow'), false);
                }
                if (isUpdate) {
                    let shouldProcessLastmod = false;
                    if (AppState.initialDraftState) {
                        if (AppState.initialHasLastmod) {
                            shouldProcessLastmod = true;
                        }
                        if (!formData.lastmodAutoChecked || String(formData.lastmod).trim() !== '') {
                           shouldProcessLastmod = true;
                        }
                    } else {
                        shouldProcessLastmod = true;
                    }
                    if (shouldProcessLastmod) {
                        const isLastmodManuallySet = formData.lastmodAutoChecked === false;
                        const lastmodInputStr = String(formData.lastmod).trim();
                        if (isLastmodManuallySet && lastmodInputStr === '') {
                            this.handleGenericError(null, 'errors.invalidDate', "Lastmod Validation (Explicitly Cleared)");
                            return null;
                        }
                        lastmodValueISO = this.getValidatedDateISO(formData.lastmod, formData.lastmodAutoChecked, originalLastmodValue, "Lastmod");
                        if (!lastmodValueISO) {
                            return null;
                        }
                        const dateObj = new Date(dateValueISO);
                        const lastmodObj = new Date(lastmodValueISO);
                        if (lastmodObj < dateObj) {
                            this.handleGenericError(null, 'errors.lastmodBeforeDate', "Date Validation (Lastmod < Date)");
                            return null;
                        }
                        frontMatterData.lastmod = lastmodValueISO;
                        if (formData.lastmodAutoChecked && saveType !== 'draft') {
                             UIManager.updateStatus(i18next.t('statusBar.dateSetToNow'), false);
                        }
                    }
                }
                FM_FIELD_CONFIG.forEach(field => {
                    if (field.key === 'date' || field.key === 'lastmod' || field.key === 'custom') return;
                    if (formData[field.key] !== undefined) {
                        if (field.type === 'array') {
                            if (Array.isArray(formData[field.key]) && formData[field.key].length > 0) {
                                frontMatterData[field.key] = formData[field.key];
                            } else if (typeof formData[field.key] === 'string' && formData[field.key].trim() !== '') {
                                frontMatterData[field.key] = formData[field.key].split(',').map(s => s.trim()).filter(s => s !== '');
                                if (frontMatterData[field.key].length === 0) delete frontMatterData[field.key];
                            }
                        } else {
                            if (String(formData[field.key]).trim() !== '') {
                                frontMatterData[field.key] = formData[field.key];
                            }
                        }
                    }
                });
                if (saveType === 'draft') {
                    frontMatterData.draft = true;
                }
                if (Array.isArray(formData.custom)) {
                    formData.custom.forEach(customField => {
                        let processedValue;
                        const rawValue = customField.value;
                        switch (customField.type) {
                            case 'number':
                                processedValue = parseFloat(String(rawValue));
                                if (isNaN(processedValue) && String(rawValue).trim() !== '') processedValue = String(rawValue);
                                else if (isNaN(processedValue)) processedValue = undefined;
                                break;
                            case 'boolean':
                                processedValue = typeof rawValue === 'boolean' ? rawValue : String(rawValue).toLowerCase() === 'true';
                                break;
                            case 'date':
                                try {
                                    const parsed = flatpickr.parseDate(String(rawValue), "Y-m-d H:i:S") || new Date(String(rawValue).replace(' ', 'T'));
                                    if (parsed && !isNaN(parsed.getTime())) {
                                        parsed.setSeconds(0, 0);
                                        processedValue = parsed.toISOString();
                                    } else if (String(rawValue).trim() !== '') {
                                        processedValue = String(rawValue);
                                    } else {
                                        processedValue = undefined;
                                    }
                                } catch (e) {
                                    processedValue = String(rawValue).trim() !== '' ? String(rawValue) : undefined;
                                }
                                break;
                            case 'array':
                                processedValue = Array.isArray(rawValue) ? rawValue.map(String).filter(s => s !== '') : String(rawValue).split(',').map(s => s.trim()).filter(s => s !== '');
                                if (processedValue.length === 0) processedValue = undefined;
                                break;
                            case 'string':
                            default:
                                processedValue = String(rawValue).trim() !== '' ? String(rawValue) : undefined;
                                break;
                        }
                        if (processedValue !== undefined) {
                            frontMatterData.custom[customField.key] = processedValue;
                        }
                    });
                }
                if (frontMatterData.draft === undefined || frontMatterData.draft === false) delete frontMatterData.draft;
                if (frontMatterData.lastmod === undefined) {
                    delete frontMatterData.lastmod;
                }
                return frontMatterData;
            },
            getSaveOperationTypeKey(saveType, isUpdate) {
                if (!isUpdate) {
                    return saveType === 'publish' ? 'statusBar.opPublishNew' : 'statusBar.opCreateDraft';
                }
                if (AppState.initialDraftState) {
                    return saveType === 'publish' ? 'statusBar.opPublishUpdate' : 'statusBar.opUpdateDraft';
                }
                return saveType === 'draft' ? 'statusBar.opRevertToDraft' : 'statusBar.opUpdatePublished';
            },
            async saveFile(saveType) {
                if (!AppState.octokit) {
                    this.handleLogout();
                    return;
                }
                UIManager.setEditorSaving(true);
                const formData = await this.getProcessedEditorFormData();
                if (!this.validateSaveInputs(formData)) {
                    UIManager.setEditorSaving(false);
                    this.refreshEditorUIState();
                    return;
                }
                const isUpdate = !!AppState.currentFileSha;
                const finalFrontMatterData = this.prepareFrontMatterForSave(formData, saveType, isUpdate);
                if (!finalFrontMatterData) {
                     UIManager.setEditorSaving(false);
                     this.refreshEditorUIState();
                     return;
                }
                const newSlug = formData.slugOrFilename;
                const userEnteredPathValue = formData.fullPathValue;
                const originalPath = AppState.currentFilePath ? PathUtils.normalizePath(AppState.currentFilePath) : null;
                const { targetPath, isTargetLocalActual } = this.determineSaveTarget(
                    isUpdate,
                    newSlug,
                    userEnteredPathValue,
                    originalPath,
                    AppState.currentPath,
                    UserSettings
                );
                const markdownDirPath = PathUtils.getDirname(targetPath);
                let bodyToSave = formData.body;
                if (UserSettings.VDITOR_EDIT_MODE === 'ir' && AppState.isDraft(AppState.currentFilePath) && PathUtils.isAnyBundlePath(AppState.currentFilePath) && UserSettings.ASSET_STRATEGY === 'local') {
                    bodyToSave = this.restoreBlobURLsToRelativePathsInBody(formData.body);
                }
                let uploadsToCommit = [], markdownWithUploadsProcessed = bodyToSave;
                try {
                    const uploadResult = await this.prepareUploads(bodyToSave, newSlug, markdownDirPath, isTargetLocalActual);
                    markdownWithUploadsProcessed = uploadResult.updatedBody;
                    uploadsToCommit = uploadResult.uploadsToCommit;
                } catch (error) {
                    UIManager.setEditorSaving(false);
                    this.refreshEditorUIState();
                    return;
                }
                let filesToDeletePaths = [];
                if (isUpdate && originalPath) {
                     const finalLinks = this.parseManagedUploadLinks(markdownWithUploadsProcessed, targetPath);
                     filesToDeletePaths.push(...await this.getFilesToDeleteBasedOnLinks(finalLinks, AppState.initialUploadLinks));
                     filesToDeletePaths = [...new Set(filesToDeletePaths.filter(p => p))];
                }
                const operationType = i18next.t(this.getSaveOperationTypeKey(saveType, isUpdate));
                let finalContent;
                try {
                    finalContent = FrontMatterUtils.formatFrontMatterAndBody(finalFrontMatterData, markdownWithUploadsProcessed);
                } catch (formatError) {
                    UIManager.setEditorSaving(false);
                    this.refreshEditorUIState();
                    return;
                }
                const filesToCommit = [
                    ...uploadsToCommit,
                    { path: targetPath, content: finalContent, encoding: 'utf-8' }
                ];
                UIManager.updateStatus(i18next.t('statusBar.saving', { path: targetPath, operation: operationType }), false, false, true);
                try {
                    const commitResult = await this.executeCommit(formData.commitMessage, filesToCommit, filesToDeletePaths);
                    if (commitResult.success) {
                        UIManager.updateStatus(i18next.t('statusBar.saveSuccess', {
                            path: targetPath,
                            operation: operationType,
                            commitSha: commitResult.commitSha?.substring(0, 7) || 'N/A'
                        }), false, true, false);
                        const normalizedTargetPath = PathUtils.normalizePath(targetPath);
                        if (finalFrontMatterData.draft === true) {
                           AppState.draftPathsSet.add(normalizedTargetPath);
                        } else {
                            AppState.draftPathsSet.delete(normalizedTargetPath);
                        }
                        this.setBaseTag(null);
                        UIManager.removeActiveFileHighlight();
                        AppState.clearPendingUploads();
                        AppState.clearDraftAssets();
                        AppState.clearEditingFile();
                        UIManager.setBrowseOnlyState();
                        UIManager.updateStatus(i18next.t('statusBar.refreshingList'), false, false, true);
                        await Utils.delay(UserSettings.UI_TRANSITION_DELAY_MS);
                        await this.browsePath(PathUtils.getDirname(targetPath) || UserSettings.BASE_BROWSE_PATH);
                    } else {
                        UIManager.setEditorSaving(false);
                        this.refreshEditorUIState();
                    }
                } catch (error) {
                    UIManager.setEditorSaving(false);
                    this.handleGenericError(error, 'errors.saveException', "Save File");
                    this.refreshEditorUIState();
                }
            },
             confirmDeletion(filePathToDelete) {
                const isBranchBundleIndex = PathUtils.isBranchBundlePath(filePathToDelete);
                const isLeafBundleIndex = PathUtils.isPageBundlePath(filePathToDelete);
                const resourceNameToDelete = (isBranchBundleIndex || isLeafBundleIndex)
                    ? PathUtils.getBasename(PathUtils.getDirname(filePathToDelete))
                    : PathUtils.getBasename(filePathToDelete);
                let confirmMsgKey = 'prompts.confirmDelete';
                if (isBranchBundleIndex) {
                    confirmMsgKey = 'prompts.confirmDeleteBranchBundleIndex';
                } else if (isLeafBundleIndex) {
                    confirmMsgKey = 'prompts.confirmDeleteBundle';
                }
                 return confirm(
                     `${i18next.t(confirmMsgKey, { filename: PathUtils.getBasename(filePathToDelete), bundleName: PathUtils.getDirname(filePathToDelete) })}\n\n` +
                     `${i18next.t('prompts.confirmDeleteDetail')}`
                 );
            },
             getDeleteCommitMessage(resourceNameToDelete) {
                const commitMessage = i18next.t('commit.delete', { path: resourceNameToDelete });
                UIManager.setCommitMessage(commitMessage, '');
                if (!commitMessage) {
                    this.handleGenericError(null, 'errors.commitMsgRequired', "Delete Commit Message");
                    this.elements.commitMessageInput.focus();
                    return null;
                }
                return commitMessage;
            },
            async deleteFile() {
                if (!AppState.octokit) { this.handleLogout(); return; }
                if (!AppState.currentFilePath || !AppState.currentFileSha) {
                    this.handleGenericError(null, 'errors.noFileToDelete', "Delete File");
                    return;
                }
                const filePathToDelete = AppState.currentFilePath;
                if (!this.confirmDeletion(filePathToDelete)) {
                    UIManager.updateStatus(i18next.t('prompts.deleteCancelled'), false);
                    return;
                }
                const isBranchBundleIndex = PathUtils.isBranchBundlePath(filePathToDelete);
                const isLeafBundleIndex = PathUtils.isPageBundlePath(filePathToDelete);
                const resourceNameToDelete = (isBranchBundleIndex || isLeafBundleIndex)
                    ? PathUtils.getBasename(PathUtils.getDirname(filePathToDelete))
                    : PathUtils.getBasename(filePathToDelete);
                const commitMessage = this.getDeleteCommitMessage(resourceNameToDelete);
                if (!commitMessage) return;
                UIManager.setEditorSaving(true);
                UIManager.updateStatus(i18next.t(
                    isBranchBundleIndex ? 'statusBar.deletingBranchIndex' : (isLeafBundleIndex ? 'statusBar.deletingBundle' : 'statusBar.deleting'),
                     { path: resourceNameToDelete }
                 ), false, false, true);
                 let filesToDeletePaths = [];
                 try {
                     const pathsToDeleteSet = await this.identifyResourcesToDelete(
                         filePathToDelete,
                         isBranchBundleIndex,
                         isLeafBundleIndex,
                         AppState.initialUploadLinks,
                         UserSettings,
                         GitHubService
                     );
                     filesToDeletePaths = Array.from(pathsToDeleteSet).filter(p => p);
                     if (filesToDeletePaths.length === 0) {
                        throw new Error("No files identified for deletion.");
                    }
                 } catch (error) {
                     UIManager.setEditorSaving(false);
                     this.handleGenericError(error, 'errors.deleteException', "Delete Preparation");
                     this.refreshEditorUIState();
                     return;
                 }
                try {
                    const commitResult = await this.executeCommit(commitMessage, [], filesToDeletePaths);
                    if (commitResult.success) {
                        UIManager.updateStatus(i18next.t(
                            isBranchBundleIndex ? 'statusBar.deleteBranchIndexSuccess' : 'statusBar.deleteSuccess', {
                                path: resourceNameToDelete,
                                commitSha: commitResult.commitSha?.substring(0, 7) || 'N/A'
                            }
                        ), false, true, false);
                         const normalizedFilePathToDelete = PathUtils.normalizePath(filePathToDelete);
                         AppState.draftPathsSet.delete(normalizedFilePathToDelete);
                         if (isLeafBundleIndex) {
                             const bundleDirPrefix = PathUtils.getDirname(normalizedFilePathToDelete) + '/';
                             AppState.draftPathsSet.forEach(path => {
                                 if (path.startsWith(bundleDirPrefix)) {
                                     AppState.draftPathsSet.delete(path);
                                 }
                             });
                         }
                        this.setBaseTag(null);
                        UIManager.removeActiveFileHighlight();
                        AppState.clearEditingFile();
                        UIManager.setBrowseOnlyState();
                        UIManager.updateStatus(i18next.t('statusBar.navigatingParent'), false, false, true);
                        await Utils.delay(UserSettings.UI_TRANSITION_DELAY_MS);
                         let pathToShowAfterDelete = PathUtils.getDirname(filePathToDelete) || UserSettings.BASE_BROWSE_PATH;
                         if(isBranchBundleIndex || isLeafBundleIndex) {
                             pathToShowAfterDelete = PathUtils.getDirname(PathUtils.getDirname(filePathToDelete)) || UserSettings.BASE_BROWSE_PATH;
                         }
                        const normalizedBasePath = PathUtils.normalizePath(UserSettings.BASE_BROWSE_PATH);
                        if (pathToShowAfterDelete !== normalizedBasePath && !pathToShowAfterDelete.startsWith(normalizedBasePath + '/')) {
                            pathToShowAfterDelete = normalizedBasePath;
                        }
                        await this.browsePath(PathUtils.normalizePath(pathToShowAfterDelete));
                    } else {
                        UIManager.setEditorSaving(false);
                        this.refreshEditorUIState();
                    }
                } catch (error) {
                    UIManager.setEditorSaving(false);
                    this.handleGenericError(error, 'errors.deleteException', "Delete Commit");
                    this.refreshEditorUIState();
                }
            },
            async cancelEdit() {
                if (!AppState.octokit) { this.handleLogout(); return; }
                let hasChanges = false;
                if (VditorManager.isReady) {
                     try {
                         const formData = await this.getProcessedEditorFormData();
                         hasChanges = AppState.isModified(formData);
                     } catch(e) {
                         this.handleGenericError(e, "Error checking modifications", "Cancel Edit");
                         hasChanges = true;
                     }
                 }
                 if (hasChanges ? confirm(i18next.t('prompts.confirmCancel')) : true) {
                    UIManager.setEditorSaving(true);
                    UIManager.updateStatus(i18next.t('statusBar.cancelled'), false, false, true);
                    const pathBeforeCancel = AppState.currentPath || UserSettings.BASE_BROWSE_PATH;
                    UIManager.removeActiveFileHighlight();
                    await Utils.delay(UserSettings.UI_TRANSITION_DELAY_MS / 2);
                    AppState.clearEditingFile();
                    UIManager.clearEditorFields();
                    UIManager.setBrowseOnlyState();
                    UIManager.setEditorSaving(false);
                    await this.browsePath(pathBeforeCancel);
                } else {
                    UIManager.updateStatus(i18next.t('prompts.cancelAbort'));
                }
            },
        };
        document.addEventListener('DOMContentLoaded', () => {
            try {
                if (typeof App !== 'undefined' && typeof App.init === 'function') {
                    App.init();
                } else {
                    throw new Error("App object or init function not found.");
                }
            } catch (error) {
                const sb = document.getElementById('statusBar');
                if (sb) {
                    sb.textContent = resources.en.translation['errors.appInit'];
                    sb.classList.add('status-bar-error');
                }
                document.body.innerHTML = `<h1 style="color: red;">${resources.en.translation['errors.appLoad']}</h1><p>${resources.en.translation['errors.scriptError']}</p><p>${error.message}</p>`;
            }
        });
    </script></body></html>