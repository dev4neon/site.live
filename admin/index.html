<!doctype html><html><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title data-i18n=appTitle></title>
<link rel=stylesheet href=https://cdn.jsdelivr.net/npm/flatpickr/dist/flatpickr.min.css><link rel=stylesheet href=https://unpkg.com/vditor/dist/index.css><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@yaireo/tagify/dist/tagify.css><style>:root{--bg-color:#f8f9fa;--text-color:#212529;--input-bg:#ffffff;--input-border:#dee2e6;--input-text:#495057;--button-bg:#007bff;--button-text:#ffffff;--button-border:transparent;--hover-bg:#e9ecef;--border-color:#e9ecef;--link-color:#007bff;--status-bg:#f1f3f5;--status-border:#dee2e6;--status-text:#495057;--status-error-bg:#f8d7da;--status-error-text:#721c24;--status-error-border:#f5c6cb;--status-success-bg:#d1e7dd;--status-success-text:#0f5132;--status-success-border:#badbcc;--status-loading-bg:#fff3cd;--status-loading-text:#664d03;--status-loading-border:#ffecb5;--disabled-bg-color:#e9ecef;--disabled-text-color:#6c757d;--dark-disabled-bg-color:#343a40;--dark-disabled-text-color:#6c757d;--active-edit-bg:#e6f7ff;--active-edit-text:#0d6efd}body.dark-mode{--bg-color:#212529;--text-color:#e9ecef;--input-bg:#343a40;--input-border:#495057;--input-text:#f8f9fa;--button-bg:#0d6efd;--button-text:#ffffff;--button-border:transparent;--hover-bg:#495057;--border-color:#495057;--link-color:#6ea8fe;--status-bg:#343a40;--status-border:#495057;--status-text:#e9ecef;--status-error-bg:#5a2c30;--status-error-text:#f8d7da;--status-error-border:#721c24;--status-success-bg:#274a2d;--status-success-text:#d1e7dd;--status-success-border:#155724;--status-loading-bg:#5a4f2c;--status-loading-text:#fff3cd;--status-loading-border:#856404;--disabled-bg-color:#343a40;--disabled-text-color:#6c757d;--active-edit-bg:#1c3b5e;--active-edit-text:#6ea8fe}body{max-width:80rem;margin:0 auto;padding:0 .5rem;background-color:var(--bg-color);color:var(--text-color);font-family:-apple-system,BlinkMacSystemFont,segoe ui,Roboto,Helvetica,Arial,sans-serif,apple color emoji,segoe ui emoji,segoe ui symbol;line-height:1.6}body>div:first-of-type{display:flex;flex-direction:column;min-height:100vh}#fileContentInput{min-height:500px}.hidden{display:none!important}#fileList ul{list-style:none;padding:0;margin:0}#fileList li{padding:8px 10px;cursor:pointer;border-bottom:1px solid var(--border-color);display:flex;justify-content:space-between;align-items:center;gap:8px;transition:background-color .15s ease-in-out}#fileList li:last-child{border-bottom:none}#fileList li:hover{background-color:var(--hover-bg)}#fileList li.dir::before,#fileList li.bundle::before{content:"ğŸ“‚ ";flex-shrink:0;font-size:1.1em}#fileList li.file::before{content:"ğŸ“„ ";flex-shrink:0;font-size:1.1em}#fileList li.asset::before{content:"ğŸ“¦ ";flex-shrink:0;font-size:1.1em}#fileList li.parent-dir{font-style:italic;color:#6c757d}body.dark-mode #fileList li.parent-dir{color:#adb5bd}#fileList li.no-hover,#fileList li.asset{cursor:default;color:#6c757d}body.dark-mode #fileList li.no-hover,body.dark-mode #fileList li.asset{color:#adb5bd}#fileList li.no-hover:hover,#fileList li.asset:hover{background-color:transparent}#fileList li.error{background-color:var(--status-error-bg);color:var(--status-error-text);padding:10px;cursor:default;border-radius:4px;margin-bottom:5px;border:1px solid var(--status-error-border)}#fileList li.active-edit-item{background-color:var(--active-edit-bg);color:var(--active-edit-text);font-weight:600}#fileList li.active-edit-item:hover{background-color:var(--active-edit-bg)}#fileList li.active-edit-item .file-item-name,#fileList li.active-edit-item .draft-indicator{color:var(--active-edit-text)}.file-item-name{white-space:nowrap;overflow:hidden;text-overflow:ellipsis;flex-grow:1;min-width:0}.draft-indicator{color:#fd7e14;font-size:1em;font-style:normal;margin-left:auto;padding-left:10px;flex-shrink:0}body.dark-mode .draft-indicator{color:#fd7e14}.breadcrumb a{text-decoration:none;color:var(--link-color)}.breadcrumb a:hover{text-decoration:underline}.breadcrumb strong{font-weight:600}#errorStatusBarContainer{margin-top:15px;display:flex;flex-direction:column;gap:5px}.error-status-item{padding:10px 30px 10px 10px;white-space:pre-wrap;word-break:break-all;border:1px solid var(--status-error-border);background-color:var(--status-error-bg);color:var(--status-error-text);position:relative;border-radius:4px}#statusBar{margin-top:10px;padding:10px;white-space:pre-wrap;word-break:break-all;border:1px solid var(--status-border);border-radius:4px;background-color:var(--status-bg);margin-bottom:1rem}.dismiss-error-btn{position:absolute;right:5px;top:50%;transform:translateY(-50%);background:0 0;border:none;font-size:1.5em;cursor:pointer;color:var(--status-error-text);padding:0 5px;line-height:1}body.dark-mode .dismiss-error-btn{color:var(--status-error-text)}#statusBar.status-bar-error{background-color:var(--status-error-bg);color:var(--status-error-text);border-color:var(--status-error-border)}#statusBar.status-bar-success{background-color:var(--status-success-bg);color:var(--status-success-text);border-color:var(--status-success-border)}#statusBar.status-bar-loading{background-color:var(--status-loading-bg);color:var(--status-loading-text);border-color:var(--status-loading-border)}label{display:block;margin-top:10px;margin-bottom:5px;font-weight:600}.flatpickr-input{padding:.5rem .75rem!important;box-sizing:border-box!important}input[type=text],input[type=password],input[type=search],textarea,select{width:100%;box-sizing:border-box;padding:.5rem .75rem;margin-bottom:10px;border:1px solid var(--input-border);background-color:var(--input-bg);color:var(--input-text);border-radius:4px;line-height:1.5;font-size:1rem;height:2.5rem;transition:border-color .15s ease-in-out,box-shadow .15s ease-in-out}input:focus,textarea:focus,select:focus{border-color:#86b7fe;outline:0;box-shadow:0 0 0 .25rem rgba(13,110,253,.25)}textarea{min-height:200px;font-family:Consolas,Monaco,andale mono,ubuntu mono,monospace}button{display:inline-block;font-weight:400;line-height:1.5;color:var(--button-text);text-align:center;text-decoration:none;vertical-align:middle;cursor:pointer;-webkit-user-select:none;-moz-user-select:none;user-select:none;background-color:var(--button-bg);border:1px solid var(--button-border);padding:.5rem .7rem;font-size:1rem;border-radius:4px;transition:opacity .15s ease-in-out}button:hover{opacity:.85}button:disabled{cursor:not-allowed;opacity:.65;background-color:var(--disabled-bg-color);color:var(--disabled-text-color);border-color:var(--input-border)}body.dark-mode button:disabled{background-color:var(--dark-disabled-bg-color);color:var(--dark-disabled-text-color);border-color:var(--input-border)}#saveDraftButton,#publishButton,#deleteFileButton,#cancelEditButton{margin-bottom:8px}#logoutButton{display:block;background-color:#6c757d;color:#fff;border-color:#6c757d;margin-top:15px;margin-bottom:10px;margin-left:auto}hr{margin:1.5rem 0;border:0;border-top:1px solid var(--border-color);opacity:.7}.custom-fm-row{display:flex;gap:5px;margin-bottom:5px;align-items:center}.custom-fm-row input[type=text],.custom-fm-row input[type=checkbox],.custom-fm-row select,.custom-fm-row .tagify{margin-bottom:0}.custom-fm-type{flex:.5}.custom-fm-key{flex:.8}.custom-fm-value-container{flex:2;min-width:0}.custom-fm-value-container input[type=text],.custom-fm-value-container input[type=checkbox],.custom-fm-value-container .tagify{width:100%;box-sizing:border-box}.custom-fm-value-container input[type=checkbox]{width:auto;margin-right:5px}.remove-custom-fm-button{background-color:#dc3545;border-color:#dc3545;color:#fff}h1,h2,h3{color:var(--text-color);margin-top:1.5rem;font-weight:600}p,div,span,li{color:var(--text-color)}code{background-color:var(--hover-bg);padding:.2em .4em;margin:0;font-size:85%;border-radius:3px;font-family:Consolas,Monaco,andale mono,ubuntu mono,monospace;color:var(--text-color)}body.dark-mode code{background-color:#495057}body.dark-mode .flatpickr-calendar{background:#2a2a2a;border-color:var(--border-color);box-shadow:0 0 0 1px var(--border-color)}body.dark-mode .flatpickr-day{color:#adb5bd}body.dark-mode .flatpickr-day:hover,body.dark-mode .flatpickr-day:focus{background:var(--hover-bg);border-color:var(--hover-bg);color:#f8f9fa}body.dark-mode .flatpickr-day.today{border-color:var(--link-color);color:var(--link-color)}body.dark-mode .flatpickr-day.selected,body.dark-mode .flatpickr-day.startRange,body.dark-mode .flatpickr-day.endRange{background:var(--link-color);border-color:var(--link-color);color:#fff}body.dark-mode .flatpickr-month,body.dark-mode .flatpickr-weekday,body.dark-mode .flatpickr-weekdays,body.dark-mode .numInput,body.dark-mode .flatpickr-current-month input.cur-year{color:#ced4da}body.dark-mode .flatpickr-time input,body.dark-mode .flatpickr-time .flatpickr-am-pm{background:#495057;color:#f8f9fa;border-color:var(--input-border)}input:disabled,textarea:disabled,select:disabled{background-color:var(--disabled-bg-color);color:var(--disabled-text-color);cursor:not-allowed;opacity:.7}body.dark-mode input:disabled,body.dark-mode textarea:disabled,body.dark-mode select:disabled{background-color:var(--dark-disabled-bg-color);color:var(--dark-disabled-text-color);opacity:.7}.filename-input-wrapper{display:flex;align-items:center;gap:5px}.filename-input-wrapper input{flex-grow:1;margin-bottom:0;font-family:Consolas,Monaco,andale mono,ubuntu mono,monospace}#fmLastmodValue{margin-left:.5rem;font-size:.9rem;color:#6c757d}body.dark-mode #fmLastmodValue{color:#adb5bd}#fileFilterInput{max-width:300px;margin-right:10px;margin-bottom:0}.file-browser-toolbar{margin:10px 0;display:flex;flex-wrap:wrap;gap:5px;align-items:center}#fileListEmptyMessage{text-align:center;margin-top:15px;color:#6c757d}body.dark-mode #fileListEmptyMessage{color:#adb5bd}.warning-message{font-weight:400;margin:0;font-size:.8em}.pat-warning-box{padding:1rem;margin-bottom:1.5rem;border:1px solid var(--status-loading-border);background-color:var(--status-loading-bg);color:var(--status-loading-text);border-radius:4px}.pat-warning-box strong{color:var(--status-loading-text)}.description-note{font-size:.9em;color:#6c757d;margin-bottom:1rem;line-height:1.5;padding:.7rem;margin-bottom:1.5rem;border:1px solid var(--input-border);border-radius:4px}body.dark-mode .description-note{color:#adb5bd}#draftFilterContainer{display:flex;margin-left:10px;align-items:center;gap:5px}.home-logout-container{display:flex;align-items:center;margin-top:auto;padding-top:1rem;border-top:1px solid var(--border-color);width:100%;box-sizing:border-box}.home-link{text-decoration:none;font-weight:700;font-size:1.2rem;color:inherit}#appVersionInfo{font-size:.9em;color:var(--disabled-text-color);flex-grow:1;text-align:center}#appVersionInfo a{font-weight:700;color:var(--link-color);text-decoration:none}#appVersionInfo a:hover{text-decoration:underline}#appVersionInfo sup{font-size:.5em}#mainLayoutContainer{display:flex;gap:1.5rem;align-items:flex-start}#fileBrowserSection{flex:1 1 100%;max-width:none;display:block;border:none;border-radius:0;background-color:transparent;box-sizing:border-box}#fileList{border:1px solid var(--border-color);border-radius:4px;background-color:var(--input-bg);overflow-y:auto;margin-top:.5rem;margin-bottom:.5rem}#editorSection{flex:1 1 100%;display:none}.tagify{--tag-pad:0.3rem 0.5rem;width:100%;color:var(--input-text);background-color:var(--input-bg);border:1px solid var(--input-border);border-radius:4px}.tagify.tagify--focus{box-shadow:0 0 0 .25rem rgba(13,110,253,.25)}body.dark-mode .tagify{color:var(--input-text);background-color:var(--input-bg)}.tagify__tag>div::before{box-shadow:none}.tagify__input{color:var(--input-text);background-color:var(--input-bg)}.tagify__tag{--tag-remove-btn-color:var(--text-color);background-color:#d3d3d3;display:inline-flex;align-items:center;box-sizing:border-box;font-size:.9em;border-radius:4px}body.dark-mode .tagify__tag{background-color:dimgray}.tagify__tag:hover{opacity:.85}.fm-date-wrapper{display:flex;align-items:center;gap:10px;margin-bottom:10px}.fm-date-wrapper .flatpickr-input{flex-grow:1;margin-bottom:0}.fm-date-wrapper input[type=checkbox]{width:auto;margin-bottom:0}.fm-date-wrapper label{margin-top:0;margin-bottom:0;font-weight:400;font-size:.9em}@media(min-width:64rem){#mainLayoutContainer.split-view #fileBrowserSection{flex:1 1 300px;max-width:380px;min-width:250px}#mainLayoutContainer.split-view #editorSection{flex:3;min-width:0;display:block!important}}@media(max-width:63.999rem){#mainLayoutContainer{flex-direction:column;gap:1rem}#fileBrowserSection{flex-basis:auto;padding:0;width:100%;max-width:none;order:1;margin-bottom:1rem;background-color:transparent;border:none}#fileBrowserSection>h2,#fileBrowserSection>div:not(#fileList):not(#draftFilterContainer),#fileBrowserSection>.file-browser-toolbar{padding-left:10px;padding-right:10px}#fileList{max-height:calc(40vh - 60px);margin-top:0}#editorSection{flex-basis:auto;width:100%;order:2}#mainLayoutContainer.mobile-editor-visible #editorSection{display:block!important}body{padding:0 .5rem}#fileContentInput{min-height:350px}}</style></head><body><div><div id=loginSection class=hidden><h2 data-i18n=login.title></h2><p class=pat-warning-box><strong data-i18n=login.warningTitle></strong>
<span data-i18n=login.warningText><strong data-i18n=login.warningStorage></strong>
<strong data-i18n=login.warningLogout></strong>
<strong data-i18n=login.warningPerms></strong></span></p><label for=patInput data-i18n=login.patLabel></label>
<input type=password id=patInput data-i18n=[placeholder]login.patPlaceholder>
<button id=loginButton data-i18n=login.loginButton></button></div><div id=repoSection class=hidden><h2 data-i18n=repo.title></h2><label for=repoSelect data-i18n=repo.selectLabel></label>
<select id=repoSelect><option value data-i18n=repo.selectDefaultOption></option></select>
<button id=loadRepoButton disabled data-i18n=repo.loadButton></button></div><div id=mainLayoutContainer class=hidden><div id=fileBrowserSection class=hidden><h2 data-i18n=browser.title></h2><div><strong data-i18n=browser.currentRepoLabel></strong>
<span id=currentRepo></span> (
<span data-i18n=browser.branchLabel></span>
<span id=currentBranchName></span>)</div><div class=breadcrumb><strong data-i18n=browser.pathLabel></strong>
<span id=currentPathBreadcrumb>content</span></div><div class=file-browser-toolbar><input type=search id=fileFilterInput placeholder data-i18n=[placeholder]browser.filterPlaceholder><div id=draftFilterContainer class=hidden><input type=checkbox id=draftFilterCheckbox>
<label for=draftFilterCheckbox class=warning-message data-i18n=browser.showOnlyDraftsLabel></label></div></div><div id=fileList><ul></ul></div><div id=fileListEmptyMessage class=hidden data-i18n=browser.filterNoResults></div><button id=createNewFileButton data-i18n=browser.newFileButtonInFolder></button></div><div id=editorSection class=hidden><h2 data-i18n=editor.title></h2><input type=hidden id=currentFileSha>
<input type=hidden id=currentFilePathInput>
<label for=fmTitleInput data-i18n=editor.fm.titleLabel></label>
<input type=text id=fmTitleInput data-i18n=[placeholder]editor.fm.titlePlaceholder>
<label for=fileNameInput id=fileNameLabel data-i18n=editor.fm.fileNameLabel></label><div class=filename-input-wrapper><input type=text id=fileNameInput data-i18n=[placeholder]editor.fm.fileNamePlaceholder></div><hr><h3 data-i18n=editor.fm.baseHeader></h3><p class=description-note data-i18n=editor.fm.baseNote></p><label for=fmDateInput data-i18n=editor.fm.dateLabel></label><div class=fm-date-wrapper><input type=text id=fmDateInput data-i18n=[placeholder]editor.fm.datePlaceholder class=flatpickr-input>
<input type=checkbox id=fmDateAutoCheckbox>
<label for=fmDateAutoCheckbox id=fmDateAutoLabel data-i18n=editor.fm.autoSetToNow></label></div><div id=fmLastmodContainer class=hidden><label for=fmLastmodInput data-i18n=editor.fm.lastmodLabel></label><div class=fm-date-wrapper><input type=text id=fmLastmodInput data-i18n=[placeholder]editor.fm.datePlaceholder class=flatpickr-input>
<input type=checkbox id=fmLastmodAutoCheckbox>
<label for=fmLastmodAutoCheckbox id=fmLastmodAutoLabel data-i18n=editor.fm.autoSetToNow></label></div></div><label for=fmAuthorInput data-i18n=editor.fm.authorLabel></label>
<input type=text id=fmAuthorInput data-i18n=[placeholder]editor.fm.authorPlaceholder>
<label for=fmDescriptionInput data-i18n=editor.fm.descriptionLabel></label>
<input type=text id=fmDescriptionInput data-i18n=[placeholder]editor.fm.descriptionPlaceholder>
<label for=fmTagsInput data-i18n=editor.fm.tagsLabel></label>
<input type=text id=fmTagsInput data-i18n=[placeholder]editor.fm.tagsPlaceholder>
<label for=fmCategoriesInput data-i18n=editor.fm.categoriesLabel></label>
<input type=text id=fmCategoriesInput data-i18n=[placeholder]editor.fm.categoriesPlaceholder><hr><h3 data-i18n=editor.fm.customHeader></h3><p class=description-note data-i18n=editor.fm.customNote></p><div id=customFrontMatterContainer></div><button type=button id=addCustomFieldButton data-i18n=editor.fm.addCustomFieldButton></button><hr><h3 id=fileContentLabel data-i18n=editor.content.fileContentLabel></h3><div id=fileContentInput aria-labelledby=fileContentLabel></div><hr><h3 for=commitMessageInput data-i18n=editor.commitMessageLabel></h3><input type=text id=commitMessageInput data-i18n=[placeholder]editor.commitMessagePlaceholder>
<button id=saveDraftButton data-i18n=editor.saveDraftButton></button>
<button id=publishButton data-i18n=editor.publishButton></button>
<button id=deleteFileButton data-i18n=editor.deleteButton></button>
<button id=cancelEditButton data-i18n=editor.cancelButton></button></div></div><div id=errorStatusBarContainer></div><div id=statusBar></div><div class=home-logout-container><a href=/ id=homeLink class=home-link>ğŸ </a>
<span id=appVersionInfo><a href=https://github.com/dev4neon target=_blank rel="noopener noreferrer">GiCAHS</a>
<sup>0.1.1</sup>
</span><button id=logoutButton class=hidden data-i18n=logoutButton></button></div></div><script>const UserSettings={DEFAULT_BRANCH:"main",BASE_BROWSE_PATH:"content",ASSET_STRATEGY:"local",GLOBAL_ROOT_DIR:"static",GLOBAL_ASSET_SUBPATH:"uploads",OMIT_GLOBAL_ROOT_DIR_FROM_URL:!0,LOCAL_ASSET_SUBDIR:"",FRONTMATTER_FORMAT:"yaml",VDITOR_EDIT_MODE:"ir",DEFAULT_LANGUAGE:"en",UI_TRANSITION_DELAY_MS:500}</script><script>const resources={en:{translation:{appTitle:"GitHub-integrated Content Administration for Hugo Sites","login.title":"GitHub Login","login.warningTitle":"âš ï¸","login.warningText":"Using a Personal Access Token (PAT) involves security risks. Use it only in trusted environments for personal use and be careful not to expose it. This token is stored in your browser's local storage and may persist even after closing the browser. On public computers, always log out to delete the token or clear browser data after use.","login.warningStorage":"stored in the browser's local storage","login.warningLogout":"be sure to log out","login.warningPerms":"'repo'","login.patLabel":"Personal Access Token (PAT):","login.patPlaceholder":"Enter GitHub PAT ('repo' permission needed)","login.loginButton":"Login","login.loadingButton":"Logging in...","login.authCompleteButton":"Authenticated","repo.title":"Select Repository","repo.selectLabel":"Repository:","repo.selectDefaultOption":"-- Select Repository --","repo.loadButton":"Open content folder","browser.title":"File Browser","browser.currentRepoLabel":"Current Repo:","browser.branchLabel":"Branch:","browser.pathLabel":"Path:","browser.newFileButtonInFolder":"New File @ __dirName__","browser.loadingFiles":"<center>Loading folder contents...</center>","browser.emptyFolder":"(Folder is empty)","browser.emptyBaseFolder":"(folder is empty or not found)","browser.parentDirLink":".. (Parent folder)","browser.fileTooltip":"Edit file: __path__","browser.dirTooltip":"Open folder: __path__","browser.bundleTooltip":"Open Local Content (Page Bundle) folder: __path__","browser.nonEditableTooltip":"This editor can only edit markdown(.md) files (__name__)","browser.assetTooltip":"Asset file (not editable): __name__","browser.errorLoading":"<center>Could not load folder contents.</center>","browser.errorNotFound":"<center>Path '__path__' not found.</center>","browser.newFileButtonDisabledLeafBundleTooltip":"Cannot create a new file inside a leaf bundle.","browser.filterPlaceholder":"Filter by name...","browser.filterNoResults":"(No matching files or folders found)","browser.showOnlyDraftsLabel":"Drafts only","editor.title":"File Editor","editor.fm.titleLabel":"Title (Used for filename/folder generation):","editor.fm.titlePlaceholder":"Post title","editor.fm.fileNameLabel":"File Name (Includes suffix):","editor.fm.fileNamePlaceholder":"my-new-post.md (Auto-generated from Title)","editor.fm.bundlePathLabel":"Local Content Path (Includes index):","editor.fm.bundlePathPlaceholder":"my-new-content/index.md (Auto-generated from Title)","editor.fm.baseHeader":"Front Matter - Basic Fields","editor.fm.baseNote":"â„¹ï¸ Both YAML and TOML formats are recognized on load. The content will be saved in the format specified in the configuration (currently __format__).","editor.fm.authorLabel":"Author:","editor.fm.authorPlaceholder":"(Optional) Author name","editor.fm.dateLabel":"Date (YYYY-MM-DD HH:MM)):","editor.fm.datePlaceholder":"Select or enter date and time","editor.fm.lastmodLabel":"Lastmod (YYYY-MM-DD HH:MM)):","editor.fm.lastmodPlaceholder":"Select or enter date and time (Optional)","editor.fm.descriptionLabel":"Description:","editor.fm.descriptionPlaceholder":"(Optional) Short description","editor.fm.tagsLabel":"Tags (comma-separated):","editor.fm.tagsPlaceholder":"(Optional) e.g., web, development, github","editor.fm.categoriesLabel":"Categories (comma-separated):","editor.fm.categoriesPlaceholder":"(Optional) e.g., tech, programming","editor.fm.customHeader":"Front Matter - Additional Options","editor.fm.customNote":"âš ï¸ Ensure custom keys do not conflict with standard fields (title, date, etc.) and are not duplicated below. Saving will be blocked if conflicts or duplicates are found. Select the appropriate type for each custom field.","editor.fm.customKeyPlaceholder":"Key","editor.fm.customValuePlaceholder":"Value","editor.fm.customTypeLabel":"Type:","editor.fm.typeString":"String","editor.fm.typeNumber":"Number","editor.fm.typeBoolean":"Boolean","editor.fm.typeDate":"Date","editor.fm.typeArrayString":"Array (String)","editor.fm.addCustomFieldButton":"Add Custom Field","editor.fm.removeCustomFieldButton":"Remove","editor.fm.removeCustomFieldButtonTooltip":"Delete this field","editor.fm.fileNameDisabledTooltip":"Filename/path cannot be changed for existing files.","editor.fm.typeBooleanTrue":"True","editor.fm.typeBooleanFalse":"False","editor.fm.dateAutoLabel":"Date Auto","editor.fm.lastmodAutoLabel":"Lastmod Auto","editor.fm.autoSetToNow":"Auto (current time)","editor.fm.manualInput":"Manual","editor.content.fileContentLabel":"File Content (Body - Markdown, etc.)","editor.commitMessageLabel":"Commit Message (Auto-generated/editable):","editor.commitMessagePlaceholder":"Auto-generated or enter manually","editor.saveDraftButton":"Draft","editor.publishButton":"Publish","editor.revertToDraftButton":"Unpublish","editor.updateAndPublishButton":"Update","editor.deleteButton":"Delete","editor.cancelButton":"Cancel","commit.create":"Create __path__ via GiCAHS","commit.update":"Update __path__ via GiCAHS","commit.delete":"Delete __path__ via GiCAHS","statusBar.statusPrefix":"Status:","statusBar.waiting":"Waiting...","statusBar.loadingRepo":"Loading '__repo__' repository '__path__'...","statusBar.loadingFolder":"Loading folder '__path__'...","statusBar.loadingFile":"Loading file '__path__'...","statusBar.repoLoaded":"Loaded __count__ repositories. Select a repository to edit.","statusBar.folderLoaded":"Loaded folder '__path__'.","statusBar.fileLoaded":"Loaded '__path__' __fmInfo__. Ready to edit.","statusBar.fileLoadedWithError":"Loaded '__path__' (Front Matter parsing error). Ready to edit.","statusBar.fmInfoYAML":"(Parsed YAML)","statusBar.fmInfoTOML":"(Parsed TOML)","statusBar.fmInfoNone":"(No FM)","statusBar.saving":"Saving changes to '__path__' (__operation__)...","statusBar.opCreateDraft":"Create Draft","statusBar.opPublishNew":"Publish New","statusBar.opUpdateDraft":"Update Draft","statusBar.opPublishUpdate":"Publish Update","statusBar.opRevertToDraft":"Revert to Draft","statusBar.opUpdatePublished":"Update Published","statusBar.deleting":"Deleting '__path__'... Preparing commit...","statusBar.deletingBundle":"Deleting Local Content folder '__path__' and all its contents... Preparing commit...","statusBar.deletingBranchIndex":"Deleting branch index '__path__' and linked assets...","statusBar.deletingLegacyDir":"Identifying related global assets in '__path__' for deletion...","statusBar.legacyDirContentsIdentified":"Marked __count__ related global files/folders in '__path__' for deletion.","statusBar.legacyDirCheckFailed":"Error identifying related global assets in '__path__'. Deletion might be incomplete.","statusBar.saveSuccess":"File '__path__' __operation__ complete (Commit: __commitSha__).","statusBar.deleteSuccess":"'__path__' deleted successfully (Commit: __commitSha__).","statusBar.deleteBranchIndexSuccess":"Branch index '__path__' and linked assets deleted (Commit: __commitSha__).","statusBar.refreshingList":"Refreshing list...","statusBar.navigatingParent":"Navigating to parent folder...","statusBar.newFileReady":"Ready to create a new file in '__path__'.","statusBar.newFileReadyBundle":"Ready to create new Local Content (Page Bundle) in '__path__'.","statusBar.newFileCreationReady":"New file creation @ '__path__'","statusBar.newFileCreationReadyBundle":"New Local Content creation @ '__path__'","statusBar.cancelled":"Edit operation cancelled.","statusBar.logout":"Logged out.","statusBar.authInProgress":"Authenticating with GitHub...","statusBar.authSuccess":"Authentication successful. Loading repository list...","statusBar.autoLoginInProgress":"Attempting auto-login with stored PAT...","statusBar.autoLoginFailed":"Auto-login failed. Please enter your PAT.","statusBar.urlAction":"Processing URL action: __path__...","statusBar.urlActionNew":"URL request: Ready to create new file/bundle in '__path__'.","statusBar.findingFile":"Looking for file '__filename__' in '__dirPath__'...","statusBar.fileFound":"Found file '__filename__'. Loading content...","statusBar.fileNotFound":"404 Error - File '__filename__' not found in '__dirPath__'.","statusBar.parentNotFound":"404 Error - Parent path '__dirPath__' not found. Cannot load file '__filename__'.","statusBar.mdExtAdded":"Warning: '.md' extension automatically added to filename.","statusBar.bundleIndexMdRequired":"Warning: Local Content requires '/index.md' or '/_index.md' suffix.","statusBar.dateSetToNow":"Info: Date automatically set to current time.","statusBar.uploadingImages":"Preparing __count__ files for commit...","statusBar.uploadingImage":"Preparing file: __filename__...","statusBar.uploadComplete":"__count__ files prepared. Creating commit...","statusBar.imagePreviewReady":"__count__ file upload placeholders ready. Will be uploaded on save.","statusBar.uploadPlaceholderReady":"__count__ file upload placeholders ready. Will be uploaded on save.","statusBar.imageUploadError":"Error preparing file '__filename__' for commit.","statusBar.checkingAssocImages":"Identifying associated assets for deletion...","statusBar.gettingImageSha":"Preparing file for commit: __image__...","statusBar.deletingUnusedImage":"Marking unused file for deletion: __image__...","statusBar.imageCleanupSuccess":"__count__ unused files marked for deletion.","statusBar.imageCleanupFailed":"Finished identifying files: __success__ marked for deletion, __count__ failed. Check console.","statusBar.imageCleanupSkipped":"Info: File cleanup skipped __count__ files (already deleted?).","statusBar.cleaningImages":"Identifying unused files for deletion...","statusBar.checkingBundleContents":"Identifying all contents of local content folder '__path__' for deletion...","statusBar.bundleContentsIdentified":"Marked __count__ files/folders in '__path__' for deletion.","statusBar.bundleContentsCheckFailed":"Error identifying local content contents for deletion in '__path__'. Deletion might be incomplete.","statusBar.creatingBlobs":"Creating blobs for __count__ files...","statusBar.creatingTree":"Creating tree object...","statusBar.creatingCommit":"Creating commit...","statusBar.updatingRef":"Updating branch reference...","statusBar.commitFailed":"Commit failed at step: __step__. Check console.","statusBar.searchingContent":"Searching for content matching '__slug__'...","statusBar.searchAttempt":"Searching for '__path__'...","statusBar.contentNotFound":"Could not find content for '__slug__' (tried index.md, _index.md, and .md).","statusBar.infoPrefix":"Info:","statusBar.patChangedLogout":"Stored token changed. Logging out for security. Please log in again.","statusBar.identifyingBranchIndexResources":"Info: Identifying resources for branch index deletion: __filePath__","statusBar.markedFileForDeletion":"Info: Marked file for deletion: __filename__","statusBar.noInitialLinksFound":"Info: No initial links found for this _index.md.","statusBar.noAssociatedAssetsFound":"Info: No associated assets found based on initial links.","statusBar.legacyAssetDirNotFound":"Info: Related global asset dir '__path__' not found.","statusBar.legacyAssetDirEmpty":"Info: Related global asset dir '__path__' empty.","statusBar.loadingStoredRepo":"Loading stored repository '__repo__'...","statusBar.loadingRepoList":"Loading repository list...",logoutButton:"Logout","prompts.confirmDelete":"Are you sure you want to permanently delete the file '__filename__'?","prompts.confirmDeleteBundle":`This is Local Content (Page Bundle)!

Are you sure you want to permanently delete the folder '__bundleName__' and ALL its contents (including images and other assets)?`,"prompts.confirmDeleteBranchBundleIndex":`You are about to delete the branch index file '__filename__'. This may also delete assets linked within this file.

The folder '__bundleName__' and its other contents WILL NOT be deleted.

This action cannot be undone!`,"prompts.confirmDeleteDetail":"This action cannot be undone!","prompts.confirmCancel":"There are unsaved changes. Are you sure you want to cancel without saving?","prompts.cancelAbort":"Cancellation aborted.","prompts.deleteCancelled":"File deletion cancelled.","errors.patRequired":"GitHub PAT is required.","errors.invalidRepo":"Please select a valid repository.","errors.apiError":"API Error: __message__","errors.authFailed":"GitHub authentication failed","errors.repoListFailed":"Failed to load repository list","errors.folderLoadFailed":"Failed to load folder contents (__path__)","errors.fileLoadFailed":"Failed to load file content (__path__)","errors.saveFailed":"Failed to save file","errors.deleteFailed":"Failed to delete","errors.deleteFailedResource":"Failed to delete '__path__'","errors.yamlParseError":"Front Matter (YAML) parsing error: __message__. Original content preserved.","errors.tomlParseError":"Front Matter (TOML) parsing error: __message__. Original content preserved.","errors.yamlFormatError":"Front Matter (YAML) generation error: __message__","errors.tomlFormatError":"Front Matter (TOML) generation error: __message__","errors.networkError":"Network error or unable to connect to GitHub API.","errors.unknownError":"An unexpected error occurred. __message__","errors.titleRequired":"'Title' is required.","errors.invalidFilename":"Valid filename/path required (e.g., name.md or folder/index.md).","errors.commitMsgRequired":"Commit message is required.","errors.invalidDate":"Invalid date format. Use 'YYYY-MM-DD HH:MM' or select from calendar.","errors.invalidCustomFieldType":"Invalid value for selected type for custom field '__key__'.","errors.vditorInitFailed":"Markdown editor (Vditor) initialization failed.","errors.vditorGetValueFailed":"Failed to get content from Vditor.","errors.vditorSetValueFailed":"Failed to set content in Vditor.","errors.imageUploadFailed":"Error preparing file for commit: __message__","errors.folderNotFound":"Resource '__path__' not found.","errors.fileNotFoundInFolder":"File '__filename__' not found within '__dirPath__'.","errors.genericApiError":"__context__ (Code: __code__): __message__","errors.authError":"__context__ (Code: 401): Authentication error. PAT may be invalid/expired.","errors.permissionError":"__context__ (Code: 403): Permission error. PAT may lack 'repo' permission or API rate limit exceeded.","errors.rateLimit":" GitHub API rate limit reached. Try again later.","errors.repoAccessDenied":" PAT lacks repository access (SSO/permissions).","errors.notFoundError":"404 Error: Resource '__path__' not found.","errors.conflictError":"__context__ (Code: 409): Conflict error (possibly SHA mismatch or branch update issue). Refresh and try again.","errors.unprocessableError":"__context__ (Code: 422): Unprocessable Entity. Issue with commit data (tree/blob?). __message__","errors.unexpectedErrorContext":"__context__: Unexpected error. __message__","errors.urlParseFailed":"Error parsing URL path. Starting in default mode.","errors.repoNotSet":"Repository information not set.","errors.missingBlob":"Invalid blob data received from API.","errors.largeFileWarn":"Warning: File size (__sizeMB__ MB) exceeds 1MB. Loading/saving may be slow.","errors.noAuth":"Not authenticated.","errors.missingContext":"Missing auth or repo context.","errors.base64Encode":"Base64 encoding failed.","errors.base64Decode":"Base64 or UTF-8 decoding failed: __message__","errors.invalidDateForFlatpickr":"Warning: Could not parse/convert date '__date__'. Displaying original value.","errors.customKeyConflict":"Warning: Custom key '__key__' conflicts with/duplicates a standard field and will be ignored.","errors.vditorNotReady":"Vditor instance not ready or available.","errors.vditorFocus":"Error focusing Vditor editor.","errors.titleFocus":"Error focusing title input.","errors.vditorTheme":"Error setting Vditor theme dynamically.","errors.vditorDestroy":"Error destroying previous Vditor instance.","errors.appInit":"Error: Application initialization failed.","errors.appLoad":"App Loading Error","errors.appError":"Application error: __message__","errors.scriptError":"Script error. Check console.","errors.blobUrl":"Error creating blob URL.","errors.previewGenFailed":"Error generating placeholder for __filename__.","errors.noFileToUpload":"No file to upload.","errors.notLoggedInForUpload":"File preparation error: Not logged into GitHub.","errors.shaFetchFailed":"Failed to get info for file __path__: __reason__","errors.imageDeleteFailed":"Failed to mark file __path__ for deletion: __reason__","errors.imageUploadFailedGeneric":"File preparation for commit failed. Cannot proceed.","errors.imageUploadFailedGenericWithMessage":"File preparation for commit failed: __message__","errors.noFileToDelete":"No file selected or loaded for deletion.","errors.deleteException":"An unexpected error occurred during the delete commit process.","errors.saveException":"An unexpected error occurred during the save commit process.","errors.fileEditPrepException":"Error preparing to edit file: __path__","errors.fileSearchLoadFailed":"Error searching for file: __path__","errors.folderBrowseException":"Error browsing folder: __path__","errors.browserErrorLoadingSevere":"Severe error loading folder contents. Check console.","errors.urlActionFailed":"Error processing URL action","errors.noAccessibleRepos":"No accessible repositories found.","errors.commitFailed":"Commit process failed: __step__","errors.bundleContentsCheckFailed":"Failed to identify local content contents for deletion in '__path__': __message__","errors.deleteBundleException":"An unexpected error occurred while preparing local content deletion for '__path__'.","errors.contentSearchFailed":"Error searching for content '__slug__': __message__","errors.searchParentDirNotFound":"Parent folder '__dirPath__' not found while searching for '__slug__'.","errors.markdownTransformError":"Error transforming Markdown paths.","errors.markdownRestoreError":"Error restoring Markdown paths.","errors.legacyDirCheckFailed":"Failed to identify related global assets for deletion in '__path__': __message__","errors.contextualNetworkError":"__context__: Network error or unable to connect to GitHub API.","errors.storedRepoLoadFailed":"Failed to load stored repository '__repo__'. Check access or select again.","errors.customKeyConflictSaveBlock":"Custom key '__key__' conflicts with a standard field and cannot be used. Please rename the key.","errors.customKeyDuplicate":"Duplicate custom key '__key__' found. Please remove duplicate fields or rename the key.","errors.lastmodBeforeDate":"Lastmod cannot be earlier than Date. Please correct the dates."}},ko:{translation:{appTitle:"Hugo ì‚¬ì´íŠ¸ìš© GitHub ê¸°ë°˜ ì½˜í…ì¸  ê´€ë¦¬ ë„êµ¬","login.title":"GitHub ë¡œê·¸ì¸","login.warningTitle":"âš ï¸","login.warningText":"Personal Access Token (PAT) ì‚¬ìš©ì€ ë³´ì•ˆ ìœ„í—˜ì´ ë”°ë¦…ë‹ˆë‹¤. ì‹ ë¢°í•˜ëŠ” í™˜ê²½ì—ì„œ ê°œì¸ ìš©ë„ë¡œë§Œ ì‚¬ìš©í•˜ê³ , ë…¸ì¶œë˜ì§€ ì•Šë„ë¡ ì£¼ì˜í•˜ì„¸ìš”. ì´ í† í°ì€ ë¸Œë¼ìš°ì €ì˜ ë¡œì»¬ ìŠ¤í† ë¦¬ì§€ì— ì €ì¥ë˜ì–´ ë¸Œë¼ìš°ì €ë¥¼ ë‹«ì•˜ë‹¤ ì—´ì–´ë„ ìœ ì§€ë  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ê³µìš© ì»´í“¨í„° ë“±ì—ì„œëŠ” ì‚¬ìš© í›„ ë°˜ë“œì‹œ ë¡œê·¸ì•„ì›ƒí•˜ì—¬ í† í°ì„ ì‚­ì œí•˜ê±°ë‚˜ ë¸Œë¼ìš°ì € ë°ì´í„°ë¥¼ ì •ë¦¬í•˜ì„¸ìš”.","login.warningStorage":"ë¸Œë¼ìš°ì €ì˜ ë¡œì»¬ ìŠ¤í† ë¦¬ì§€ì— ì €ì¥","login.warningLogout":"ë°˜ë“œì‹œ ë¡œê·¸ì•„ì›ƒ","login.warningPerms":"'repo'","login.patLabel":"Personal Access Token (PAT):","login.patPlaceholder":"GitHub PAT ì…ë ¥ (repo ê¶Œí•œ í•„ìš”)","login.loginButton":"ë¡œê·¸ì¸","login.loadingButton":"ë¡œê·¸ì¸ ì¤‘...","login.authCompleteButton":"ì¸ì¦ ì™„ë£Œ","repo.title":"ì €ì¥ì†Œ ì„ íƒ","repo.selectLabel":"ì €ì¥ì†Œ:","repo.selectDefaultOption":"-- ì €ì¥ì†Œ ì„ íƒ --","repo.loadButton":"content í´ë” ì—´ê¸°","browser.title":"íŒŒì¼ íƒìƒ‰ê¸°","browser.currentRepoLabel":"í˜„ì¬ ì €ì¥ì†Œ:","browser.branchLabel":"Branch:","browser.pathLabel":"ê²½ë¡œ:","browser.newFileButtonInFolder":"ìƒˆ íŒŒì¼ ë§Œë“¤ê¸° @ __dirName__","browser.loadingFiles":"<center>í´ë” ë‚´ìš© ë¡œë”© ì¤‘...</center>","browser.emptyFolder":"(í´ë”ê°€ ë¹„ì–´ ìˆìŠµë‹ˆë‹¤)","browser.emptyBaseFolder":"(í´ë”ê°€ ë¹„ì–´ ìˆê±°ë‚˜ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤)","browser.parentDirLink":".. (ìƒìœ„ í´ë”)","browser.fileTooltip":"íŒŒì¼ ìˆ˜ì •: __path__","browser.dirTooltip":"í´ë” ì—´ê¸°: __path__","browser.bundleTooltip":"ë¡œì»¬ ì»¨í…ì¸  (í˜ì´ì§€ ë²ˆë“¤) í´ë” ì—´ê¸°: __path__","browser.nonEditableTooltip":"ì´ í¸ì§‘ê¸°ëŠ” ë§ˆí¬ë‹¤ìš´(.md) íŒŒì¼ë§Œ í¸ì§‘ ê°€ëŠ¥ (__name__)","browser.assetTooltip":"ì—ì…‹ íŒŒì¼ (í¸ì§‘ ë¶ˆê°€): __name__","browser.errorLoading":"<center>í´ë” ë‚´ìš©ì„ ë¶ˆëŸ¬ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.</center>","browser.errorNotFound":"<center>ê²½ë¡œ '__path__'ì„(ë¥¼) ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.</center>","browser.newFileButtonDisabledLeafBundleTooltip":"ë¦¬í”„ ë²ˆë“¤ ì•ˆì—ëŠ” ìƒˆ íŒŒì¼ì„ ë§Œë“¤ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.","browser.filterPlaceholder":"ì´ë¦„ìœ¼ë¡œ í•„í„°ë§...","browser.filterNoResults":"(ì¼ì¹˜í•˜ëŠ” íŒŒì¼ì´ë‚˜ í´ë”ê°€ ì—†ìŠµë‹ˆë‹¤)","browser.showOnlyDraftsLabel":"ì´ˆì•ˆë§Œ","editor.title":"íŒŒì¼ í¸ì§‘ê¸°","editor.fm.titleLabel":"Title (íŒŒì¼ëª…/í´ë”ëª… ìƒì„±ì— ì‚¬ìš©):","editor.fm.titlePlaceholder":"ê²Œì‹œë¬¼ ì œëª©","editor.fm.fileNameLabel":"íŒŒì¼ ì´ë¦„ (í™•ì¥ì í¬í•¨):","editor.fm.fileNamePlaceholder":"my-new-post.md (Title ì…ë ¥ ì‹œ ìë™ ìƒì„±)","editor.fm.bundlePathLabel":"ë¡œì»¬ ì»¨í…ì¸  ê²½ë¡œ (index í¬í•¨):","editor.fm.bundlePathPlaceholder":"my-new-content/index.md (Title ì…ë ¥ ì‹œ ìë™ ìƒì„±)","editor.fm.baseHeader":"Front Matter - ê¸°ë³¸ í•­ëª©","editor.fm.baseNote":"â„¹ï¸ ë¶ˆëŸ¬ì˜¬ ë•ŒëŠ” YAML ë˜ëŠ” TOML í˜•ì‹ì„ ì¸ì‹í•˜ë©° ì €ì¥ ì‹œì—ëŠ” ì„¤ì •ëœ í˜•ì‹(í˜„ì¬ __format__)ìœ¼ë¡œ ë³€í™˜ë©ë‹ˆë‹¤.","editor.fm.authorLabel":"Author:","editor.fm.authorPlaceholder":"(ì„ íƒ) ì‘ì„±ì","editor.fm.dateLabel":"Date (YYYY-MM-DD HH:MM):","editor.fm.datePlaceholder":"ë‚ ì§œ ë° ì‹œê°„ ì„ íƒ ë˜ëŠ” ì…ë ¥","editor.fm.lastmodLabel":"Lastmod (YYYY-MM-DD HH:MM):","editor.fm.lastmodPlaceholder":"ë‚ ì§œ ë° ì‹œê°„ ì„ íƒ ë˜ëŠ” ì…ë ¥ (ì„ íƒ ì‚¬í•­)","editor.fm.descriptionLabel":"Description:","editor.fm.descriptionPlaceholder":"(ì„ íƒ) ê°„ë‹¨í•œ ì„¤ëª…","editor.fm.tagsLabel":"Tags (ì‰¼í‘œë¡œ êµ¬ë¶„):","editor.fm.tagsPlaceholder":"(ì„ íƒ) ì˜ˆ: web, development, github","editor.fm.categoriesLabel":"Categories (ì‰¼í‘œë¡œ êµ¬ë¶„):","editor.fm.categoriesPlaceholder":"(ì„ íƒ) ì˜ˆ: tech, programming","editor.fm.customHeader":"Front Matter -ì¶”ê°€ ì„ íƒ","editor.fm.customNote":"âš ï¸ ì‚¬ìš©ì ì •ì˜ í‚¤ëŠ” ê¸°ë³¸ í•„ë“œ('title', 'date' ë“±)ì™€ ì¶©ëŒí•˜ê±°ë‚˜, ì¶”ê°€ í•„ë“œ ë‚´ì—ì„œ ì¤‘ë³µë  ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ì¶©ëŒ ë˜ëŠ” ì¤‘ë³µì´ ìˆìœ¼ë©´ ì €ì¥ì´ ì°¨ë‹¨ë©ë‹ˆë‹¤. ê° ì¶”ê°€ í•„ë“œì— ëŒ€í•´ ì˜¬ë°”ë¥¸ íƒ€ì…ì„ ì„ íƒí•´ì£¼ì„¸ìš”.","editor.fm.customKeyPlaceholder":"í‚¤ (Key)","editor.fm.customValuePlaceholder":"ê°’ (Value)","editor.fm.customTypeLabel":"íƒ€ì…:","editor.fm.typeString":"ë¬¸ìì—´","editor.fm.typeNumber":"ìˆ«ì","editor.fm.typeBoolean":"ë¶ˆë¦¬ì–¸","editor.fm.typeDate":"ë‚ ì§œ","editor.fm.typeArrayString":"ë°°ì—´(ë¬¸ìì—´)","editor.fm.addCustomFieldButton":"ì¶”ê°€ í•„ë“œ ì…ë ¥","editor.fm.removeCustomFieldButton":"ì‚­ì œ","editor.fm.removeCustomFieldButtonTooltip":"ì´ í•„ë“œ ì‚­ì œ","editor.fm.fileNameDisabledTooltip":"ê¸°ì¡´ íŒŒì¼ì˜ ì´ë¦„/ê²½ë¡œëŠ” ë³€ê²½í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.","editor.fm.typeBooleanTrue":"ì°¸","editor.fm.typeBooleanFalse":"ê±°ì§“","editor.fm.dateAutoLabel":"Date ìë™","editor.fm.lastmodAutoLabel":"Lastmod ìë™","editor.fm.autoSetToNow":"ìë™ (í˜„ì¬ ì‹œê°„)","editor.fm.manualInput":"ìˆ˜ë™","editor.content.fileContentLabel":"íŒŒì¼ ë‚´ìš© (ë³¸ë¬¸ - Markdown ë“±)","editor.commitMessageLabel":"ì»¤ë°‹ ë©”ì‹œì§€ (ìë™ ìƒì„±/í¸ì§‘ ê°€ëŠ¥):","editor.commitMessagePlaceholder":"ìë™ ìƒì„± ë˜ëŠ” ì§ì ‘ ì…ë ¥","editor.saveDraftButton":"ì´ˆì•ˆ","editor.publishButton":"ê³µê°œ","editor.revertToDraftButton":"ë¹„ê³µê°œ","editor.updateAndPublishButton":"ê³µê°œ","editor.deleteButton":"ì‚­ì œ","editor.cancelButton":"ì·¨ì†Œ","commit.create":"GiCAHS: __path__ ìƒì„±","commit.update":"GiCAHS: __path__ ì—…ë°ì´íŠ¸","commit.delete":"GiCAHS: __path__ ì‚­ì œ","statusBar.statusPrefix":"ìƒíƒœ:","statusBar.waiting":"ëŒ€ê¸° ì¤‘...","statusBar.loadingRepo":"'__repo__' ì €ì¥ì†Œ '__path__' ë¡œë”© ì¤‘...","statusBar.loadingFolder":"í´ë” '__path__' ë¡œë”© ì¤‘...","statusBar.loadingFile":"íŒŒì¼ '__path__' ë¡œë”© ì¤‘...","statusBar.repoLoaded":"__count__ê°œ ì €ì¥ì†Œ ë¡œë“œ ì™„ë£Œ. í¸ì§‘í•  ì €ì¥ì†Œë¥¼ ì„ íƒí•˜ì„¸ìš”.","statusBar.folderLoaded":"í´ë” '__path__' ë¡œë“œ ì™„ë£Œ.","statusBar.fileLoaded":"'__path__' ë¡œë“œ ì™„ë£Œ __fmInfo__. í¸ì§‘ ê°€ëŠ¥.","statusBar.fileLoadedWithError":"'__path__' ë¡œë“œ ì™„ë£Œ (Front Matter íŒŒì‹± ì˜¤ë¥˜). í¸ì§‘ ê°€ëŠ¥.","statusBar.fmInfoYAML":"(YAML íŒŒì‹±ë¨)","statusBar.fmInfoTOML":"(TOML íŒŒì‹±ë¨)","statusBar.fmInfoNone":"(FM ì—†ìŒ)","statusBar.saving":"'__path__' ë³€ê²½ì‚¬í•­ ì €ì¥ ì¤‘ (__operation__)...","statusBar.opCreateDraft":"ì´ˆì•ˆ ìƒì„±","statusBar.opPublishNew":"ìƒˆë¡œ ê³µê°œ","statusBar.opUpdateDraft":"ì´ˆì•ˆ ê°±ì‹ ","statusBar.opPublishUpdate":"ê³µê°œ","statusBar.opRevertToDraft":"ì´ˆì•ˆìœ¼ë¡œ","statusBar.opUpdatePublished":"ê³µê°œëœ ê¸€ ì—…ë°ì´íŠ¸","statusBar.deleting":"'__path__' ì‚­ì œ ì¤‘...","statusBar.deletingBundle":"ë¡œì»¬ ì»¨í…ì¸  í´ë” '__path__' ë° ëª¨ë“  ë‚´ìš© ì‚­ì œ ì¤‘...","statusBar.deletingBranchIndex":"ë¸Œëœì¹˜ ì¸ë±ìŠ¤ '__path__' ë° ë§í¬ëœ ì—ì…‹ ì‚­ì œ ì¤‘...","statusBar.deletingLegacyDir":"'__path__' ë‚´ ì—°ê´€ëœ ì „ì—­ ì—ì…‹ ì‚­ì œ ì¤€ë¹„ ì¤‘...","statusBar.legacyDirContentsIdentified":"'__path__' ë‚´ ì—°ê´€ëœ ì „ì—­ íŒŒì¼/í´ë” __count__ê°œ ì‚­ì œ ëŒ€ìƒìœ¼ë¡œ í‘œì‹œ.","statusBar.legacyDirCheckFailed":"ì˜¤ë¥˜ - '__path__' ì—°ê´€ ì „ì—­ ì—ì…‹ ì‹ë³„ ì‹¤íŒ¨. ì‚­ì œê°€ ë¶ˆì™„ì „í•  ìˆ˜ ìˆìŒ.","statusBar.saveSuccess":"íŒŒì¼ '__path__' __operation__ ì™„ë£Œ (Commit: __commitSha__).","statusBar.deleteSuccess":"'__path__' ì‚­ì œ ì™„ë£Œ (Commit: __commitSha__).","statusBar.deleteBranchIndexSuccess":"ë¸Œëœì¹˜ ì¸ë±ìŠ¤ '__path__' ë° ë§í¬ëœ ì—ì…‹ ì‚­ì œ ì™„ë£Œ (Commit: __commitSha__).","statusBar.refreshingList":"ëª©ë¡ ìƒˆë¡œê³ ì¹¨ ì¤‘...","statusBar.navigatingParent":"ìƒìœ„ í´ë”ë¡œ ì´ë™ ì¤‘...","statusBar.newFileReady":"í˜„ì¬ í´ë”('__path__')ì— ìƒˆ íŒŒì¼ ìƒì„± ì¤€ë¹„ ì™„ë£Œ.","statusBar.newFileReadyBundle":"í˜„ì¬ í´ë”('__path__')ì— ìƒˆ ë¡œì»¬ ì»¨í…ì¸ (í˜ì´ì§€ ë²ˆë“¤) ìƒì„± ì¤€ë¹„ ì™„ë£Œ.","statusBar.newFileCreationReady":"ìƒˆ íŒŒì¼ ì‘ì„± @ '__path__'","statusBar.newFileCreationReadyBundle":"ìƒˆ ë¡œì»¬ ì»¨í…ì¸  ì‘ì„± @ '__path__'","statusBar.cancelled":"í¸ì§‘ ì‘ì—… ì·¨ì†Œë¨.","statusBar.logout":"ë¡œê·¸ì•„ì›ƒë¨.","statusBar.authInProgress":"GitHub ì¸ì¦ ì§„í–‰ ì¤‘...","statusBar.authSuccess":"ì¸ì¦ ì„±ê³µ. ì €ì¥ì†Œ ëª©ë¡ ë¡œë”© ì¤‘...","statusBar.autoLoginInProgress":"ì €ì¥ëœ PATë¡œ ìë™ ë¡œê·¸ì¸ ì‹œë„ ì¤‘...","statusBar.autoLoginFailed":"ìë™ ë¡œê·¸ì¸ ì‹¤íŒ¨. PATë¥¼ ë‹¤ì‹œ ì…ë ¥í•˜ì„¸ìš”.","statusBar.urlAction":"URL ì‘ì—… ì²˜ë¦¬ ì¤‘: __path__...","statusBar.urlActionNew":"URL ìš”ì²­: '__path__' í´ë”ì— ìƒˆ íŒŒì¼/ë²ˆë“¤ ìƒì„± ì¤€ë¹„ ì™„ë£Œ.","statusBar.findingFile":"'__dirPath__' í´ë”ì—ì„œ '__filename__' íŒŒì¼ ì°¾ëŠ” ì¤‘...","statusBar.fileFound":"'__filename__' íŒŒì¼ ì°¾ìŒ. ë‚´ìš© ë¡œë”© ì¤‘...","statusBar.fileNotFound":"404 ì˜¤ë¥˜ - '__dirPath__' í´ë” ë‚´ì—ì„œ '__filename__' íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŒ.","statusBar.parentNotFound":"404 ì˜¤ë¥˜ - ìƒìœ„ ê²½ë¡œ '__dirPath__'ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŒ. íŒŒì¼ '__filename__' ë¡œë“œ ë¶ˆê°€.","statusBar.mdExtAdded":"ê²½ê³ : íŒŒì¼ëª…ì— '.md' í™•ì¥ìê°€ ìë™ ì¶”ê°€ë˜ì—ˆìŠµë‹ˆë‹¤.","statusBar.bundleIndexMdRequired":"ê²½ê³ : ë¡œì»¬ ì»¨í…ì¸ ëŠ” '/index.md' ë˜ëŠ” '/_index.md'ë¡œ ëë‚˜ì•¼ í•©ë‹ˆë‹¤.","statusBar.dateSetToNow":"ì •ë³´: ë‚ ì§œê°€ í˜„ì¬ ì‹œê°„ìœ¼ë¡œ ìë™ ì„¤ì •ë˜ì—ˆìŠµë‹ˆë‹¤.","statusBar.uploadingImages":"__count__ê°œ íŒŒì¼ ì»¤ë°‹ ì¤€ë¹„ ì¤‘...","statusBar.uploadingImage":"íŒŒì¼ ì»¤ë°‹ ì¤€ë¹„ ì¤‘: __filename__...","statusBar.uploadComplete":"__count__ê°œ íŒŒì¼ ì¤€ë¹„ ì™„ë£Œ. ì»¤ë°‹ ìƒì„± ì¤‘...","statusBar.imagePreviewReady":"__count__ê°œ íŒŒì¼ ì—…ë¡œë“œ ì¤€ë¹„ ì™„ë£Œ. ì €ì¥ ì‹œ ì»¤ë°‹ë©ë‹ˆë‹¤.","statusBar.uploadPlaceholderReady":"__count__ê°œ íŒŒì¼ ì—…ë¡œë“œ ì¤€ë¹„ ì™„ë£Œ. ì €ì¥ ì‹œ ì»¤ë°‹ë©ë‹ˆë‹¤.","statusBar.imageUploadError":"ì˜¤ë¥˜ - '__filename__' íŒŒì¼ ì»¤ë°‹ ì¤€ë¹„ ì‹¤íŒ¨.","statusBar.checkingAssocImages":"ì‚­ì œí•  ì—°ê´€ ì—ì…‹ ì‹ë³„ ì¤‘...","statusBar.gettingImageSha":"ì»¤ë°‹í•  íŒŒì¼ ì¤€ë¹„ ì¤‘: __image__...","statusBar.deletingUnusedImage":"ë¯¸ì‚¬ìš© íŒŒì¼ ì‚­ì œ ëŒ€ìƒìœ¼ë¡œ í‘œì‹œ ì¤‘: __image__...","statusBar.imageCleanupSuccess":"ë¯¸ì‚¬ìš© íŒŒì¼ __count__ê°œ ì‚­ì œ ëŒ€ìƒìœ¼ë¡œ í‘œì‹œ ì™„ë£Œ.","statusBar.imageCleanupFailed":"íŒŒì¼ ì‹ë³„ ì™„ë£Œ: __success__ê°œ ì‚­ì œ í‘œì‹œ, __count__ê°œ ì‹¤íŒ¨. ì½˜ì†” í™•ì¸.","statusBar.imageCleanupSkipped":"ì •ë³´: íŒŒì¼ ì •ë¦¬ ì¤‘ __count__ê°œ ê±´ë„ˆëœ€ (ì´ë¯¸ ì‚­ì œë¨?).","statusBar.cleaningImages":"ì‚­ì œí•  ë¯¸ì‚¬ìš© íŒŒì¼ ì‹ë³„ ì¤‘...","statusBar.checkingBundleContents":"ì‚­ì œí•  ë¡œì»¬ ì»¨í…ì¸  í´ë” '__path__'ì˜ ëª¨ë“  ë‚´ìš© ì‹ë³„ ì¤‘...","statusBar.bundleContentsIdentified":"'__path__' ë‚´ íŒŒì¼/í´ë” __count__ê°œ ì‚­ì œ ëŒ€ìƒìœ¼ë¡œ í‘œì‹œ ì™„ë£Œ.","statusBar.bundleContentsCheckFailed":"ì˜¤ë¥˜ - '__path__' ë¡œì»¬ ì»¨í…ì¸  ë‚´ìš© ì‹ë³„ ì‹¤íŒ¨. ì‚­ì œê°€ ë¶ˆì™„ì „í•  ìˆ˜ ìˆìŒ.","statusBar.creatingBlobs":"__count__ê°œ íŒŒì¼ Blob ìƒì„± ì¤‘...","statusBar.creatingTree":"Tree ê°ì²´ ìƒì„± ì¤‘...","statusBar.creatingCommit":"Commit ê°ì²´ ìƒì„± ì¤‘...","statusBar.updatingRef":"ë¸Œëœì¹˜ ì°¸ì¡° ì—…ë°ì´íŠ¸ ì¤‘...","statusBar.commitFailed":"ì»¤ë°‹ ì‹¤íŒ¨ (ë‹¨ê³„: __step__). ì½˜ì†” í™•ì¸ í•„ìš”.","statusBar.searchingContent":"'__slug__' ì»¨í…ì¸  ê²€ìƒ‰ ì¤‘...","statusBar.searchAttempt":"'__path__' ê²€ìƒ‰ ì‹œë„ ì¤‘...","statusBar.contentNotFound":"'__slug__' ì»¨í…ì¸ ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŒ (index.md, _index.md, .md ì‹œë„í•¨).","statusBar.infoPrefix":"ì •ë³´:","statusBar.patChangedLogout":"ì €ì¥ëœ í† í°ì´ ë³€ê²½ë˜ì–´ ë¡œê·¸ì•„ì›ƒí•©ë‹ˆë‹¤. ë‹¤ì‹œ ë¡œê·¸ì¸í•´ì£¼ì„¸ìš”.","statusBar.identifyingBranchIndexResources":"ì •ë³´: ë¸Œëœì¹˜ ì¸ë±ìŠ¤ ì‚­ì œë¥¼ ìœ„í•œ ë¦¬ì†ŒìŠ¤ ì‹ë³„ ì¤‘: __filePath__","statusBar.markedFileForDeletion":"ì •ë³´: íŒŒì¼ ì‚­ì œ ëŒ€ìƒìœ¼ë¡œ í‘œì‹œ: __filename__","statusBar.noInitialLinksFound":"ì •ë³´: ì´ _index.mdì— ëŒ€í•œ ì´ˆê¸° ë§í¬ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.","statusBar.noAssociatedAssetsFound":"ì •ë³´: ì´ˆê¸° ë§í¬ ê¸°ë°˜ ì—°ê´€ ì—ì…‹ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.","statusBar.legacyAssetDirNotFound":"ì •ë³´: ì—°ê´€ëœ ì „ì—­ ì—ì…‹ í´ë” '__path__'ì„(ë¥¼) ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.","statusBar.legacyAssetDirEmpty":"ì •ë³´: ì—°ê´€ëœ ì „ì—­ ì—ì…‹ í´ë” '__path__'ì´(ê°€) ë¹„ì–´ ìˆìŠµë‹ˆë‹¤.","statusBar.loadingStoredRepo":"ì €ì¥ëœ ì €ì¥ì†Œ '__repo__' ë¡œë”© ì¤‘...","statusBar.loadingRepoList":"ì €ì¥ì†Œ ëª©ë¡ ë¡œë”© ì¤‘...",logoutButton:"ë¡œê·¸ì•„ì›ƒ","prompts.confirmDelete":"ì •ë§ë¡œ '__filename__' íŒŒì¼ì„ ì˜êµ¬ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?","prompts.confirmDeleteBundle":`ë¡œì»¬ ì»¨í…ì¸  (í˜ì´ì§€ ë²ˆë“¤)ì…ë‹ˆë‹¤!

ì •ë§ë¡œ '__bundleName__' í´ë”ì™€ ê·¸ ì•ˆì˜ ëª¨ë“  ë‚´ìš©(ì´ë¯¸ì§€, ê¸°íƒ€ ì—ì…‹ í¬í•¨)ì„ ì˜êµ¬ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?`,"prompts.confirmDeleteBranchBundleIndex":`ë¸Œëœì¹˜ ì¸ë±ìŠ¤ íŒŒì¼ '__filename__'ì„(ë¥¼) ì‚­ì œí•˜ë ¤ê³  í•©ë‹ˆë‹¤. ì´ íŒŒì¼ ë‚´ì— ë§í¬ëœ ì—ì…‹ íŒŒì¼ë“¤ë„ í•¨ê»˜ ì‚­ì œë  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

í•˜ì§€ë§Œ '__bundleName__' í´ë”ì™€ ê·¸ ì•ˆì˜ ë‹¤ë¥¸ íŒŒì¼/í´ë”ë“¤ì€ ì‚­ì œë˜ì§€ ì•ŠìŠµë‹ˆë‹¤.

ì´ ì‘ì—…ì€ ë˜ëŒë¦´ ìˆ˜ ì—†ìŠµë‹ˆë‹¤!`,"prompts.confirmDeleteDetail":"ì´ ì‘ì—…ì€ ë˜ëŒë¦´ ìˆ˜ ì—†ìŠµë‹ˆë‹¤!","prompts.confirmCancel":"ì €ì¥ë˜ì§€ ì•Šì€ ë³€ê²½ ì‚¬í•­ì´ ìˆìŠµë‹ˆë‹¤. ì €ì¥í•˜ì§€ ì•Šê³  ê³„ì†í•˜ì‹œê² ìŠµë‹ˆê¹Œ?","prompts.cancelAbort":"ì·¨ì†Œ ì‘ì—… ì¤‘ë‹¨ë¨.","prompts.deleteCancelled":"íŒŒì¼ ì‚­ì œ ì·¨ì†Œë¨.","errors.patRequired":"GitHub PATë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”.","errors.invalidRepo":"ìœ íš¨í•œ ì €ì¥ì†Œë¥¼ ì„ íƒí•´ì£¼ì„¸ìš”.","errors.apiError":"API ì˜¤ë¥˜: __message__","errors.authFailed":"GitHub ì¸ì¦ ì‹¤íŒ¨","errors.repoListFailed":"ì €ì¥ì†Œ ëª©ë¡ ë¡œë”© ì‹¤íŒ¨","errors.folderLoadFailed":"í´ë” ë‚´ìš© ë¡œë“œ ì‹¤íŒ¨ (__path__)","errors.fileLoadFailed":"íŒŒì¼ ë‚´ìš© ë¡œë”© ì‹¤íŒ¨ (__path__)","errors.saveFailed":"íŒŒì¼ ì €ì¥ ì‹¤íŒ¨","errors.deleteFailed":"ì‚­ì œ ì‹¤íŒ¨","errors.deleteFailedResource":"'__path__' ì‚­ì œ ì‹¤íŒ¨","errors.yamlParseError":"Front Matter (YAML) íŒŒì‹± ì˜¤ë¥˜: __message__. ì›ë³¸ ë‚´ìš© ìœ ì§€.","errors.tomlParseError":"Front Matter (TOML) íŒŒì‹± ì˜¤ë¥˜: __message__. ì›ë³¸ ë‚´ìš© ìœ ì§€.","errors.yamlFormatError":"Front Matter (YAML) ìƒì„± ì˜¤ë¥˜: __message__","errors.tomlFormatError":"Front Matter (TOML) ìƒì„± ì˜¤ë¥˜: __message__","errors.networkError":"ë„¤íŠ¸ì›Œí¬ ì˜¤ë¥˜ ë˜ëŠ” GitHub API ì—°ê²° ë¶ˆê°€.","errors.unknownError":"ì˜ˆìƒì¹˜ ëª»í•œ ì˜¤ë¥˜ ë°œìƒ. __message__","errors.titleRequired":"'Title'ì€ í•„ìˆ˜ í•­ëª©ì…ë‹ˆë‹¤.","errors.invalidFilename":"ìœ íš¨í•œ íŒŒì¼ëª…/ê²½ë¡œ í•„ìš” (ì˜ˆ: name.md ë˜ëŠ” folder/index.md).","errors.commitMsgRequired":"ì»¤ë°‹ ë©”ì‹œì§€ê°€ í•„ìš”í•©ë‹ˆë‹¤.","errors.invalidDate":"ë‚ ì§œ í˜•ì‹ ì˜¤ë¥˜. 'YYYY-MM-DD HH:MM' í˜•ì‹ì„ ì‚¬ìš©í•˜ê±°ë‚˜ ë‹¬ë ¥ì—ì„œ ì„ íƒí•˜ì„¸ìš”.","errors.invalidCustomFieldType":"ì¶”ê°€ í•„ë“œ '__key__'ì˜ ì„ íƒëœ íƒ€ì…ì— ëŒ€í•œ ê°’ì´ ìœ íš¨í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.","errors.vditorInitFailed":"Markdown í¸ì§‘ê¸°(Vditor) ì´ˆê¸°í™” ì‹¤íŒ¨.","errors.vditorGetValueFailed":"Vditor ë‚´ìš© ê°€ì ¸ì˜¤ê¸° ì˜¤ë¥˜.","errors.vditorSetValueFailed":"Vditor ë‚´ìš© ì„¤ì • ì˜¤ë¥˜.","errors.imageUploadFailed":"íŒŒì¼ ì»¤ë°‹ ì¤€ë¹„ ì¤‘ ì˜¤ë¥˜ ë°œìƒ: __message__","errors.folderNotFound":"ë¦¬ì†ŒìŠ¤ '__path__' ì°¾ì„ ìˆ˜ ì—†ìŒ.","errors.fileNotFoundInFolder":"'__dirPath__' í´ë” ë‚´ì—ì„œ íŒŒì¼ '__filename__'ì„(ë¥¼) ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.","errors.genericApiError":"__context__ (ì½”ë“œ: __code__): __message__","errors.authError":"__context__ (ì½”ë“œ: 401): ì¸ì¦ ì˜¤ë¥˜. PATê°€ ìœ íš¨í•˜ì§€ ì•Šê±°ë‚˜ ë§Œë£Œë˜ì—ˆì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.","errors.permissionError":"__context__ (Code: 403): ê¶Œí•œ ì˜¤ë¥˜. PATì— 'repo' ê¶Œí•œì´ ì—†ê±°ë‚˜ API ì†ë„ ì œí•œì¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤.","errors.rateLimit":" GitHub API ì†ë„ ì œí•œ ë„ë‹¬. ì ì‹œ í›„ ë‹¤ì‹œ ì‹œë„.","errors.repoAccessDenied":" PATì— ì €ì¥ì†Œ ì ‘ê·¼ ê¶Œí•œ ì—†ìŒ (SSO/ê¶Œí•œ).","errors.notFoundError":"404 ì˜¤ë¥˜: ë¦¬ì†ŒìŠ¤ '__path__' ì°¾ì„ ìˆ˜ ì—†ìŒ.","errors.conflictError":"__context__ (Code: 409): ì¶©ëŒ ì˜¤ë¥˜ (SHA ë¶ˆì¼ì¹˜ ë˜ëŠ” ë¸Œëœì¹˜ ì—…ë°ì´íŠ¸ ë¬¸ì œ). ìƒˆë¡œê³ ì¹¨ í›„ ì¬ì‹œë„.","errors.unprocessableError":"__context__ (Code: 422): ì²˜ë¦¬ ë¶ˆê°€ ì—”í‹°í‹°. ì»¤ë°‹ ë°ì´í„° ì˜¤ë¥˜ (tree/blob?). __message__","errors.unexpectedErrorContext":"__context__: ì˜ˆìƒì¹˜ ëª»í•œ ì˜¤ë¥˜. __message__","errors.urlParseFailed":"ì˜¤ë¥˜: URL ê²½ë¡œ íŒŒì‹± ì‹¤íŒ¨. ê¸°ë³¸ ëª¨ë“œë¡œ ì‹œì‘í•©ë‹ˆë‹¤.","errors.repoNotSet":"ì˜¤ë¥˜: ì €ì¥ì†Œ ì •ë³´ ì—†ìŒ.","errors.missingBlob":"APIë¡œë¶€í„° ì˜ëª»ëœ blob ë°ì´í„°ë¥¼ ë°›ì•˜ìŠµë‹ˆë‹¤.","errors.largeFileWarn":"ê²½ê³ : íŒŒì¼ í¬ê¸°(__sizeMB__ MB)ê°€ 1MBë¥¼ ì´ˆê³¼í•©ë‹ˆë‹¤. ë¡œë”©/ì €ì¥ì´ ëŠë¦´ ìˆ˜ ìˆìŠµë‹ˆë‹¤.","errors.noAuth":"ì¸ì¦ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.","errors.missingContext":"ì¸ì¦ ë˜ëŠ” ì €ì¥ì†Œ ì»¨í…ìŠ¤íŠ¸ê°€ ì—†ìŠµë‹ˆë‹¤.","errors.base64Encode":"Base64 ì¸ì½”ë”© ì¤‘ ì˜¤ë¥˜ ë°œìƒ.","errors.base64Decode":"Base64 ë˜ëŠ” UTF-8 ë””ì½”ë”© ì¤‘ ì˜¤ë¥˜ ë°œìƒ: __message__","errors.invalidDateForFlatpickr":"ê²½ê³ : ë‚ ì§œ '__date__' í˜•ì‹ì„ ì¸ì‹/ë³€í™˜í•˜ì§€ ëª»í–ˆìŠµë‹ˆë‹¤. ì›ë³¸ ê°’ì„ í‘œì‹œí•©ë‹ˆë‹¤.","errors.customKeyConflict":"ê²½ê³ : ì‚¬ìš©ì ì •ì˜ í‚¤ '__key__'ê°€ ê¸°ë³¸ í•„ë“œì™€ ì¶©ëŒ/ì¤‘ë³µë˜ì–´ ë¬´ì‹œë©ë‹ˆë‹¤.","errors.vditorNotReady":"Vditor ì¸ìŠ¤í„´ìŠ¤ê°€ ì¤€ë¹„ë˜ì§€ ì•Šì•˜ê±°ë‚˜ ì‚¬ìš©í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.","errors.vditorFocus":"Vditor í¸ì§‘ê¸° í¬ì»¤ìŠ¤ ì¤‘ ì˜¤ë¥˜.","errors.titleFocus":"ì œëª© ì…ë ¥ í•„ë“œ í¬ì»¤ìŠ¤ ì¤‘ ì˜¤ë¥˜.","errors.vditorTheme":"Vditor í…Œë§ˆ ë™ì  ì„¤ì • ì¤‘ ì˜¤ë¥˜.","errors.vditorDestroy":"ì´ì „ Vditor ì¸ìŠ¤í„´ìŠ¤ ì œê±° ì¤‘ ì˜¤ë¥˜.","errors.appInit":"ì˜¤ë¥˜: ì• í”Œë¦¬ì¼€ì´ì…˜ ì´ˆê¸°í™” ì‹¤íŒ¨.","errors.appLoad":"ì•± ë¡œë“œ ì˜¤ë¥˜","errors.appError":"ì• í”Œë¦¬ì¼€ì´ì…˜ ì˜¤ë¥˜: __message__","errors.scriptError":"ìŠ¤í¬ë¦½íŠ¸ ì˜¤ë¥˜. ì½˜ì†” í™•ì¸.","errors.blobUrl":"Blob URL ìƒì„± ì˜¤ë¥˜.","errors.previewGenFailed":"ì˜¤ë¥˜: __filename__ í”Œë ˆì´ìŠ¤í™€ë” ìƒì„± ì‹¤íŒ¨.","errors.noFileToUpload":"ì—…ë¡œë“œí•  íŒŒì¼ ì—†ìŒ.","errors.notLoggedInForUpload":"íŒŒì¼ ì¤€ë¹„ ì˜¤ë¥˜: GitHubì— ë¡œê·¸ì¸ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.","errors.shaFetchFailed":"íŒŒì¼ __path__ ì •ë³´ ê°€ì ¸ì˜¤ê¸° ì‹¤íŒ¨: __reason__","errors.imageDeleteFailed":"íŒŒì¼ __path__ ì‚­ì œ ëŒ€ìƒìœ¼ë¡œ í‘œì‹œ ì‹¤íŒ¨: __reason__","errors.imageUploadFailedGeneric":"íŒŒì¼ ì»¤ë°‹ ì¤€ë¹„ ì‹¤íŒ¨. ì €ì¥ì„ ì§„í–‰í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.","errors.imageUploadFailedGenericWithMessage":"íŒŒì¼ ì»¤ë°‹ ì¤€ë¹„ ì‹¤íŒ¨: __message__","errors.noFileToDelete":"ì‚­ì œí•  íŒŒì¼ì´ ì„ íƒë˜ê±°ë‚˜ ë¡œë“œë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.","errors.deleteException":"ì‚­ì œ ì»¤ë°‹ ê³¼ì • ì¤‘ ì˜ˆìƒì¹˜ ëª»í•œ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.","errors.saveException":"ì €ì¥ ì»¤ë°‹ ê³¼ì • ì¤‘ ì˜ˆìƒì¹˜ ëª»í•œ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.","errors.fileEditPrepException":"íŒŒì¼ í¸ì§‘ ì¤€ë¹„ ì¤‘ ì˜¤ë¥˜: __path__","errors.fileSearchLoadFailed":"íŒŒì¼ ê²€ìƒ‰ ì¤‘ ì˜¤ë¥˜: __path__","errors.folderBrowseException":"í´ë” íƒìƒ‰ ì¤‘ ì˜¤ë¥˜: __path__","errors.browserErrorLoadingSevere":"í´ë” ë‚´ìš© ë¡œë“œ ì¤‘ ì‹¬ê°í•œ ì˜¤ë¥˜ ë°œìƒ. ì½˜ì†” í™•ì¸.","errors.urlActionFailed":"URL ì‘ì—… ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜ ë°œìƒ","errors.noAccessibleRepos":"ì ‘ê·¼ ê°€ëŠ¥í•œ ì €ì¥ì†Œê°€ ì—†ìŠµë‹ˆë‹¤.","errors.commitFailed":"ì»¤ë°‹ í”„ë¡œì„¸ìŠ¤ ì‹¤íŒ¨: __step__","errors.bundleContentsCheckFailed":"'__path__' ë¡œì»¬ ì»¨í…ì¸  ë‚´ìš© ì‚­ì œ ì‹ë³„ ì‹¤íŒ¨: __message__","errors.deleteBundleException":"'__path__' ë¡œì»¬ ì»¨í…ì¸  ì‚­ì œ ì¤€ë¹„ ì¤‘ ì˜ˆìƒì¹˜ ëª»í•œ ì˜¤ë¥˜ ë°œìƒ.","errors.contentSearchFailed":"'__slug__' ì»¨í…ì¸  ê²€ìƒ‰ ì˜¤ë¥˜: __message__","errors.searchParentDirNotFound":"'__slug__' ê²€ìƒ‰ ì¤‘ ìƒìœ„ í´ë” '__dirPath__' ì°¾ì„ ìˆ˜ ì—†ìŒ.","errors.markdownTransformError":"ë§ˆí¬ë‹¤ìš´ ê²½ë¡œ ë³€í™˜ ì¤‘ ì˜¤ë¥˜.","errors.markdownRestoreError":"ë§ˆí¬ë‹¤ìš´ ê²½ë¡œ ë³µì› ì¤‘ ì˜¤ë¥˜.","errors.legacyDirCheckFailed":"ì˜¤ë¥˜ - '__path__' ì—°ê´€ ì „ì—­ ì—ì…‹ ì‹ë³„ ì‹¤íŒ¨: __message__","errors.contextualNetworkError":"__context__: ë„¤íŠ¸ì›Œí¬ ì˜¤ë¥˜ ë˜ëŠ” GitHub API ì—°ê²° ë¶ˆê°€.","errors.storedRepoLoadFailed":"ì €ì¥ëœ ì €ì¥ì†Œ '__repo__' ë¡œë“œ ì‹¤íŒ¨. ì ‘ê·¼ ê¶Œí•œ í™•ì¸ ë˜ëŠ” ì¬ì„ íƒ í•„ìš”.","errors.customKeyConflictSaveBlock":"ì»¤ìŠ¤í…€ í‚¤ '__key__'ëŠ” ê¸°ë³¸ í•„ë“œì™€ ì¶©ëŒí•˜ì—¬ ì‚¬ìš©í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤. í‚¤ ì´ë¦„ì„ ìˆ˜ì •í•´ì£¼ì„¸ìš”.","errors.customKeyDuplicate":"ì»¤ìŠ¤í…€ í•„ë“œì— ì¤‘ë³µëœ í‚¤ '__key__'ê°€ ìˆìŠµë‹ˆë‹¤. ì¤‘ë³µëœ í•„ë“œë¥¼ ì œê±°í•˜ê±°ë‚˜ í‚¤ ì´ë¦„ì„ ìˆ˜ì •í•´ì£¼ì„¸ìš”.","errors.lastmodBeforeDate":"LastmodëŠ” Dateë³´ë‹¤ ì´ì „ì¼ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ë‚ ì§œë¥¼ ìˆ˜ì •í•´ì£¼ì„¸ìš”."}}}</script><script>window.hugoPermalinkMap={};try{window.hugoPermalinkMap=JSON.parse('{"admin":"admin","archive":"archive","new":"new","posts/a-walk-in-the-rain":"blog/2024/a-walk-in-the-rain-with-an-umbrella","posts/baking-bread-for-the-first-time":"blog/2023/baking-bread-for-the-first-time","posts/cozy-evening-with-book-and-blanket":"blog/2023/a-cozy-evening-with-a-book-and-blanket","posts/creating-a-vision-board-for-goals":"blog/2025/creating-a-vision-board-for-goals","posts/decluttering-digital-files":"blog/2025/decluttering-digital-files","posts/emoji-support":"blog/2025/emoji-support","posts/exploring-new-city-on-foot":"blog/2024/exploring-a-new-city-on-foot","posts/finding-inspriattion-in-nature":"blog/2023/finding-inspiration-in-nature","posts/first-snowfall-of-the-year":"blog/2023/first-snowfall-of-the-year","posts/gardening-updates-spring-is-coming":"blog/2024/gardening-updates-spring-is-coming","posts/important-of-saying-no":"blog/1","posts/learing-from-feeback-even-whe-its-hard":"blog/2024/learning-from-feedback-even-when-its-hard","posts/learning-new-language-challenges":"blog/2024/learning-a-new-language-challenges","posts/listening-to-vinyl-records":"blog/2023/listening-to-vinyl-records","posts/making-homemade-pizza":"blog/2024/making-homemade-pizza","posts/markdown-test-hehe":"blog/2025/markdown-test","posts/morining-meditation-practice":"blog/2024/morning-meditation-practice","posts/placeholder-text":"blog/2025/placeholder-text","posts/planning-th-next-project":"blog/2023/planning-the-next-project","posts/setting-up-a-new-development-environment":"blog/2024/setting-up-a-new-development-environment","posts/the-beauty-of=imperection":"blog/2024/the-beauty-of-imperfection-wabi-sabi","posts/the-benefits-of-walking-barefoot-on-grass":"blog/2024/the-benefits-of-walking-barefoot-on-grass-earthing","posts/the-challenge-of-staying-focused-in-a-distraced-world":"blog/2023/the-challenge-of-staying-focused-in-a-distracted-world","posts/the-importance-of-active-listening":"blog/2024/the-importance-of-active-listening","posts/the-joy-of-rediscovering-old-music":"blog/2024/the-joy-of-rediscovering-old-music","posts/the-power-of-good-nights-sleep":"blog/2023/the-power-of-a-good-nights-sleep","posts/the-satisfaction-of-crossing-things-off-a-todo-list":"blog/2023/the-satisfaction-of-crossing-things-off-a-to-do-list","posts/the-simple-pleasure-of-clean-deks":"blog/2023/the-simple-pleasure-of-a-clean-desk","posts/thoughts-on-creativity-and-inspiration":"blog/2024/thoughts-on-creativity-and-inspiration","posts/trying-mind-mapping-for-ideas":"blog/2024/trying-mind-mapping-for-ideas","posts/trying-out-new-productitity-app":"blog/2024/trying-out-a-new-productivity-app","posts/visit-to-the-art-museum":"blog/2025/a-visit-to-the-art-museum","posts/ê¹€ì¹˜ì°Œê°œ-ë§›ìˆê²Œ-ë“ì´ëŠ”-ë²•":"blog/2024/%EA%B9%80%EC%B9%98%EC%B0%8C%EA%B0%9C-%EB%A7%9B%EC%9E%88%EA%B2%8C-%EB%81%93%EC%9D%B4%EB%8A%94-%EB%B2%95","posts/ë‚˜ë§Œì˜-ìŠ¤íŠ¸ë ˆìŠ¤-í•´ì†Œë²•":"blog/2024/%EB%82%98%EB%A7%8C%EC%9D%98-%EC%8A%A4%ED%8A%B8%EB%A0%88%EC%8A%A4-%ED%95%B4%EC%86%8C%EB%B2%95","posts/ëŠ¦ê°€ì„ì˜-ì“¸ì“¸í•¨ê³¼-ì•„ë¦„ë‹¤ì›€":"blog/2023/%EB%8A%A6%EA%B0%80%EC%9D%84%EC%9D%98-%EC%93%B8%EC%93%B8%ED%95%A8%EA%B3%BC-%EC%95%84%EB%A6%84%EB%8B%A4%EC%9B%80","posts/ë™ë„¤-ì„œì -íƒë°©ê¸°":"blog/2024/%EB%8F%99%EB%84%A4-%EC%84%9C%EC%A0%90-%ED%83%90%EB%B0%A9%EA%B8%B0","posts/ë”°ëœ»í•œ-ë±…ì‡¼-ë§Œë“¤ê¸°":"blog/2023/%EB%94%B0%EB%9C%BB%ED%95%9C-%EB%B1%85%EC%87%BC-%EB%A7%8C%EB%93%A4%EA%B8%B0","posts/ë”°ëœ»í•œ-ë´„ë‚ ì˜-ìì „ê±°-íƒ€ê¸°":"blog/2022/%EB%94%B0%EB%9C%BB%ED%95%9C-%EB%B4%84%EB%82%A0%EC%9D%98-%EC%9E%90%EC%A0%84%EA%B1%B0-%ED%83%80%EA%B8%B0","posts/ë©í•˜ë‹ˆ-ë°”ë¼ë³¸-í•˜ëŠ˜":"blog/2023/%EB%A9%8D%ED%95%98%EB%8B%88-%EB%B0%94%EB%9D%BC%EB%B3%B8-%ED%95%98%EB%8A%98","posts/ë³´ë“œê²Œì„-í•˜ëŠ”-ë°¤":"blog/2023/%EB%B3%B4%EB%93%9C%EA%B2%8C%EC%9E%84-%ED%95%98%EB%8A%94-%EB%B0%A4","posts/ë´„ë§ì´-ì˜·ì¥-ì •ë¦¬":"blog/2024/%EB%B4%84%EB%A7%9E%EC%9D%B4-%EC%98%B7%EC%9E%A5-%EC%A0%95%EB%A6%AC","posts/ìƒˆí•´-ë‹¤ì§ê³¼-ëª©í‘œ-ì„¤ì •":"blog/2024/%EC%83%88%ED%95%B4-%EB%8B%A4%EC%A7%90%EA%B3%BC-%EB%AA%A9%ED%91%9C-%EC%84%A4%EC%A0%95","posts/ì†í¸ì§€-ì“°ê¸°":"blog/2023/%EC%86%90%ED%8E%B8%EC%A7%80-%EC%93%B0%EA%B8%B0","posts/ì‹œì¥-êµ¬ê²½ê³¼-ê¸¸ê±°ë¦¬-ìŒì‹":"blog/2024/the-importance-of-saying-no","posts/ì˜¤ë˜ëœ-ë¬¼ê±´ì—-ë‹´ê¸´-ì´ì•¼ê¸°":"blog/2023/%EC%98%A4%EB%9E%98%EB%90%9C-%EB%AC%BC%EA%B1%B4%EC%97%90-%EB%8B%B4%EA%B8%B4-%EC%9D%B4%EC%95%BC%EA%B8%B0","posts/ì˜¤ëœë§Œì—-ë§Œë‚œ-ì¹œêµ¬":"blog/2023/%EC%98%A4%EB%9E%9C%EB%A7%8C%EC%97%90-%EB%A7%8C%EB%82%9C-%EC%B9%9C%EA%B5%AC","posts/ìš´ë™-ë‹¤ì‹œ-ì‹œì‘í•˜ê¸°":"blog/2023/%EC%9A%B4%EB%8F%99-%EB%8B%A4%EC%8B%9C-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0","posts/ì €ë…-ë…¸ì„ì´-ì•„ë¦„ë‹¤ìš´-ë‚ ":"blog/2023/%EC%A0%80%EB%85%81-%EB%85%B8%EC%9D%84%EC%9D%B4-%EC%95%84%EB%A6%84%EB%8B%A4%EC%9A%B4-%EB%82%A0","posts/ì €ë…-ì‚°ì±…ê¸¸ì—-ë§Œë‚œ-ê³ ì–‘ì´":"blog/2023/%EC%A0%80%EB%85%81-%EC%82%B0%EC%B1%85%EA%B8%B8%EC%97%90-%EB%A7%8C%EB%82%9C-%EA%B3%A0%EC%96%91%EC%9D%B4","posts/ì œì£¼ë„-ì—¬í–‰-ì¤€ë¹„":"blog/2023/%EC%A0%9C%EC%A3%BC%EB%8F%84-%EC%97%AC%ED%96%89-%EC%A4%80%EB%B9%84","posts/ì¡°ì¡°ì˜í™”-ë³´ê¸°":"blog/2023/%EC%A1%B0%EC%A1%B0%EC%98%81%ED%99%94-%EB%B3%B4%EA%B8%B0","posts/ì£¼ë§-ë†ì¥-ê°€ê¾¸ê¸°":"blog/2024/%EC%A3%BC%EB%A7%90-%EB%86%8D%EC%9E%A5-%EA%B0%80%EA%BE%B8%EA%B8%B0","posts/ì£¼ë§-ëŒ€ì²­ì†Œ-í›„ê¸°":"blog/2023/%EC%A3%BC%EB%A7%90-%EB%8C%80%EC%B2%AD%EC%86%8C-%ED%9B%84%EA%B8%B0","posts/ì§‘ì—ì„œ-í‚¤ìš°ëŠ”-ë°˜ë ¤ì‹ë¬¼":"blog/2023/%EC%A7%91%EC%97%90%EC%84%9C-%ED%82%A4%EC%9A%B0%EB%8A%94-%EB%B0%98%EB%A0%A4%EC%8B%9D%EB%AC%BC","posts/ì°½ë°–ìœ¼ë¡œ-ë³´ì´ëŠ”-í’ê²½":"blog/2024/%EC%B0%BD%EB%B0%96%EC%9C%BC%EB%A1%9C-%EB%B3%B4%EC%9D%B4%EB%8A%94-%ED%92%8D%EA%B2%BD","posts/í‡´ê·¼ê¸¸-ì§€í•˜ì² ì—ì„œ":"blog/2023/%ED%87%B4%EA%B7%BC%EA%B8%B8-%EC%A7%80%ED%95%98%EC%B2%A0%EC%97%90%EC%84%9C","posts/í–‡ì‚´-ì¢‹ì€-ë‚ ì˜-ê³µì›":"blog/2024/%ED%96%87%EC%82%B4-%EC%A2%8B%EC%9D%80-%EB%82%A0%EC%9D%98-%EA%B3%B5%EC%9B%90","posts/íë¦°-ë‚ ì˜-ë§¤ë ¥":"blog/2023/%ED%9D%90%EB%A6%B0-%EB%82%A0%EC%9D%98-%EB%A7%A4%EB%A0%A5","test/markdown-syntax":"test/markdown-syntax","test/math-typesetting":"test/math-typesetting","test/placeholder-text":"test/placeholder-text","test/rich-content":"test/rich-content"}')}catch{window.hugoPermalinkMap={}}</script><script type=module>
        import { Octokit } from "https://esm.sh/octokit";
        import { marked } from 'https://esm.sh/marked';
        import Vditor from 'https://esm.sh/vditor';
        import * as jsyaml from 'https://esm.sh/js-yaml@4';
        import * as TOML from 'https://cdn.jsdelivr.net/npm/@iarna/toml@2.2.5/+esm';
        import i18next from 'https://esm.sh/i18next';
        import flatpickr from 'https://esm.sh/flatpickr';
        import { Korean } from 'https://esm.sh/flatpickr/dist/l10n/ko.js';
        import { Mandarin as Chinese } from 'https://esm.sh/flatpickr/dist/l10n/zh.js';
        import { Japanese } from 'https://esm.sh/flatpickr/dist/l10n/ja.js';
        import { Spanish } from 'https://esm.sh/flatpickr/dist/l10n/es.js';
        import { German } from 'https://esm.sh/flatpickr/dist/l10n/de.js';
        import { French } from 'https://esm.sh/flatpickr/dist/l10n/fr.js';
        import { Portuguese } from 'https://esm.sh/flatpickr/dist/l10n/pt.js';
        import { Russian } from 'https://esm.sh/flatpickr/dist/l10n/ru.js';
        import path from 'https://esm.sh/path-browserify';
        import isEqual from 'https://esm.sh/fast-deep-equal';
        import Tagify from 'https://cdn.jsdelivr.net/npm/@yaireo/tagify/+esm';
        const AppConstants = {
            PAT_STORAGE_KEY: 'githubPat',
            SELECTED_REPO_KEY: 'selectedGitHubRepo',
            STANDARD_FM_KEYS: [
                'title', 'author', 'date', 'lastmod', 'description', 'tags', 'categories', 'draft'
            ],
            SUPPORTED_LANGUAGES: [
                { code: 'en', name: 'English', flatpickr: 'en' },
                { code: 'ko', name: 'Korean', flatpickr: 'ko' },
                { code: 'zh', name: 'ä¸­æ–‡ (ç®€ä½“)', flatpickr: 'zh' },
                { code: 'ja', name: 'æ—¥æœ¬èª', flatpickr: 'ja' },
                { code: 'es', name: 'EspaÃ±ol', flatpickr: 'es' },
                { code: 'de', name: 'Deutsch', flatpickr: 'de' },
                { code: 'fr', name: 'FranÃ§ais', flatpickr: 'fr' },
                { code: 'pt', name: 'PortuguÃªs', flatpickr: 'pt' },
                { code: 'ru', name: 'Ğ ÑƒÑÑĞºĞ¸Ğ¹', flatpickr: 'ru' },
            ],
            ACTIVE_EDIT_CLASS: 'active-edit-item',
            CUSTOM_FM_TYPES: [
                { value: 'string', labelKey: 'editor.fm.typeString', inputType: 'text' },
                { value: 'number', labelKey: 'editor.fm.typeNumber', inputType: 'text', inputMode: 'numeric' },
                { value: 'boolean', labelKey: 'editor.fm.typeBoolean', inputType: 'checkbox' },
                { value: 'date', labelKey: 'editor.fm.typeDate', inputType: 'text', isDate: true },
                { value: 'array', labelKey: 'editor.fm.typeArrayString', inputType: 'text' }
            ],
        };
        const FM_FIELD_CONFIG = [
            { key: 'title', type: 'string', elementId: 'fmTitleInput', required: true },
            { key: 'date', type: 'datetime', elementId: 'fmDateInput', autoCheckboxId: 'fmDateAutoCheckbox', autoLabelId: 'fmDateAutoLabel' },
            { key: 'lastmod', type: 'datetime', elementId: 'fmLastmodInput', autoCheckboxId: 'fmLastmodAutoCheckbox', autoLabelId: 'fmLastmodAutoLabel' },
            { key: 'author', type: 'string', elementId: 'fmAuthorInput' },
            { key: 'description', type: 'string', elementId: 'fmDescriptionInput' },
            { key: 'tags', type: 'array', elementId: 'fmTagsInput' },
            { key: 'categories', type: 'array', elementId: 'fmCategoriesInput' },
        ];
        const PathUtils = {
            normalizePath: (p) => path.normalize(p || '').replace(/\\/g, '/'),
            joinPaths: (...parts) => PathUtils.normalizePath(path.join(...parts.filter(p => p != null && String(p).trim()))),
            getDirname: (p) => PathUtils.normalizePath(path.dirname(p || '')),
            getBasename: (p) => path.basename(p || ''),
            escapeRegex: (string) => string.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&'),
            isPageBundlePath: (filePath) => typeof filePath === 'string' && filePath.toLowerCase().endsWith('/index.md'),
            isBranchBundlePath: (filePath) => typeof filePath === 'string' && filePath.toLowerCase().endsWith('/_index.md'),
            isAnyBundlePath(filePath) {
                return PathUtils.isPageBundlePath(filePath) || PathUtils.isBranchBundlePath(filePath);
            },
            getBundleDir(bundleIndexPath) {
                return PathUtils.isAnyBundlePath(bundleIndexPath) ? PathUtils.getDirname(bundleIndexPath) : null;
            },
            getSlugFromFilename(filePath) {
                const filename = PathUtils.getBasename(filePath);
                if ((filename === 'index.md' || filename === '_index.md') && filePath.includes('/')) {
                    return PathUtils.getBasename(PathUtils.getDirname(filePath));
                } else if (filename.toLowerCase().endsWith('.md')) {
                    return filename.substring(0, filename.length - 3);
                }
                return filename;
            },
            generateFilename(title) {
                if (!title || !title.trim()) {
                    return 'untitled';
                }
                let slug = title.trim();
                slug = slug.replace(/\s+/g, '-');
                slug = slug.replace(/[^\p{L}\p{N}\-_]/gu, '');
                slug = slug.toLowerCase();
                slug = slug.replace(/-+/g, '-');
                slug = slug.replace(/^-+|-+$/g, '');
                if (!slug || slug.length === 0) {
                    slug = 'untitled';
                } else if (slug.length > 100) {
                    slug = slug.substring(0, 100);
                }
                return slug;
            },
            sanitizeFilename(name) {
                const ext = path.extname(name);
                let baseName = path.basename(name, ext);
                baseName = baseName.replace(/\s+/g, '-');
                baseName = baseName.replace(/[^\p{L}\p{N}\-_\.]/gu, '');
                baseName = baseName.toLowerCase();
                baseName = baseName.replace(/-+/g, '-');
                baseName = baseName.replace(/^-+|-+$/g, '');
                if (!baseName || baseName.length === 0) {
                    baseName = 'file';
                } else if (baseName.length > 200) {
                    baseName = baseName.substring(0, 200);
                }
                return baseName + ext;
            },
            calculateWebBasePath(filePath) {
                const normalizedBasePath = PathUtils.normalizePath(UserSettings.BASE_BROWSE_PATH);
                const normalizedFilePath = PathUtils.normalizePath(filePath);
                let webPath = '/';
                const dirPath = PathUtils.getDirname(normalizedFilePath);
                if (dirPath.startsWith(normalizedBasePath) && dirPath.length >= normalizedBasePath.length) {
                    webPath = (dirPath === normalizedBasePath)
                        ? '/'
                        : `/${dirPath.substring(normalizedBasePath.length + 1).replace(/^\/+|\/+$/g, '')}/`.replace(/\/\/+/g, '/');
                } else {
                    const parts = dirPath.split(path.sep).filter(p => p);
                    webPath = (parts.length > 0)
                        ? `/${parts.join('/')}/`.replace(/\/\/+/g, '/')
                        : '/';
                }
                return webPath;
            },
            transformRelativeToAbsolutePaths(markdown, webBasePath, localAssetSubdir = '') {
                if (!markdown || !webBasePath) return markdown;
                const relativePathRegex = /(!?\[[^\]]*\]\()([^)]+)\)/g;
                const normalizedSubdir = PathUtils.normalizePath(localAssetSubdir);
                const subdirPrefix = normalizedSubdir ? normalizedSubdir + '/' : '';
                const basePath = webBasePath.endsWith('/') ? webBasePath : webBasePath + '/';
                try {
                    return markdown.replace(relativePathRegex, (match, prefix, relativePath) => {
                        let actualRelativePath = relativePath.startsWith('./')
                            ? relativePath.substring(2)
                            : relativePath;
                        if (actualRelativePath.startsWith('/') ||
                            actualRelativePath.startsWith('http') ||
                            actualRelativePath.startsWith('blob:') ||
                            actualRelativePath.startsWith('data:')) {
                            return match;
                        }
                        const suffixWithoutFragment = actualRelativePath.split(/[?#]/)[0];
                        const fragment = actualRelativePath.substring(suffixWithoutFragment.length);
                        return `${prefix}${basePath}${subdirPrefix}${suffixWithoutFragment}${fragment})`;
                    });
                } catch (e) {
                    App.handleGenericError(e, 'errors.markdownTransformError', "Path Transformation");
                    return markdown;
                }
            },
            restoreAbsoluteToRelativePaths(markdown, webBasePath, localAssetSubdir = '') {
                if (!markdown || !webBasePath) return markdown;
                const normalizedSubdir = PathUtils.normalizePath(localAssetSubdir);
                const subdirPrefix = normalizedSubdir ? normalizedSubdir + '/' : '';
                const basePath = webBasePath.endsWith('/') ? webBasePath : webBasePath + '/';
                const escapedBasePath = PathUtils.escapeRegex(basePath + subdirPrefix);
                const absolutePathRegex = new RegExp(`(!?\\[[^\\]]*\\]\\()(${escapedBasePath})([^)]+)\\)`, 'g');
                try {
                    return markdown.replace(absolutePathRegex, (match, prefix, matchedBasePath, suffix) => {
                        const suffixWithoutFragment = suffix.split(/[?#]/)[0];
                        const fragment = suffix.substring(suffixWithoutFragment.length);
                        return `${prefix}${suffixWithoutFragment}${fragment})`;
                    });
                } catch (e) {
                    App.handleGenericError(e, 'errors.markdownRestoreError', "Path Restoration");
                    return markdown;
                }
            },
            calculateBaseTagPath(filePath) {
                const normalizedFilePath = PathUtils.normalizePath(filePath);
                const normalizedBasePath = PathUtils.normalizePath(UserSettings.BASE_BROWSE_PATH);
                const dirPath = PathUtils.getDirname(normalizedFilePath);
                const slug = PathUtils.getSlugFromFilename(normalizedFilePath);
                let relativePathToItemDir = '';
                if (dirPath.startsWith(normalizedBasePath + '/')) {
                    relativePathToItemDir = dirPath.substring(normalizedBasePath.length + 1);
                } else if (dirPath !== normalizedBasePath) {
                    relativePathToItemDir = dirPath;
                }
                const webPathComponent = PathUtils.isAnyBundlePath(normalizedFilePath)
                    ? relativePathToItemDir
                    : PathUtils.joinPaths(relativePathToItemDir, slug);
                return ('/' + PathUtils.normalizePath(webPathComponent) + '/').replace(/\/+/g, '/');
            },
            getMapKeyFromFilePath(filePath) {
                const normalizedFilePath = PathUtils.normalizePath(filePath);
                const normalizedBasePath = PathUtils.normalizePath(UserSettings.BASE_BROWSE_PATH);
                let relativePath = normalizedFilePath;
                if (normalizedBasePath === '' && normalizedFilePath.includes('/')) {
                    relativePath = normalizedFilePath;
                } else if (normalizedBasePath !== '' && normalizedFilePath.startsWith(normalizedBasePath + '/')) {
                    relativePath = normalizedFilePath.substring(normalizedBasePath.length + 1);
                } else if (normalizedBasePath !== '' && normalizedFilePath === normalizedBasePath) {
                    return '';
                } else {
                    relativePath = normalizedFilePath.includes('/') ? normalizedFilePath : normalizedFilePath;
                }
                let key = relativePath;
                if (key.toLowerCase().endsWith('/index.md') || key.toLowerCase().endsWith('/_index.md')) {
                    key = PathUtils.getDirname(key);
                } else if (key.toLowerCase().endsWith('.md')) {
                    key = key.substring(0, key.length - 3);
                }
                return PathUtils.normalizePath(key);
            },
            getMimeTypeFromPath(filePath) {
                const ext = (path.extname(filePath) || '').toLowerCase();
                const mimeTypes = {
                    '.jpg': 'image/jpeg', '.jpeg': 'image/jpeg', '.png': 'image/png',
                    '.gif': 'image/gif', '.svg': 'image/svg+xml', '.webp': 'image/webp',
                    '.pdf': 'application/pdf', '.txt': 'text/plain', '.md': 'text/markdown',
                    '.zip': 'application/zip', '.tar': 'application/x-tar', '.gz': 'application/gzip',
                    '.html': 'text/html', '.css': 'text/css', '.js': 'application/javascript',
                    '.json': 'application/json', '.xml': 'application/xml'
                };
                return mimeTypes[ext] || 'application/octet-stream';
            },
        };
        const EncodingUtils = {
            b64EncodeUnicode(str) {
                try {
                    return btoa(unescape(encodeURIComponent(str)));
                } catch (e) {
                    App.handleGenericError(e, 'errors.base64Encode', "Base64 Encode");
                    throw new Error(i18next.t('errors.base64Encode'));
                }
            },
            b64DecodeUnicode(str) {
                try {
                    atob(str);
                    return decodeURIComponent(escape(atob(str)));
                } catch (e) {
                    const message = i18next.t('errors.base64Decode', { message: e.message });
                    App.handleGenericError(e, message, "Base64 Decode", { stringStart: str.substring(0, 50) });
                    throw new Error(message);
                }
            },
        };
        const FrontMatterUtils = {
            parseFrontMatterAndBody(content) {
                const fmResult = { frontMatter: {}, body: content, type: 'none' };
                const yamlRegex = /^\s*---\s*([\s\S]*?)\s*---(\s*[\s\S]*)/;
                const tomlRegex = /^\s*\+\+\+\s*([\s\S]*?)\s*\+\+\+(\s*[\s\S]*)/;
                let match;
                if ((match = content.match(yamlRegex))) {
                    try {
                        const fmContent = match[1].trim();
                        fmResult.frontMatter = fmContent ? jsyaml.load(fmContent) || {} : {};
                        fmResult.body = match[2] ? match[2].trimStart() : '';
                        fmResult.type = 'yaml';
                    } catch (e) {
                        App.handleGenericError(e, i18next.t('errors.yamlParseError', { message: e.message }), "YAML Parsing");
                        fmResult.frontMatter = {};
                        fmResult.body = content;
                        fmResult.type = 'error';
                    }
                } else if ((match = content.match(tomlRegex))) {
                    try {
                        const fmContent = match[1].trim();
                        fmResult.frontMatter = fmContent ? TOML.parse(fmContent) || {} : {};
                        fmResult.body = match[2] ? match[2].trimStart() : '';
                        fmResult.type = 'toml';
                    } catch (e) {
                        App.handleGenericError(e, i18next.t('errors.tomlParseError', { message: e.message }), "TOML Parsing");
                        fmResult.frontMatter = {};
                        fmResult.body = content;
                        fmResult.type = 'error';
                    }
                }
                if (typeof fmResult.frontMatter !== 'object' || fmResult.frontMatter === null) {
                    fmResult.frontMatter = {};
                }
                return fmResult;
            },
            formatFrontMatterAndBody(frontMatterData, bodyContent) {
                const standardFields = {};
                const customFields = {};
                const fmKeysToProcess = AppConstants.STANDARD_FM_KEYS.filter(k => k !== 'draft');
                fmKeysToProcess.forEach(key => {
                    if (frontMatterData[key] !== undefined && frontMatterData[key] !== null) {
                        if (Array.isArray(frontMatterData[key]) && frontMatterData[key].length === 0) {
                        } else if (typeof frontMatterData[key] === 'string' && frontMatterData[key] === '') {
                        } else {
                            standardFields[key] = frontMatterData[key];
                        }
                    }
                });
                if (frontMatterData.draft === true) {
                    standardFields.draft = true;
                }
                if (frontMatterData.custom && typeof frontMatterData.custom === 'object') {
                    for (const key in frontMatterData.custom) {
                        if (Object.hasOwnProperty.call(frontMatterData.custom, key)) {
                            const trimmedKey = key.trim();
                            if (trimmedKey && !standardFields.hasOwnProperty(trimmedKey) && !AppConstants.STANDARD_FM_KEYS.includes(trimmedKey.toLowerCase())) {
                                let value = frontMatterData.custom[key];
                                if (value !== undefined && value !== null && (typeof value !== 'string' || value !== '') && (!Array.isArray(value) || value.length > 0) ) {
                                    customFields[trimmedKey] = value;
                                }
                            }
                        }
                    }
                }
                const finalFrontMatter = { ...standardFields, ...customFields };
                if (Object.keys(finalFrontMatter).length === 0) {
                    return bodyContent.trim();
                }
                const format = UserSettings.FRONTMATTER_FORMAT.toLowerCase();
                try {
                    if (format === 'yaml') {
                        const yamlString = jsyaml.dump(finalFrontMatter, {
                            skipInvalid: true,
                            indent: 2,
                            lineWidth: -1,
                            noRefs: true,
                            sortKeys: (a, b) => {
                                const order = AppConstants.STANDARD_FM_KEYS;
                                const indexA = order.indexOf(a);
                                const indexB = order.indexOf(b);
                                if (indexA !== -1 && indexB !== -1) return indexA - indexB;
                                if (indexA !== -1) return -1;
                                if (indexB !== -1) return 1;
                                return a.localeCompare(b);
                            }
                        });
                        return `---\n${yamlString.trim()}\n---\n\n${bodyContent.trim()}`;
                    } else if (format === 'toml') {
                        const tomlString = TOML.stringify(finalFrontMatter);
                        return `+++\n${tomlString.trim()}\n+++\n\n${bodyContent.trim()}`;
                    } else {
                        const yamlString = jsyaml.dump(finalFrontMatter);
                        return `---\n${yamlString.trim()}\n---\n\n${bodyContent.trim()}`;
                    }
                } catch (e) {
                    const msgKey = format === 'toml' ? 'errors.tomlFormatError' : 'errors.yamlFormatError';
                    const msg = i18next.t(msgKey, { message: e.message });
                    App.handleGenericError(e, msg, format === 'toml' ? "TOML Formatting" : "YAML Formatting");
                    throw new Error(msg);
                }
            },
        };
        const Utils = {
            readFileAsBase64(file) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = () => resolve(reader.result.split(',')[1]);
                    reader.onerror = error => reject(error);
                    reader.readAsDataURL(file);
                });
            },
            delay: (ms) => new Promise(resolve => setTimeout(resolve, ms)),
            cleanUrl: (url) => (typeof url === 'string' ? url.split(/[?#]/)[0] : url),
            base64ToBlob(base64, type = 'application/octet-stream') {
                const byteCharacters = atob(base64);
                const byteNumbers = new Array(byteCharacters.length);
                for (let i = 0; i < byteCharacters.length; i++) {
                    byteNumbers[i] = byteCharacters.charCodeAt(i);
                }
                const byteArray = new Uint8Array(byteNumbers);
                return new Blob([byteArray], { type });
            },
        };
        const AppState = {
            octokit: null,
            owner: null,
            repo: null,
            currentPath: UserSettings.BASE_BROWSE_PATH,
            branch: UserSettings.DEFAULT_BRANCH,
            flatpickrInstance: null,
            flatpickrLastmodInstance: null,
            initialFmData: {},
            initialBodyContent: '',
            currentFileSha: null,
            currentFilePath: null,
            urlActionPath: null,
            pendingUploads: {},
            draftAssets: {},
            currentLang: UserSettings.DEFAULT_LANGUAGE,
            initialUploadLinks: new Set(),
            isEditingPageBundle: false,
            isEditingBranchBundle: false,
            isEditingAnyBundle: false,
            initialSlugOrFilename: '',
            initialDraftState: false,
            initialHasLastmod: false,
            draftPathsSet: new Set(),
            currentView: 'browse',
            isProcessingVditorInput: false,
            setRepo(owner, repo) {
                this.owner = owner;
                this.repo = repo;
                this.currentPath = UserSettings.BASE_BROWSE_PATH;
            },
            setCurrentPath(p) {
                this.currentPath = PathUtils.normalizePath(p);
            },
            setEditingFile(p, sha, fmData, body, initialLinksSet, initialDraft, initialHasLastmod) {
                this.currentFilePath = PathUtils.normalizePath(p);
                this.currentFileSha = sha;
                this.isEditingPageBundle = PathUtils.isPageBundlePath(this.currentFilePath);
                this.isEditingBranchBundle = PathUtils.isBranchBundlePath(this.currentFilePath);
                this.isEditingAnyBundle = this.isEditingPageBundle || this.isEditingBranchBundle;
                this.initialFmData = JSON.parse(JSON.stringify(fmData));
                this.initialBodyContent = body;
                this.initialUploadLinks = initialLinksSet || new Set();
                this.setCurrentPath(PathUtils.getDirname(this.currentFilePath) || UserSettings.BASE_BROWSE_PATH);
                this.clearPendingUploads();
                this.initialSlugOrFilename = PathUtils.getSlugFromFilename(this.currentFilePath);
                this.initialDraftState = initialDraft;
                this.initialHasLastmod = initialHasLastmod;
                this.currentView = 'edit';
            },
            isDraft: (p) => AppState.draftPathsSet.has(PathUtils.normalizePath(p)),
            clearEditingFile() {
                this.currentFilePath = null;
                this.currentFileSha = null;
                this.initialFmData = {};
                this.initialBodyContent = '';
                this.initialUploadLinks.clear();
                this.clearPendingUploads();
                this.clearDraftAssets();
                this.isEditingPageBundle = false;
                this.isEditingBranchBundle = false;
                this.isEditingAnyBundle = false;
                this.initialSlugOrFilename = '';
                this.initialDraftState = false;
                this.initialHasLastmod = false;
                this.currentView = 'browse';
            },
            clearPendingUploads() {
                Object.keys(this.pendingUploads).forEach(urlKey => {
                    if (urlKey.startsWith('blob:')) {
                        try {
                            URL.revokeObjectURL(urlKey);
                        } catch (e) {
                        }
                    }
                });
                this.pendingUploads = {};
            },
            clearDraftAssets() {
                Object.entries(this.draftAssets).forEach(([relativePath, blobUrl]) => {
                    if (blobUrl && typeof blobUrl === 'string' && blobUrl.startsWith('blob:')) {
                        try {
                            URL.revokeObjectURL(blobUrl);
                        } catch (e) {
                        }
                    }
                });
                this.draftAssets = {};
                if (typeof App !== 'undefined' && App.reverseDraftAssetMap) {
                    App.reverseDraftAssetMap = {};
                }
            },
            isCurrentOperationTargetingLocal() {
                return this.currentFileSha
                    ? this.isEditingAnyBundle
                    : UserSettings.ASSET_STRATEGY === 'local';
            },
            isModified(processedFormData) {
                if (!processedFormData || typeof processedFormData !== 'object') {
                    return true;
                }
                if (!this.currentFileSha) {
                    const bodyHasContent = processedFormData.hasOwnProperty('body') && typeof processedFormData.body === 'string' && processedFormData.body.trim() !== '';
                    const dateAutoChanged = processedFormData.dateAutoChecked !== true;
                    let lastmodAutoChanged = false;
                    if (UIManager.elements.fmLastmodContainer && !UIManager.elements.fmLastmodContainer.classList.contains('hidden')) {
                        lastmodAutoChanged = processedFormData.lastmodAutoChecked !== true;
                    }
                    const hasInitialInput = !!processedFormData.title ||
                        !!processedFormData.fullPathValue ||
                        bodyHasContent ||
                        (Array.isArray(processedFormData.custom) && processedFormData.custom.length > 0) ||
                        Object.keys(this.pendingUploads || {}).length > 0 ||
                        dateAutoChanged ||
                        lastmodAutoChanged;
                    return hasInitialInput;
                }
                let modified = false;
                for (const field of FM_FIELD_CONFIG) {
                    const initialValue = this.initialFmData ? this.initialFmData[field.key] : undefined;
                    const currentValue = processedFormData[field.key];
                    let fieldModified = false;
                    if (field.key === 'date' || field.key === 'lastmod') {
                        const autoCheckbox = UIManager.elements[field.autoCheckboxId];
                        let initialAutoState;
                        if (field.key === 'date') {
                            if (this.initialDraftState && !this.initialHasLastmod) {
                                initialAutoState = true;
                            }
                            else if (!this.initialDraftState && !this.initialHasLastmod) {
                                initialAutoState = false;
                            }
                            else if (this.initialHasLastmod) {
                                initialAutoState = false;
                            }
                            else {
                                initialAutoState = true;
                            }
                        } else {
                            initialAutoState = true;
                        }
                        if (autoCheckbox && processedFormData[`${field.key}AutoChecked`] !== initialAutoState) {
                            fieldModified = true;
                        }
                        if (autoCheckbox && !processedFormData[`${field.key}AutoChecked`]) {
                            const initialDateStr = String(initialValue || '').trim();
                            const currentDateStr = String(currentValue || '').trim();
                            if (initialDateStr !== currentDateStr) {
                                fieldModified = true;
                            }
                        }
                    } else {
                        const initialCompareValue = (field.type === 'array' && Array.isArray(initialValue)) ? [...initialValue].sort() : initialValue;
                        const currentCompareValue = (field.type === 'array' && Array.isArray(currentValue)) ? [...currentValue].sort() : currentValue;
                        if (!isEqual(currentCompareValue, initialCompareValue)) {
                            fieldModified = true;
                        }
                    }
                    if (fieldModified) {
                        modified = true;
                        break;
                    }
                }
                if (modified) return true;
                const initialDraftValue = this.initialFmData ? (this.initialFmData.draft === true) : false;
                let currentDraftValue = initialDraftValue;
                if (processedFormData.hasOwnProperty('draft')) {
                     currentDraftValue = processedFormData.draft === true;
                }
                if (initialDraftValue !== currentDraftValue) {
                    return true;
                }
                const currentCustomForCompare = {};
                if (Array.isArray(processedFormData.custom)) {
                    processedFormData.custom.forEach(item => {
                        if (item && item.key) {
                            let valueToCompare;
                            if (item.type === 'array' && Array.isArray(item.value)) {
                                valueToCompare = [...item.value].sort();
                            } else if (item.type === 'boolean') {
                                valueToCompare = item.value === true;
                            } else if (item.type === 'date') {
                                try {
                                    const parsedDate = flatpickr.parseDate(String(item.value), "Y-m-d H:i:S") ||
                                                       flatpickr.parseDate(String(item.value), "Y-m-d H:i");
                                    if (parsedDate && !isNaN(parsedDate.getTime())) {
                                        valueToCompare = parsedDate.toISOString();
                                    } else {
                                        valueToCompare = String(item.value);
                                    }
                                } catch(e) {
                                    valueToCompare = String(item.value);
                                }
                            } else if (item.type === 'number') {
                                const num = parseFloat(String(item.value));
                                valueToCompare = isNaN(num) ? String(item.value) : num;
                            }
                            else {
                                valueToCompare = String(item.value);
                            }
                            currentCustomForCompare[item.key] = { value: valueToCompare, type: item.type };
                        }
                    });
                }
                const initialCustomForCompare = {};
                if (this.initialFmData && typeof this.initialFmData.custom === 'object') {
                    for (const key in this.initialFmData.custom) {
                        if (Object.hasOwnProperty.call(this.initialFmData.custom, key)) {
                            const initialRawValue = this.initialFmData.custom[key];
                            let initialType = 'string';
                            let initialValueToCompare;
                            if (Array.isArray(initialRawValue)) {
                                initialType = 'array';
                                initialValueToCompare = [...initialRawValue].sort();
                            } else if (typeof initialRawValue === 'boolean') {
                                initialType = 'boolean';
                                initialValueToCompare = initialRawValue === true;
                            } else if (typeof initialRawValue === 'number') {
                                initialType = 'number';
                                initialValueToCompare = initialRawValue;
                            }
                            else if (initialRawValue instanceof Date ||
                                       (typeof initialRawValue === 'string' &&
                                       (flatpickr.parseDate(initialRawValue, "Z") ||
                                        flatpickr.parseDate(initialRawValue, "Y-m-d H:i:S") ||
                                        flatpickr.parseDate(initialRawValue, "Y-m-d H:i") ||
                                        flatpickr.parseDate(initialRawValue, "Y-m-d")) &&
                                        !/^\d+$/.test(initialRawValue))) {
                                initialType = 'date';
                                try {
                                   const parsedDate = initialRawValue instanceof Date ? initialRawValue :
                                                      (flatpickr.parseDate(String(initialRawValue), "Z") ||
                                                       flatpickr.parseDate(String(initialRawValue), "Y-m-d H:i:S") ||
                                                       flatpickr.parseDate(String(initialRawValue), "Y-m-d H:i") ||
                                                       flatpickr.parseDate(String(initialRawValue), "Y-m-d"));
                                   if (parsedDate && !isNaN(parsedDate.getTime())) {
                                        initialValueToCompare = parsedDate.toISOString();
                                   } else {
                                        initialValueToCompare = String(initialRawValue);
                                   }
                                } catch(e){
                                    initialValueToCompare = String(initialRawValue);
                                }
                            } else {
                                initialType = 'string';
                                initialValueToCompare = String(initialRawValue);
                            }
                            initialCustomForCompare[key] = { value: initialValueToCompare, type: initialType };
                        }
                    }
                }
                if (!isEqual(currentCustomForCompare, initialCustomForCompare)) {
                    return true;
                }
                let currentBodyForCompare = "";
                let initialBodyForCompare = "";
                if (processedFormData.hasOwnProperty('body') && typeof processedFormData.body === 'string') {
                     currentBodyForCompare = (this.currentFilePath && typeof App.restoreBlobURLsToRelativePathsInBody === 'function')
                        ? App.restoreBlobURLsToRelativePathsInBody(processedFormData.body).trim()
                        : processedFormData.body.trim();
                }
                if (typeof this.initialBodyContent === 'string') {
                    initialBodyForCompare = (this.currentFilePath && typeof App.restoreBlobURLsToRelativePathsInBody === 'function')
                        ? App.restoreBlobURLsToRelativePathsInBody(this.initialBodyContent).trim()
                        : this.initialBodyContent.trim();
                }
                 if (currentBodyForCompare !== initialBodyForCompare) {
                    return true;
                }
                if (Object.keys(this.pendingUploads || {}).length > 0) {
                    return true;
                }
                let currentLinks = new Set();
                if (this.currentFilePath && typeof App.parseManagedUploadLinks === 'function' && processedFormData.hasOwnProperty('body') && typeof processedFormData.body === 'string') {
                    try {
                        const bodyForLinkParsing = App.restoreBlobURLsToRelativePathsInBody(processedFormData.body);
                        currentLinks = App.parseManagedUploadLinks(bodyForLinkParsing, this.currentFilePath);
                    } catch (e) {
                        return true;
                    }
                }
                const initialLinksArray = Array.from(this.initialUploadLinks || new Set()).sort();
                const currentLinksArray = Array.from(currentLinks).sort();
                 if (!isEqual(currentLinksArray, initialLinksArray)) {
                    return true;
                 }
                return false;
            },
            parseUrlQuery() {
                const queryString = location.search.substring(1);
                if (queryString) {
                    this.urlActionPath = queryString;
                    try {
                        this.urlActionPath = decodeURIComponent(this.urlActionPath.replace(/\+/g, ' '));
                    } catch (e) {
                        App.handleGenericError(e, 'errors.urlParseFailed', "URL Query Parsing");
                        this.urlActionPath = null;
                    }
                } else {
                    this.urlActionPath = null;
                }
            }
        };
        const VditorManager = {
            instance: null,
            isReady: false,
            readyPromise: null,
            resolveReady: null,
            pendingFocus: false,
            inputTimeout: null,
            init(elementId, initialValue = '', themeMediaQuery, inputCallback) {
                this.isReady = false;
                this.pendingFocus = false;
                this.readyPromise = new Promise(resolve => { this.resolveReady = resolve; });
                if (this.instance) {
                    try {
                        this.instance.destroy();
                    } catch (e) {
                        App.handleGenericError(e, 'errors.vditorDestroy', "Vditor Destroy");
                    }
                    this.instance = null;
                }
                try {
                    if (typeof Vditor === 'undefined') {
                        throw new Error("Vditor library not loaded.");
                    }
                    const currentIsDark = themeMediaQuery.matches;
                    this.instance = new Vditor(elementId, {
                        value: initialValue,
                        lang: 'en_US',
                        mode: UserSettings.VDITOR_EDIT_MODE,
                        theme: currentIsDark ? 'dark' : 'classic',
                        toolbarConfig: { pin: true },
                        cache: { enable: false },
                        preview: {
                            theme: { current: currentIsDark ? 'dark' : 'light' },
                            transform: (html) => {
                                if (UserSettings.VDITOR_EDIT_MODE === 'ir' || UserSettings.VDITOR_EDIT_MODE === 'wysiwyg') {
                                     return html;
                                }
                                if (AppState.currentFilePath && AppState.isDraft(AppState.currentFilePath) && PathUtils.isAnyBundlePath(AppState.currentFilePath) && UserSettings.ASSET_STRATEGY === 'local') {
                                    try {
                                        const doc = new DOMParser().parseFromString(html, 'text/html');
                                        const processNode = (node, attributeName) => {
                                            let pathValue = node.getAttribute(attributeName);
                                            if (pathValue && !pathValue.startsWith('blob:') && !pathValue.startsWith('http') && !pathValue.startsWith('data:') && !pathValue.startsWith('/') && !pathValue.startsWith('#')) {
                                                const blobUrl = AppState.draftAssets[pathValue];
                                                if (blobUrl) {
                                                    node.setAttribute(attributeName, blobUrl);
                                                } else {
                                                }
                                            }
                                        };
                                        doc.querySelectorAll('img').forEach(img => processNode(img, 'src'));
                                        doc.querySelectorAll('a').forEach(a => processNode(a, 'href'));
                                        const transformedHtml = doc.body.innerHTML;
                                        return transformedHtml;
                                    } catch(e) {
                                        return html;
                                    }
                                }
                                return html;
                            }
                        },
                        upload: {
                            accept: '*',
                            handler: (files) => {
                                if (!AppState.octokit) {
                                    App.handleGenericError(new Error("Not logged in"), 'errors.notLoggedInForUpload', "Vditor Upload");
                                    return i18next.t('errors.notLoggedInForUpload');
                                }
                                if (!files || files.length === 0) {
                                    App.handleGenericError(new Error("No files provided"), 'errors.noFileToUpload', "Vditor Upload");
                                    return i18next.t('errors.noFileToUpload');
                                }
                                let markdownToInsert = "";
                                let fileCount = 0;
                                for (const file of files) {
                                    try {
                                        const blobUrl = URL.createObjectURL(file);
                                        const cleanBlobUrl = Utils.cleanUrl(blobUrl);
                                        AppState.pendingUploads[cleanBlobUrl] = file;
                                        if (file.type.startsWith('image/')) {
                                            markdownToInsert += `![${PathUtils.getBasename(file.name).split('.')[0]}](${blobUrl})\n`;
                                        } else {
                                            markdownToInsert += `[${file.name}](upload-placeholder:${cleanBlobUrl})\n`;
                                        }
                                        fileCount++;
                                    } catch (error) {
                                        App.handleGenericError(error, 'errors.previewGenFailed', "Vditor Upload", { filename: file.name });
                                    }
                                }
                                if (markdownToInsert) {
                                    this.insertValue(markdownToInsert);
                                    UIManager.updateStatus(i18next.t('statusBar.uploadPlaceholderReady', { count: fileCount }), false, true);
                                    App.refreshEditorUIState();
                                }
                                return null;
                            }
                        },
                        input: (value) => {
                            if (AppState.isProcessingVditorInput) return;
                            if (this.inputTimeout) clearTimeout(this.inputTimeout);
                            this.inputTimeout = setTimeout(async () => {
                                AppState.isProcessingVditorInput = true;
                                try {
                                    if (UserSettings.VDITOR_EDIT_MODE === 'ir' &&
                                        AppState.currentFilePath &&
                                        AppState.isDraft(AppState.currentFilePath) &&
                                        PathUtils.isAnyBundlePath(AppState.currentFilePath) &&
                                        UserSettings.ASSET_STRATEGY === 'local' &&
                                        Object.keys(AppState.draftAssets).length > 0) {
                                        const originalContent = this.instance.getValue();
                                        const newContent = App.replaceRelativePathsWithDraftAssetBlobs(originalContent);
                                        if (newContent !== originalContent) {
                                            this.instance.setValue(newContent);
                                        }
                                    }
                                } finally {
                                    AppState.isProcessingVditorInput = false;
                                }
                                if (inputCallback) inputCallback();
                            }, 300);
                        },
                        after: () => {
                            this.isReady = true;
                            if (this.resolveReady) {
                                this.resolveReady();
                                this.resolveReady = null;
                            }
                            this.setTheme(themeMediaQuery.matches ? 'dark' : 'classic', themeMediaQuery.matches ? 'dark' : 'light');
                            if (this.pendingFocus) {
                                this.focus();
                                this.pendingFocus = false;
                            }
                            UIManager.updateAllText();
                            App.refreshEditorUIState();
                        }
                    });
                    return this.readyPromise;
                } catch (error) {
                    App.handleGenericError(error, 'errors.vditorInitFailed', "Vditor Initialization");
                    if (document.getElementById('editorSection')) {
                        document.getElementById('editorSection').classList.add('hidden');
                    }
                    if (this.resolveReady) {
                        this.resolveReady();
                        this.resolveReady = null;
                    }
                    this.isReady = false;
                    throw error;
                }
            },
            async awaitReady() {
                if (this.isReady) return;
                if (this.readyPromise) {
                    try {
                        await this.readyPromise;
                    } catch (e) {
                        App.handleGenericError(e, 'errors.vditorNotReady', "Vditor Await Ready");
                        throw new Error(i18next.t('errors.vditorNotReady'));
                    }
                } else {
                    const error = new Error(i18next.t('errors.vditorNotReady'));
                    App.handleGenericError(error, 'errors.vditorNotReady', "Vditor Await Ready");
                    throw error;
                }
            },
            async getValue() {
                await this.awaitReady();
                if (!this.instance) throw new Error(i18next.t('errors.vditorNotReady'));
                try {
                    return this.instance.getValue();
                } catch (e) {
                    App.handleGenericError(e, 'errors.vditorGetValueFailed', "Vditor Get Value");
                    return AppState.initialBodyContent;
                }
            },
            async setValue(value, renderNow = false) {
                await this.awaitReady();
                if (!this.instance) throw new Error(i18next.t('errors.vditorNotReady'));
                try {
                     if (typeof this.instance.setValue === 'function') {
                        this.instance.setValue(value);
                    }
                } catch (e) {
                    App.handleGenericError(e, 'errors.vditorSetValueFailed', "Vditor Set Value");
                }
            },
            async insertValue(value) {
                await this.awaitReady();
                if (!this.instance) throw new Error(i18next.t('errors.vditorNotReady'));
                try {
                    this.instance.insertValue(value);
                } catch (e) {
                    App.handleGenericError(e, "Error inserting Vditor value", "Vditor Insert Value");
                }
            },
            async focus() {
                if (!this.instance) return;
                if (!this.isReady) {
                    this.pendingFocus = true;
                    return;
                }
                try {
                    this.instance.focus();
                } catch (e) {
                    App.handleGenericError(e, 'errors.vditorFocus', "Vditor Focus");
                }
            },
            async setTheme(vditorTheme, previewTheme) {
                if (!this.instance || !this.isReady) return;
                try {
                    this.instance.setTheme(vditorTheme, previewTheme);
                } catch (e) {
                    App.handleGenericError(e, 'errors.vditorTheme', "Vditor Set Theme");
                }
            },
            destroy() {
                if (this.inputTimeout) clearTimeout(this.inputTimeout);
                if (this.instance) {
                    try {
                        this.instance.destroy();
                    } catch (e) {
                        App.handleGenericError(e, 'errors.vditorDestroy', "Vditor Destroy");
                    }
                }
                this.instance = null;
                this.isReady = false;
                this.readyPromise = null;
                this.resolveReady = null;
                this.pendingFocus = false;
            },
            async enable() {
                await this.awaitReady();
                if (!this.instance) return;
                try {
                    this.instance.enable();
                } catch (e) {
                }
            },
            async disable() {
                if (!this.instance || !this.isReady) return;
                try {
                    this.instance.disabled();
                } catch (e) {
                }
            }
        };
        const UIManager = {
            elements: {},
            customFieldFlatpickrInstances: new Map(),
            tagifyInstances: new Map(),
            init() {
                this.elements = {
                    patInput: document.getElementById('patInput'),
                    loginButton: document.getElementById('loginButton'),
                    logoutButton: document.getElementById('logoutButton'),
                    repoSelect: document.getElementById('repoSelect'),
                    loadRepoButton: document.getElementById('loadRepoButton'),
                    fileListUl: document.querySelector('#fileList ul'),
                    currentRepoSpan: document.getElementById('currentRepo'),
                    currentPathBreadcrumb: document.getElementById('currentPathBreadcrumb'),
                    fileNameInput: document.getElementById('fileNameInput'),
                    fmTitleInput: document.getElementById('fmTitleInput'),
                    fmAuthorInput: document.getElementById('fmAuthorInput'),
                    fmDateInput: document.getElementById('fmDateInput'),
                    fmDateAutoCheckbox: document.getElementById('fmDateAutoCheckbox'),
                    fmDateAutoLabel: document.getElementById('fmDateAutoLabel'),
                    fmLastmodInput: document.getElementById('fmLastmodInput'),
                    fmLastmodAutoCheckbox: document.getElementById('fmLastmodAutoCheckbox'),
                    fmLastmodAutoLabel: document.getElementById('fmLastmodAutoLabel'),
                    fmLastmodContainer: document.getElementById('fmLastmodContainer'),
                    fmDescriptionInput: document.getElementById('fmDescriptionInput'),
                    fmTagsInput: document.getElementById('fmTagsInput'),
                    fmCategoriesInput: document.getElementById('fmCategoriesInput'),
                    fileContentInput: document.getElementById('fileContentInput'),
                    commitMessageInput: document.getElementById('commitMessageInput'),
                    currentFileShaInput: document.getElementById('currentFileSha'),
                    currentFilePathInput: document.getElementById('currentFilePathInput'),
                    saveDraftButton: document.getElementById('saveDraftButton'),
                    publishButton: document.getElementById('publishButton'),
                    deleteFileButton: document.getElementById('deleteFileButton'),
                    cancelEditButton: document.getElementById('cancelEditButton'),
                    createNewFileButton: document.getElementById('createNewFileButton'),
                    statusBar: document.getElementById('statusBar'),
                    errorStatusBarContainer: document.getElementById('errorStatusBarContainer'),
                    loginSection: document.getElementById('loginSection'),
                    repoSection: document.getElementById('repoSection'),
                    fileBrowserSection: document.getElementById('fileBrowserSection'),
                    editorSection: document.getElementById('editorSection'),
                    customFrontMatterContainer: document.getElementById('customFrontMatterContainer'),
                    addCustomFieldButton: document.getElementById('addCustomFieldButton'),
                    currentBranchName: document.getElementById('currentBranchName'),
                    fileNameLabel: document.getElementById('fileNameLabel'),
                    fmBaseNoteElement: document.querySelector('[data-i18n="editor.fm.baseNote"]'),
                    mainLayoutContainer: document.getElementById('mainLayoutContainer'),
                    fileFilterInput: document.getElementById('fileFilterInput'),
                    fileListEmptyMessage: document.getElementById('fileListEmptyMessage'),
                    draftFilterCheckbox: document.getElementById('draftFilterCheckbox'),
                    draftFilterContainer: document.getElementById('draftFilterContainer'),
                };
                FM_FIELD_CONFIG.forEach(field => {
                    this.elements[field.elementId] = document.getElementById(field.elementId);
                    if (field.autoCheckboxId) this.elements[field.autoCheckboxId] = document.getElementById(field.autoCheckboxId);
                    if (field.autoLabelId) this.elements[field.autoLabelId] = document.getElementById(field.autoLabelId);
                });
                this.elements.addCustomFieldButton.addEventListener('click', () => {
                    this.addCustomFieldRow();
                    App.refreshEditorUIState();
                });
                this.setupDateAutoToggle(this.elements.fmDateInput, this.elements.fmDateAutoCheckbox, this.elements.fmDateAutoLabel);
                this.setupDateAutoToggle(this.elements.fmLastmodInput, this.elements.fmLastmodAutoCheckbox, this.elements.fmLastmodAutoLabel);
            },
            setupDateAutoToggle(inputElement, checkboxElement, labelElement) {
                if (!inputElement || !checkboxElement || !labelElement) return;
                const updateState = () => {
                    if (checkboxElement.checked) {
                        inputElement.disabled = true;
                        labelElement.textContent = i18next.t('editor.fm.autoSetToNow');
                    } else {
                        inputElement.disabled = false;
                        labelElement.textContent = i18next.t('editor.fm.manualInput');
                        inputElement.focus();
                    }
                    App.refreshEditorUIState();
                };
                checkboxElement.addEventListener('change', updateState);
                checkboxElement.defaultChecked = true;
                updateState();
            },
            initDateField(element, fieldKey, value, isAutoChecked, isDisabled) {
                if (!element) return;
                let fpInstanceTarget = (fieldKey === 'date') ? 'flatpickrInstance' : 'flatpickrLastmodInstance';
                if (AppState[fpInstanceTarget]) {
                    try { AppState[fpInstanceTarget].destroy(); } catch(e) {}
                    AppState[fpInstanceTarget] = null;
                }
                try {
                    element.readOnly = true;
                    const fp = flatpickr(element, {
                        enableTime: true, time_24hr: true, allowInput: false, dateFormat: "Y-m-d H:i", static: true,
                        onChange: () => App.refreshEditorUIState(),
                        onClose: (selectedDates, dateStr, instance) => {
                            if (selectedDates.length > 0) instance.input.value = flatpickr.formatDate(selectedDates[0], "Y-m-d H:i");
                            App.refreshEditorUIState();
                        }
                    });
                    AppState[fpInstanceTarget] = fp;
                    if (value) {
                        try {
                            let dateInput = (typeof value === 'number') ? new Date(value) : value;
                            let parsedDate = (dateInput instanceof Date)
                                ? dateInput
                                : (flatpickr.parseDate(String(dateInput), "Z") || flatpickr.parseDate(String(dateInput), "Y-m-d H:i:S") || flatpickr.parseDate(String(dateInput), "Y-m-d H:i") || flatpickr.parseDate(String(dateInput), "Y-m-d") || new Date(dateInput));
                            if (parsedDate && !isNaN(parsedDate.getTime())) {
                                fp.setDate(parsedDate, false);
                                element.value = flatpickr.formatDate(parsedDate, "Y-m-d H:i");
                            } else {
                                element.value = String(value);
                                App.handleGenericError(null, 'errors.invalidDateForFlatpickr', "Flatpickr Populate", { date: value });
                            }
                        } catch (e) {
                            element.value = String(value);
                            App.handleGenericError(e, 'errors.invalidDateForFlatpickr', "Flatpickr Populate", { date: value });
                        }
                    } else {
                        fp.clear(false);
                        element.value = '';
                    }
                    const checkbox = this.elements[FM_FIELD_CONFIG.find(f => f.key === fieldKey).autoCheckboxId];
                    const label = this.elements[FM_FIELD_CONFIG.find(f => f.key === fieldKey).autoLabelId];
                    if (checkbox) checkbox.checked = isAutoChecked;
                    if (checkbox && label) {
                        element.disabled = isAutoChecked;
                        label.textContent = isAutoChecked ? i18next.t('editor.fm.autoSetToNow') : i18next.t('editor.fm.manualInput');
                    }
                    if(isDisabled !== undefined) element.disabled = isDisabled;
                } catch (e) {
                    App.handleGenericError(e, 'errors.vditorInitFailed', `Flatpickr Init (${fieldKey})`);
                }
            },
            manageTagifyInstance(inputElement, enable, initialValue = '') {
                const elementId = inputElement.id;
                if (!elementId) {
                    return;
                }
                if (this.tagifyInstances.has(elementId)) {
                    try {
                        this.tagifyInstances.get(elementId).destroy(); } catch (e) { }
                    this.tagifyInstances.delete(elementId);
                }
                if (enable) {
                    if (inputElement.tagName.toLowerCase() !== 'input' && inputElement.tagName.toLowerCase() !== 'textarea') {
                        return;
                    }
                    const tagifyInstance = new Tagify(inputElement, {
                        delimiters: ',',
                    });
                    if (initialValue && String(initialValue).trim() !== '') {
                        try {
                            tagifyInstance.loadOriginalValues(initialValue); } catch (e) { }
                    }
                    this.tagifyInstances.set(elementId, tagifyInstance);
                    tagifyInstance.on('change', (e) => {
                        App.refreshEditorUIState();
                    });
                }
            },
            updateStatus(message, isError = false, isSuccess = false, isLoading = false) {
                const statusBarEl = this.elements.statusBar;
                const errorContainerEl = this.elements.errorStatusBarContainer;
                if (!statusBarEl || !errorContainerEl) return;
                const cleanMessage = message.replace(/^[âŒâœ…â³â„¹ï¸]\s*(Status|ìƒíƒœ):/, '').trim();
                if (isError) {
                    const errorItem = document.createElement('div');
                    errorItem.className = 'error-status-item';
                    const dismissBtn = document.createElement('button');
                    dismissBtn.type = 'button';
                    dismissBtn.className = 'dismiss-error-btn';
                    dismissBtn.innerHTML = 'Ã—';
                    dismissBtn.addEventListener('click', (event) => {
                        event.preventDefault();
                        errorItem.remove();
                    });
                    errorItem.appendChild(document.createTextNode(`âŒ ${i18next.t('statusBar.statusPrefix')} ${cleanMessage}`));
                    errorItem.appendChild(dismissBtn);
                    errorContainerEl.appendChild(errorItem);
                    statusBarEl.className = 'status-bar';
                    statusBarEl.textContent = `â„¹ï¸ ${i18next.t('statusBar.statusPrefix')} ${i18next.t('statusBar.waiting')}`;
                } else {
                    let emoji = 'â„¹ï¸';
                    statusBarEl.className = 'status-bar';
                    if (isSuccess) {
                        statusBarEl.classList.add('status-bar-success');
                        emoji = 'âœ…';
                    } else if (isLoading) {
                        statusBarEl.classList.add('status-bar-loading');
                        emoji = 'â³';
                    }
                    statusBarEl.textContent = `${emoji} ${i18next.t('statusBar.statusPrefix')} ${cleanMessage}`;
                }
            },
            showSection(sectionName) {
                this.elements.loginSection.classList.add('hidden');
                this.elements.repoSection.classList.add('hidden');
                this.elements.mainLayoutContainer.classList.add('hidden');
                this.elements.mainLayoutContainer.classList.remove('split-view', 'mobile-editor-visible');
                this.removeActiveFileHighlight();
                if (sectionName === 'login') {
                    this.elements.loginSection.classList.remove('hidden');
                } else if (sectionName === 'repo') {
                    this.elements.repoSection.classList.remove('hidden');
                } else if (sectionName === 'main') {
                    this.elements.mainLayoutContainer.classList.remove('hidden');
                    this.setBrowseOnlyState();
                }
                this.toggleLogoutButton(!!AppState.octokit);
                App.updateNewFileButtonUI();
            },
            setBrowseOnlyState() {
                AppState.currentView = 'browse';
                this.elements.mainLayoutContainer.classList.remove('split-view', 'mobile-editor-visible');
                this.elements.fileBrowserSection.classList.remove('hidden');
                this.elements.editorSection.classList.add('hidden');
                this.removeActiveFileHighlight();
                App.setBaseTag(null);
                App.updateNewFileButtonUI();
            },
            setEditState() {
                AppState.currentView = 'edit';
                this.elements.mainLayoutContainer.classList.add('split-view', 'mobile-editor-visible');
                this.elements.fileBrowserSection.classList.remove('hidden');
                this.elements.editorSection.classList.remove('hidden');
                App.updateNewFileButtonUI();
                this.highlightActiveFile(AppState.currentFilePath);
            },
            toggleLogoutButton(show) {
                this.elements.logoutButton.classList.toggle('hidden', !show);
            },
            setLoginLoading(isLoading) {
                this.elements.patInput.disabled = isLoading;
                this.elements.loginButton.disabled = isLoading;
                this.elements.loginButton.textContent = isLoading
                    ? i18next.t('login.loadingButton')
                    : i18next.t('login.loginButton');
                if (isLoading) {
                    this.toggleLogoutButton(false);
                }
            },
            setLoginSuccess(tokenProvided) {
                this.elements.patInput.value = tokenProvided ? '********' : '';
                this.elements.patInput.disabled = true;
                this.elements.loginButton.textContent = i18next.t('login.authCompleteButton');
                this.elements.loginButton.disabled = true;
                this.toggleLogoutButton(true);
            },
            resetLoginScreen(tokenToKeep = '') {
                this.showSection('login');
                this.elements.patInput.disabled = false;
                this.elements.patInput.value = tokenToKeep;
                if (!tokenToKeep) {
                    this.elements.patInput.placeholder = i18next.t('login.patPlaceholder');
                }
                this.elements.loginButton.disabled = false;
                this.elements.loginButton.textContent = i18next.t('login.loginButton');
                this.toggleLogoutButton(false);
                this.elements.repoSelect.innerHTML = `<option value="">${i18next.t('repo.selectDefaultOption')}</option>`;
                this.elements.repoSelect.disabled = true;
                this.elements.loadRepoButton.disabled = true;
                this.elements.currentRepoSpan.textContent = '';
                this.elements.currentBranchName.textContent = UserSettings.DEFAULT_BRANCH;
                this.elements.mainLayoutContainer.classList.add('hidden');
                this.elements.fileBrowserSection.classList.add('hidden');
                this.elements.editorSection.classList.add('hidden');
                if (this.elements.fileListUl) {
                    this.elements.fileListUl.innerHTML = '';
                }
                App.updateNewFileButtonUI();
                this.clearEditorFields(true);
            },
            populateRepoSelect(repos) {
                const select = this.elements.repoSelect;
                select.innerHTML = `<option value="">${i18next.t('repo.selectDefaultOption')}</option>`;
                if (repos && repos.length > 0) {
                    repos.forEach(repo => {
                        const option = document.createElement('option');
                        option.value = `${repo.owner.login}/${repo.name}`;
                        option.textContent = `${repo.full_name} (${repo.private ? 'Private' : 'Public'})`;
                        select.appendChild(option);
                    });
                    select.disabled = false;
                    this.elements.loadRepoButton.disabled = select.value === '';
                } else {
                    select.disabled = true;
                    this.elements.loadRepoButton.disabled = true;
                }
            },
            setRepoLoading(isLoading, repoFullName = '') {
                this.elements.repoSelect.disabled = isLoading;
                this.elements.loadRepoButton.disabled = isLoading || this.elements.repoSelect.value === '';
                if (isLoading && repoFullName) {
                    this.elements.currentRepoSpan.textContent = repoFullName;
                    this.updateBreadcrumb(UserSettings.BASE_BROWSE_PATH);
                }
                App.updateNewFileButtonUI();
            },
            updateBreadcrumb(currentP) {
                const breadcrumb = this.elements.currentPathBreadcrumb;
                breadcrumb.innerHTML = '';
                const normalizedPath = PathUtils.normalizePath(currentP);
                const normalizedBasePath = PathUtils.normalizePath(UserSettings.BASE_BROWSE_PATH);
                const rootLink = document.createElement('a');
                rootLink.href = '#';
                rootLink.textContent = UserSettings.BASE_BROWSE_PATH === '' ? '/' : UserSettings.BASE_BROWSE_PATH;
                rootLink.addEventListener('click', e => {
                    e.preventDefault();
                    App.requestBrowseAction(UserSettings.BASE_BROWSE_PATH || '');
                });
                if (normalizedPath === normalizedBasePath || (normalizedBasePath !== '' && !normalizedPath.startsWith(normalizedBasePath + '/'))) {
                    const strong = document.createElement('strong');
                    strong.appendChild(rootLink);
                    breadcrumb.appendChild(strong);
                } else {
                    breadcrumb.appendChild(rootLink);
                    let relativePath = (normalizedBasePath === '' && normalizedPath !== '')
                        ? normalizedPath
                        : (normalizedPath.startsWith(normalizedBasePath + path.sep)
                            ? normalizedPath.substring(normalizedBasePath.length + 1)
                            : '');
                    const parts = relativePath.split(path.sep).filter(p => p);
                    let accumulatedPath = normalizedBasePath;
                    parts.forEach((part, index) => {
                        accumulatedPath = PathUtils.joinPaths(accumulatedPath, part);
                        breadcrumb.appendChild(document.createTextNode(' / '));
                        if (index === parts.length - 1) {
                            const strong = document.createElement('strong');
                            strong.textContent = part;
                            breadcrumb.appendChild(strong);
                        } else {
                            const link = document.createElement('a');
                            link.href = '#';
                            link.textContent = part;
                            const currentLinkPath = accumulatedPath;
                            link.addEventListener('click', e => {
                                e.preventDefault();
                                App.requestBrowseAction(currentLinkPath);
                            });
                            breadcrumb.appendChild(link);
                        }
                    });
                }
            },
            setFileListLoading(isLoading, currentP) {
                const ul = this.elements.fileListUl;
                ul.innerHTML = isLoading
                    ? `<li><em class="no-hover">â³ ${i18next.t('browser.loadingFiles')}</em></li>`
                    : '';
                ul.style.pointerEvents = isLoading ? 'none' : 'auto';
                ul.style.opacity = isLoading ? 0.6 : 1.0;
                this.elements.createNewFileButton.disabled = isLoading;
                App.updateNewFileButtonUI();
                if (isLoading) {
                    this.updateBreadcrumb(currentP);
                }
            },
            setNewFileButtonUI(text, title, hidden, disabled) {
                const button = this.elements.createNewFileButton;
                if (!button) return;
                button.textContent = text;
                button.title = title;
                button.classList.toggle('hidden', hidden);
                button.disabled = disabled;
            },
            renderFileList(directoryListing, currentP) {
                const ul = this.elements.fileListUl;
                ul.innerHTML = '';
                this.addParentDirectoryLink(currentP);
                AppState.setCurrentPath(currentP);
                App.updateNewFileButtonUI();
                if (directoryListing.length === 0 && !ul.querySelector('.parent-dir')) {
                    const messageKey = PathUtils.normalizePath(currentP) === PathUtils.normalizePath(UserSettings.BASE_BROWSE_PATH)
                        ? 'browser.emptyBaseFolder'
                        : 'browser.emptyFolder';
                    ul.innerHTML += `<li><em class="no-hover"><center>${i18next.t(messageKey)}</center></em></li>`;
                }
                const indexMdPaths = new Set(
                    directoryListing
                        .filter(i => i.type === 'file' && (PathUtils.isPageBundlePath(i.path) || PathUtils.isBranchBundlePath(i.path)))
                        .map(i => i.path.toLowerCase())
                );
                const bundleDirPaths = new Set([...indexMdPaths].map(p => PathUtils.getDirname(p).toLowerCase()));
                const sortedItems = directoryListing.sort((a, b) => {
                    const priority = (item) => item.type === 'dir' ? 0 : (item.name.toLowerCase().endsWith('.md') ? 1 : 2);
                    return priority(a) - priority(b) || a.name.localeCompare(b.name, navigator.language || 'en', { sensitivity: 'base' });
                });
                sortedItems.forEach(item => {
                    const li = document.createElement('li');
                    const textSpan = document.createElement('span');
                    textSpan.textContent = item.name;
                    textSpan.classList.add('file-item-name');
                    li.appendChild(textSpan);
                    li.dataset.path = item.path;
                    if (item.sha) li.dataset.sha = item.sha;
                    let typeClass = '', tooltipKey = '', clickHandler = null, showDraftIcon = false;
                    const normalizedItemPath = PathUtils.normalizePath(item.path);
                    if (item.type === 'dir') {
                        typeClass = 'dir';
                        tooltipKey = 'browser.dirTooltip';
                        clickHandler = () => App.requestBrowseAction(item.path);
                        if (AppState.draftPathsSet.has(PathUtils.normalizePath(PathUtils.joinPaths(normalizedItemPath, 'index.md'))) ||
                            AppState.draftPathsSet.has(PathUtils.normalizePath(PathUtils.joinPaths(normalizedItemPath, '_index.md')))) {
                            showDraftIcon = true;
                            typeClass = 'bundle';
                            tooltipKey = 'browser.bundleTooltip';
                        } else if (bundleDirPaths.has(normalizedItemPath.toLowerCase())) {
                            typeClass = 'bundle';
                            tooltipKey = 'browser.bundleTooltip';
                        }
                    } else if (item.type === 'file') {
                        if (item.name.toLowerCase().endsWith('.md')) {
                            typeClass = 'file';
                            tooltipKey = 'browser.fileTooltip';
                            clickHandler = () => App.requestEditAction(item.path, item.sha);
                            if (AppState.draftPathsSet.has(normalizedItemPath) && !PathUtils.isAnyBundlePath(normalizedItemPath)) {
                                showDraftIcon = true;
                            }
                        } else {
                            typeClass = 'asset';
                            tooltipKey = 'browser.assetTooltip';
                            li.classList.add('no-hover', 'asset');
                        }
                    } else {
                        return;
                    }
                    li.classList.add(typeClass);
                    li.title = i18next.t(tooltipKey, { path: item.path, name: item.name });
                    if (showDraftIcon) {
                        const draftIndicator = document.createElement('span');
                        draftIndicator.textContent = 'ğŸ“';
                        draftIndicator.classList.add('draft-indicator');
                        draftIndicator.title = 'Draft';
                        li.appendChild(draftIndicator);
                    }
                    if (clickHandler) {
                        li.addEventListener('click', clickHandler);
                    } else {
                        li.classList.add('no-hover');
                    }
                    ul.appendChild(li);
                });
                if (ul.children.length === 0 || (ul.children.length === 1 && ul.children[0].classList.contains('parent-dir'))) {
                    if (!Array.from(ul.children).some(child => child.querySelector('em.no-hover center'))) {
                        const messageKey = PathUtils.normalizePath(currentP) === PathUtils.normalizePath(UserSettings.BASE_BROWSE_PATH)
                            ? 'browser.emptyBaseFolder'
                            : 'browser.emptyFolder';
                        ul.innerHTML += `<li><em class="no-hover"><center>${i18next.t(messageKey)}</center></em></li>`;
                    }
                }
                if (AppState.currentFilePath) {
                    this.highlightActiveFile(AppState.currentFilePath);
                }
            },
            addParentDirectoryLink(currentDirPath) {
                const ul = this.elements.fileListUl;
                const normalizedCurrent = PathUtils.normalizePath(currentDirPath);
                const normalizedBase = PathUtils.normalizePath(UserSettings.BASE_BROWSE_PATH);
                const parentPath = PathUtils.getDirname(normalizedCurrent);
                let isParentValid = parentPath != null && parentPath !== '.' &&
                    (normalizedBase === '' || parentPath === normalizedBase || parentPath.startsWith(normalizedBase + '/')) &&
                    !(parentPath.length < normalizedBase.length && parentPath !== normalizedBase);
                if (normalizedCurrent !== normalizedBase && isParentValid) {
                    const li = document.createElement('li');
                    const textSpan = document.createElement('span');
                    textSpan.innerHTML = i18next.t('browser.parentDirLink');
                    li.appendChild(textSpan);
                    li.classList.add('parent-dir');
                    li.title = i18next.t('browser.dirTooltip', { path: parentPath || '/' });
                    li.addEventListener('click', () => App.requestBrowseAction(parentPath));
                    ul.insertBefore(li, ul.firstChild);
                }
            },
            highlightActiveFile(filePath) {
                this.removeActiveFileHighlight();
                if (!filePath || !this.elements.fileListUl) return;
                try {
                    const activeItem = this.elements.fileListUl.querySelector(`li[data-path="${CSS.escape(filePath)}"]`);
                    if (activeItem) {
                        activeItem.classList.add(AppConstants.ACTIVE_EDIT_CLASS);
                    }
                } catch (e) {
                }
            },
            removeActiveFileHighlight() {
                if (!this.elements.fileListUl) return;
                const currentlyActive = this.elements.fileListUl.querySelector(`.${AppConstants.ACTIVE_EDIT_CLASS}`);
                if (currentlyActive) {
                    currentlyActive.classList.remove(AppConstants.ACTIVE_EDIT_CLASS);
                }
            },
            clearEditorFields(skipVditor = false) {
                this.elements.fileNameInput.value = '';
                FM_FIELD_CONFIG.forEach(field => {
                    const element = this.elements[field.elementId];
                    if (element) {
                        if (field.type === 'datetime') {
                            const fpInstance = (field.key === 'date') ? AppState.flatpickrInstance : AppState.flatpickrLastmodInstance;
                            if (fpInstance) fpInstance.clear(false);
                            element.value = '';
                            const autoCheckbox = this.elements[field.autoCheckboxId];
                            const autoLabel = this.elements[field.autoLabelId];
                            if (autoCheckbox) autoCheckbox.checked = true;
                            if (autoLabel) autoLabel.textContent = i18next.t('editor.fm.autoSetToNow');
                            element.disabled = true;
                        } else if (field.elementId === 'fmTagsInput' || field.elementId === 'fmCategoriesInput') {
                            this.manageTagifyInstance(element, true, '');
                        } else {
                            element.value = '';
                        }
                    }
                });
                this.elements.customFrontMatterContainer.innerHTML = '';
                this.customFieldFlatpickrInstances.forEach(fp => {
                    try { fp.destroy(); } catch(e) {}
                });
                this.customFieldFlatpickrInstances.clear();
                this.tagifyInstances.forEach((instance, key) => {
                    if (key.startsWith('tagify_custom_')) {
                        try { instance.destroy(); } catch(e) {}
                        this.tagifyInstances.delete(key);
                    }
                });
                if (this.elements.fmLastmodContainer) {
                    this.elements.fmLastmodContainer.classList.add('hidden');
                }
                if (!skipVditor && VditorManager.instance && VditorManager.isReady) {
                    try {
                        VditorManager.setValue('');
                    } catch (e) {
                        App.handleGenericError(e, 'errors.vditorSetValueFailed', "Clear Editor Fields");
                    }
                }
                this.setCommitMessage('', i18next.t('editor.commitMessagePlaceholder'));
                this.elements.currentFileShaInput.value = '';
                this.elements.currentFilePathInput.value = '';
                AppState.clearPendingUploads();
                AppState.clearDraftAssets();
                AppState.initialUploadLinks.clear();
                this.removeActiveFileHighlight();
            },
            setFilenameInputMode(isLocalMode) {
                this.elements.fileNameLabel.textContent = i18next.t(
                    isLocalMode ? 'editor.fm.bundlePathLabel' : 'editor.fm.fileNameLabel'
                );
                this.elements.fileNameInput.placeholder = i18next.t(
                    isLocalMode ? 'editor.fm.bundlePathPlaceholder' : 'editor.fm.fileNamePlaceholder'
                );
            },
            async populateEditor(filePath, parsedFrontMatter, fmType, initialDraft, initialHasLastmod) {
                const displayValue = PathUtils.isAnyBundlePath(filePath)
                    ? `${PathUtils.getSlugFromFilename(filePath)}/${PathUtils.getBasename(filePath)}`
                    : PathUtils.getBasename(filePath);
                this.elements.fileNameInput.value = displayValue;
                if(AppState.flatpickrInstance) { try { AppState.flatpickrInstance.destroy(); AppState.flatpickrInstance = null; } catch(e){} }
                if(AppState.flatpickrLastmodInstance) { try { AppState.flatpickrLastmodInstance.destroy(); AppState.flatpickrLastmodInstance = null; } catch(e){} }
                this.customFieldFlatpickrInstances.forEach(fp => {
                    try { fp.destroy(); } catch(e) {}
                });
                this.customFieldFlatpickrInstances.clear();
                const isB1a = initialDraft && !initialHasLastmod;
                const isB2a = !initialDraft && !initialHasLastmod;
                this.initDateField(this.elements.fmDateInput, 'date', parsedFrontMatter.date, isB1a, isB1a);
                this.elements.fmLastmodContainer.classList.toggle('hidden', isB1a);
                if (!isB1a) {
                    this.initDateField(this.elements.fmLastmodInput, 'lastmod', parsedFrontMatter.lastmod, true, true);
                }
                FM_FIELD_CONFIG.forEach(field => {
                    if (field.key === 'date' || field.key === 'lastmod') return;
                    const element = this.elements[field.elementId];
                    const value = parsedFrontMatter[field.key];
                    if (element) {
                       if (field.type === 'array' && (field.elementId === 'fmTagsInput' || field.elementId === 'fmCategoriesInput')) {
                            let valueForInputElement;
                            let valueForTagify;
                            if (Array.isArray(value)) {
                                valueForInputElement = value.join(', ');
                                valueForTagify = value;
                            } else {
                                valueForInputElement = String(value || '');
                                valueForTagify = String(value || '');
                            }
                            element.value = valueForInputElement;
                            this.manageTagifyInstance(element, true, valueForTagify);
                        } else if (field.type === 'array') {
                            const arrayValue = Array.isArray(value) ? value.join(', ') : (String(value || ''));
                            element.value = arrayValue;
                        } else {
                            element.value = String(value || '');
                        }
                    }
                });
                this.elements.customFrontMatterContainer.innerHTML = '';
                const customFieldPromises = [];
                const standardKeysLower = AppConstants.STANDARD_FM_KEYS.map(k => k.toLowerCase());
                for (const key in parsedFrontMatter) {
                    if (Object.hasOwnProperty.call(parsedFrontMatter, key) && !standardKeysLower.includes(key.toLowerCase())) {
                        let fieldType = null;
                        const fieldValue = parsedFrontMatter[key];
                        if (typeof fieldValue === 'boolean') fieldType = 'boolean';
                        else if (typeof fieldValue === 'number') fieldType = 'number';
                        else if (Array.isArray(fieldValue)) fieldType = 'array';
                        else if (typeof fieldValue === 'string' && (flatpickr.parseDate(fieldValue, "Z") || flatpickr.parseDate(fieldValue, "Y-m-d H:i:S") || flatpickr.parseDate(fieldValue, "Y-m-d")) && !/^\d+$/.test(fieldValue)) fieldType = 'date';
                        else if (fieldValue instanceof Date) fieldType = 'date';
                        else fieldType = 'string';
                        customFieldPromises.push(this.addCustomFieldRow(key, fieldValue, fieldType));
                    }
                }
                await Promise.all(customFieldPromises);
                this.setEditorButtonLabels(true, initialDraft);
                this.highlightActiveFile(filePath);
                let fmInfoKey = fmType === 'yaml' ? 'statusBar.fmInfoYAML'
                            : fmType === 'toml' ? 'statusBar.fmInfoTOML'
                            : (fmType === 'none' ? 'statusBar.fmInfoNone' : '');
                this.updateStatus(i18next.t(
                    fmType === 'error' ? 'statusBar.fileLoadedWithError' : 'statusBar.fileLoaded',
                    { path: filePath, fmInfo: fmInfoKey ? i18next.t(fmInfoKey) : '' }
                ), fmType === 'error', true);
                VditorManager.focus();
            },
            createValueInputElement(typeConfig, value = '') {
                const input = document.createElement('input');
                input.type = typeConfig.inputType;
                input.className = 'custom-fm-value';
                if (typeConfig.inputType === 'text') {
                    input.placeholder = i18next.t('editor.fm.customValuePlaceholder');
                    input.value = String(value ?? '');
                    if (typeConfig.inputMode) {
                        input.inputMode = typeConfig.inputMode;
                    }
                    if (typeConfig.isDate) {
                        input.dataset.isDateField = 'true';
                    }
                } else if (typeConfig.inputType === 'checkbox') {
                    input.checked = typeof value === 'boolean' ? value : String(value).toLowerCase() === 'true';
                }
                input.id = `custom_val_${Date.now()}_${Math.random().toString(36).substr(2, 5)}`;
                return input;
            },
            async updateCustomFieldValueInput(valueContainer, selectedType, currentValue) {
                return new Promise((resolve) => {
                    const oldValInput = valueContainer.querySelector('.custom-fm-value, .tagify');
                    if (oldValInput && oldValInput.id) {
                        if (this.customFieldFlatpickrInstances.has(oldValInput.id)) {
                            this.customFieldFlatpickrInstances.get(oldValInput.id).destroy();
                            this.customFieldFlatpickrInstances.delete(oldValInput.id);
                        }
                        if (oldValInput.tagName?.toLowerCase() === 'input' || oldValInput.tagName?.toLowerCase() === 'textarea' || oldValInput.classList?.contains('tagify')) {
                            const originalInput = oldValInput.classList.contains('tagify') ? oldValInput.querySelector('input, textarea') : oldValInput;
                            if (originalInput) this.manageTagifyInstance(originalInput, false);
                        }
                    }
                    valueContainer.innerHTML = '';
                    const typeConfig = AppConstants.CUSTOM_FM_TYPES.find(t => t.value === selectedType);
                    if (!typeConfig) {
                        resolve();
                        return;
                    }
                    let displayValue = currentValue;
                    let newInput;
                    if (selectedType === 'array') {
                        newInput = document.createElement('input');
                        newInput.type = 'text';
                        newInput.className = 'custom-fm-value';
                        const newGeneratedId = `tagify_custom_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
                        newInput.id = newGeneratedId;
                        displayValue = Array.isArray(currentValue) ? currentValue.join(',') : String(currentValue ?? '');
                        newInput.value = displayValue;
                        valueContainer.appendChild(newInput);
                        requestAnimationFrame(() => {
                            this.manageTagifyInstance(newInput, true, displayValue);
                            resolve();
                        });
                    } else {
                        if (typeConfig.inputType === 'checkbox') {
                            displayValue = (String(currentValue).toLowerCase() === 'true' || currentValue === true);
                        } else if (typeConfig.isDate) {
                            if (currentValue) {
                                try {
                                    const parsedDate = flatpickr.parseDate(String(currentValue), "Y-m-d H:i:S") || flatpickr.parseDate(String(currentValue), "Z") || new Date(currentValue);
                                    displayValue = (parsedDate && !isNaN(parsedDate.getTime())) ? flatpickr.formatDate(parsedDate, "Y-m-d H:i") : String(currentValue);
                                } catch(e) { displayValue = String(currentValue); }
                            } else {
                                displayValue = '';
                            }
                        } else {
                            displayValue = String(currentValue ?? '');
                        }
                        newInput = this.createValueInputElement(typeConfig, displayValue);
                        valueContainer.appendChild(newInput);
                        if (typeConfig.inputType === 'checkbox') {
                            const booleanLabel = document.createElement('span');
                            booleanLabel.className = 'custom-fm-boolean-label';
                            booleanLabel.style.marginLeft = '5px';
                            const updateBooleanLabel = (checked) => {
                                booleanLabel.textContent = checked ? i18next.t('editor.fm.typeBooleanTrue') : i18next.t('editor.fm.typeBooleanFalse');
                            };
                            updateBooleanLabel(newInput.checked);
                            newInput.addEventListener('change', () => {
                                updateBooleanLabel(newInput.checked);
                                App.refreshEditorUIState();
                            });
                            valueContainer.appendChild(booleanLabel);
                        } else if (typeConfig.isDate) {
                            newInput.readOnly = true;
                            const fpInstance = flatpickr(newInput, {
                                enableTime: true, time_24hr: true, allowInput: false, dateFormat: "Y-m-d H:i", static: true,
                                onChange: () => App.refreshEditorUIState(),
                                onClose: (selectedDates, dateStr, instance) => {
                                    if (selectedDates.length > 0) instance.input.value = flatpickr.formatDate(selectedDates[0], "Y-m-d H:i");
                                    App.refreshEditorUIState();
                                }
                            });
                            if (newInput.id) {
                                this.customFieldFlatpickrInstances.set(newInput.id, fpInstance);
                                if (displayValue) fpInstance.setDate(displayValue, true);
                            } else { }
                        }
                        if (newInput && newInput.type !== 'checkbox' && selectedType !== 'array' && !typeConfig.isDate) {
                            newInput.addEventListener('input', () => App.refreshEditorUIState());
                        }
                        resolve();
                    }
                });
            },
            async addCustomFieldRow(key = '', value = '', explicitTypeFromArg = null) {
                const rowDiv = document.createElement('div');
                rowDiv.className = 'custom-fm-row';
                const keyInput = document.createElement('input');
                keyInput.type = 'text';
                keyInput.placeholder = i18next.t('editor.fm.customKeyPlaceholder');
                keyInput.className = 'custom-fm-key';
                keyInput.value = key;
                keyInput.addEventListener('input', () => App.refreshEditorUIState());
                const valueContainer = document.createElement('div');
                valueContainer.className = 'custom-fm-value-container';
                const typeSelect = document.createElement('select');
                typeSelect.className = 'custom-fm-type';
                AppConstants.CUSTOM_FM_TYPES.forEach(typeOpt => {
                    const option = document.createElement('option');
                    option.value = typeOpt.value;
                    option.textContent = i18next.t(typeOpt.labelKey);
                    typeSelect.appendChild(option);
                });
                let inferredType;
                if (explicitTypeFromArg && AppConstants.CUSTOM_FM_TYPES.some(t => t.value === explicitTypeFromArg)) {
                    inferredType = explicitTypeFromArg;
                } else if (value !== undefined && value !== null) {
                    if (typeof value === 'boolean') inferredType = 'boolean';
                    else if (typeof value === 'number') inferredType = 'number';
                    else if (Array.isArray(value)) inferredType = 'array';
                    else if (typeof value === 'string' && (flatpickr.parseDate(value, "Z") || flatpickr.parseDate(value, "Y-m-d H:i:S") || flatpickr.parseDate(value, "Y-m-d")) && !/^\d+$/.test(value)) inferredType = 'date';
                    else if (value instanceof Date) inferredType = 'date';
                    else inferredType = 'string';
                } else {
                    inferredType = 'string';
                }
                typeSelect.value = inferredType;
                rowDiv.appendChild(typeSelect);
                rowDiv.appendChild(keyInput);
                rowDiv.appendChild(valueContainer);
                await this.updateCustomFieldValueInput(valueContainer, typeSelect.value, value);
                typeSelect.addEventListener('change', async (e) => {
                    const newSelectedType = e.target.value;
                    let initialValueForNewType = (newSelectedType === 'boolean') ? false : '';
                    await this.updateCustomFieldValueInput(valueContainer, newSelectedType, initialValueForNewType);
                    App.refreshEditorUIState();
                });
                const removeButton = document.createElement('button');
                removeButton.type = 'button';
                removeButton.textContent = i18next.t('editor.fm.removeCustomFieldButton');
                removeButton.className = 'remove-custom-fm-button';
                removeButton.title = i18next.t('editor.fm.removeCustomFieldButtonTooltip');
                removeButton.addEventListener('click', () => {
                    const valueInputInContainer = valueContainer.querySelector('.custom-fm-value, .tagify');
                    if (valueInputInContainer && valueInputInContainer.id) {
                        if (this.customFieldFlatpickrInstances.has(valueInputInContainer.id)) {
                            this.customFieldFlatpickrInstances.get(valueInputInContainer.id).destroy();
                            this.customFieldFlatpickrInstances.delete(valueInputInContainer.id);
                        }
                        if (valueInputInContainer.tagName?.toLowerCase() === 'input' || valueInputInContainer.tagName?.toLowerCase() === 'textarea' || valueInputInContainer.classList?.contains('tagify')) {
                            const originalInput = valueInputInContainer.classList.contains('tagify') ? valueInputInContainer.querySelector('input, textarea') : valueInputInContainer;
                            if (originalInput) this.manageTagifyInstance(originalInput, false);
                        }
                    }
                    rowDiv.remove();
                    App.refreshEditorUIState();
                });
                rowDiv.appendChild(removeButton);
                this.elements.customFrontMatterContainer.appendChild(rowDiv);
                if (!key) {
                    keyInput.focus();
                }
            },
            getRawEditorFormData() {
                const formData = {
                    custom: [],
                    commitMessage: this.elements.commitMessageInput.value.trim(),
                    fullPathValue: this.elements.fileNameInput.value.trim()
                };
                FM_FIELD_CONFIG.forEach(field => {
                    const element = this.elements[field.elementId];
                    if (element) {
                        if ((field.key === 'tags' || field.key === 'categories') && this.tagifyInstances.has(field.elementId)) {
                            const tagifyInstance = this.tagifyInstances.get(field.elementId);
                            formData[field.key] = tagifyInstance.value.map(tag => tag.value).sort();
                        } else if (field.type === 'datetime') {
                            formData[field.key] = element.value.trim();
                            if (this.elements[field.autoCheckboxId]) {
                                formData[`${field.key}AutoChecked`] = this.elements[field.autoCheckboxId].checked;
                            }
                        }
                         else {
                            formData[field.key] = element.value.trim();
                        }
                    }
                });
                if (!this.elements.customFrontMatterContainer) {
                    return formData;
                }
                this.elements.customFrontMatterContainer.querySelectorAll('.custom-fm-row').forEach((row) => {
                    const keyInput = row.querySelector('.custom-fm-key');
                    const typeSelect = row.querySelector('.custom-fm-type');
                    let valueInputElement = null;
                    if (!keyInput || !typeSelect) {
                        return;
                    }
                    const selectedType = typeSelect.value;
                    if (selectedType === 'array') {
                        valueInputElement = row.querySelector('input.custom-fm-value[id^="tagify_custom_"], textarea.custom-fm-value[id^="tagify_custom_"]');
                    } else if (selectedType === 'boolean') {
                        valueInputElement = row.querySelector('input.custom-fm-value[type="checkbox"]');
                    } else if (selectedType === 'date') {
                        valueInputElement = row.querySelector('input.custom-fm-value[data-is-date-field="true"]');
                        if (!valueInputElement) {
                            valueInputElement = row.querySelector('input.custom-fm-value.flatpickr-input[type="text"]');
                        }
                        if (!valueInputElement) {
                            valueInputElement = row.querySelector('input.custom-fm-value.flatpickr-input[type="hidden"]');
                        }
                        if (!valueInputElement) {
                            valueInputElement = row.querySelector('input.custom-fm-value.flatpickr-input.flatpickr-mobile[type="datetime-local"]');
                        }
                    } else {
                        valueInputElement = row.querySelector('input.custom-fm-value[type="text"]');
                    }
                    if (!valueInputElement) {
                        return;
                    }
                    const key = keyInput.value.trim();
                    const type = selectedType;
                    let valueToPush;
                    if (key) {
                        if (type === 'array') {
                            if (valueInputElement.id && this.tagifyInstances.has(valueInputElement.id)) {
                                const tagifyInstance = this.tagifyInstances.get(valueInputElement.id);
                                valueToPush = tagifyInstance.value
                                    .map(tag => tag.value)
                                    .filter(val => val !== undefined && val !== null && String(val).trim() !== '')
                                    .sort();
                            } else {
                                valueToPush = valueInputElement.value.split(',')
                                    .map(s => s.trim())
                                    .filter(s => s !== '')
                                    .sort();
                            }
                        } else if (type === 'boolean') {
                            valueToPush = valueInputElement.checked;
                        } else {
                            valueToPush = valueInputElement.value;
                        }
                        formData.custom.push({
                            key: key,
                            value: valueToPush,
                            type: type
                        });
                    }
                });
                return formData;
            },
            setCommitMessage(message, placeholder) {
                this.elements.commitMessageInput.value = message;
                this.elements.commitMessageInput.placeholder = placeholder || i18next.t('editor.commitMessagePlaceholder');
            },
            setEditorButtonLabels(isEditing, isDraftInitially) {
                if (isEditing && !isDraftInitially) {
                    this.elements.saveDraftButton.textContent = i18next.t('editor.revertToDraftButton');
                    this.elements.publishButton.textContent = i18next.t('editor.updateAndPublishButton');
                } else {
                    this.elements.saveDraftButton.textContent = i18next.t('editor.saveDraftButton');
                    this.elements.publishButton.textContent = i18next.t('editor.publishButton');
                }
            },
            setEditorActionButtonsState(canSaveDraft, canPublish, canDelete, canCancel) {
                this.elements.saveDraftButton.disabled = !canSaveDraft;
                this.elements.publishButton.disabled = !canPublish;
                this.elements.deleteFileButton.disabled = !canDelete;
                this.elements.cancelEditButton.disabled = !canCancel;
            },
            setEditorSaving(isSaving) {
                this.elements.editorSection.querySelectorAll('input, select, button, textarea, .tagify').forEach(el => {
                    if (el !== this.elements.statusBar && el !== this.elements.errorStatusBarContainer &&
                        el !== this.elements.saveDraftButton && el !== this.elements.publishButton &&
                        el !== this.elements.deleteFileButton && el !== this.elements.cancelEditButton) {
                        if (el.classList.contains('tagify')) {
                             const tagifyInstance = Array.from(this.tagifyInstances.values()).find(inst => inst.DOM.scope === el);
                             if(tagifyInstance) tagifyInstance.setDisabled(isSaving);
                        } else {
                            el.disabled = isSaving;
                        }
                    }
                });
                if (VditorManager.instance) {
                    if (isSaving) VditorManager.disable(); else VditorManager.enable();
                }
                this.elements.saveDraftButton.disabled = isSaving;
                this.elements.publishButton.disabled = isSaving;
                this.elements.deleteFileButton.disabled = isSaving || !AppState.currentFileSha;
                this.elements.cancelEditButton.disabled = isSaving;
                this.elements.addCustomFieldButton.disabled = isSaving;
                this.elements.customFrontMatterContainer.querySelectorAll('.remove-custom-fm-button')
                    .forEach(btn => btn.disabled = isSaving);
            },
            updateAllText() {
                document.querySelectorAll('[data-i18n]').forEach(el => {
                    const key = el.getAttribute('data-i18n');
                    if (!key) return;
                    let translationKey = key, attributeToSet = 'textContent';
                    if (key.startsWith('[placeholder]')) {
                        translationKey = key.substring('[placeholder]'.length);
                        attributeToSet = 'placeholder';
                    } else if (key.startsWith('[title]')) {
                        translationKey = key.substring('[title]'.length);
                        attributeToSet = 'title';
                    } else if (key.startsWith('[html]')) {
                        translationKey = key.substring('[html]'.length);
                        attributeToSet = 'innerHTML';
                    }
                    if (translationKey === 'editor.fm.baseNote' && el) {
                        el.innerHTML = i18next.t(translationKey, { format: UserSettings.FRONTMATTER_FORMAT.toUpperCase() });
                    } else if (translationKey === 'browser.newFileButtonInFolder') {
                        App.updateNewFileButtonUI();
                    } else if (translationKey === 'editor.saveDraftButton' || translationKey === 'editor.publishButton') {
                        this.setEditorButtonLabels(!!AppState.currentFileSha, AppState.initialDraftState);
                    } else if (translationKey === 'editor.fm.autoSetToNow' || translationKey === 'editor.fm.manualInput') {
                        if (el.id === 'fmDateAutoLabel') {
                            el.textContent = this.elements.fmDateAutoCheckbox.checked ? i18next.t('editor.fm.autoSetToNow') : i18next.t('editor.fm.manualInput');
                        } else if (el.id === 'fmLastmodAutoLabel') {
                            el.textContent = this.elements.fmLastmodAutoCheckbox.checked ? i18next.t('editor.fm.autoSetToNow') : i18next.t('editor.fm.manualInput');
                        }
                    }
                    else {
                        try {
                            const translatedText = i18next.t(translationKey);
                            el[attributeToSet] = translatedText;
                        } catch (e) {
                        }
                    }
                });
                if (this.elements.customFrontMatterContainer) {
                    this.elements.customFrontMatterContainer.querySelectorAll('.remove-custom-fm-button').forEach(button => {
                        button.textContent = i18next.t('editor.fm.removeCustomFieldButton');
                        button.title = i18next.t('editor.fm.removeCustomFieldButtonTooltip');
                    });
                    this.elements.customFrontMatterContainer.querySelectorAll('.custom-fm-type option').forEach(option => {
                         const typeConfig = AppConstants.CUSTOM_FM_TYPES.find(t => t.value === option.value);
                         if (typeConfig) option.textContent = i18next.t(typeConfig.labelKey);
                    });
                }
                document.documentElement.lang = AppState.currentLang;
                this.setFilenameInputMode(AppState.isCurrentOperationTargetingLocal());
            },
        };
        const GitHubService = {
            async authenticate(token) {
                AppState.octokit = new Octokit({ auth: token });
                try {
                    const { data: user } = await AppState.octokit.rest.users.getAuthenticated();
                    return { success: true, user };
                } catch (error) {
                    AppState.octokit = null;
                    return { success: false, error };
                }
            },
            async listRepos() {
                if (!AppState.octokit) throw new Error(i18next.t('errors.noAuth'));
                try {
                    const repos = await AppState.octokit.paginate(
                        AppState.octokit.rest.repos.listForAuthenticatedUser,
                        { type: 'all', sort: 'updated', per_page: 100 }
                    );
                    return { success: true, repos };
                } catch (error) {
                    return { success: false, error };
                }
            },
            async getContent(p) {
                if (!AppState.octokit || !AppState.owner || !AppState.repo) {
                    throw new Error(i18next.t('errors.missingContext'));
                }
                try {
                    const { data } = await AppState.octokit.rest.repos.getContent({
                        owner: AppState.owner,
                        repo: AppState.repo,
                        path: p,
                        ref: AppState.branch,
                        headers: { 'If-None-Match': '' }
                    });
                    const contentList = Array.isArray(data) ? data : [data];
                    const items = contentList
                        .map(item => ({
                            name: item.name,
                            path: item.path,
                            sha: item.sha,
                            type: item.type,
                            size: item.size
                        }))
                        .sort((a, b) => {
                            const aIsIndexMd = PathUtils.isPageBundlePath(a.path) || PathUtils.isBranchBundlePath(a.path);
                            const bIsIndexMd = PathUtils.isPageBundlePath(b.path) || PathUtils.isBranchBundlePath(b.path);
                            if (aIsIndexMd && !bIsIndexMd) return -1;
                            if (!aIsIndexMd && bIsIndexMd) return 1;
                            if (a.type !== b.type) return a.type === 'dir' ? -1 : 1;
                            return a.name.localeCompare(b.name, navigator.language || 'en', { sensitivity: 'base' });
                        });
                    return { success: true, items };
                } catch (error) {
                    return { success: false, error, path: p, notFound: error.status === 404 };
                }
            },
            async getFileContent(filePath, fileSha) {
                if (!AppState.octokit || !AppState.owner || !AppState.repo) {
                    throw new Error(i18next.t('errors.missingContext'));
                }
                try {
                    const { data: blobData } = await AppState.octokit.rest.git.getBlob({
                        owner: AppState.owner,
                        repo: AppState.repo,
                        file_sha: fileSha,
                        headers: { 'If-None-Match': '' }
                    });
                    if (!blobData || typeof blobData.content === 'undefined' || blobData.encoding !== 'base64' || !blobData.sha) {
                        throw new Error(i18next.t('errors.missingBlob'));
                    }
                    if (blobData.size > 1048576) {
                        UIManager.updateStatus(i18next.t('errors.largeFileWarn', { sizeMB: (blobData.size / 1048576).toFixed(2) }), false);
                    }
                    const decodedContent = EncodingUtils.b64DecodeUnicode(blobData.content);
                    const { frontMatter, body, type } = FrontMatterUtils.parseFrontMatterAndBody(decodedContent);
                    return { success: true, path: filePath, sha: blobData.sha, frontMatter, body, type };
                } catch (error) {
                    return { success: false, error, path: filePath, sha: fileSha, notFound: error.status === 404 };
                }
            },
            async getRawAssetContent(assetPath) {
                if (!AppState.octokit || !AppState.owner || !AppState.repo) {
                    throw new Error(i18next.t('errors.missingContext'));
                }
                try {
                    const { data } = await AppState.octokit.rest.repos.getContent({
                        owner: AppState.owner,
                        repo: AppState.repo,
                        path: assetPath,
                        ref: AppState.branch,
                        headers: { 'If-None-Match': '' }
                    });
                    if (data.type === 'file' && data.content && data.encoding === 'base64') {
                        return { success: true, content: data.content, path: assetPath, sha: data.sha };
                    }
                    throw new Error('Invalid asset data received from API.');
                } catch (error) {
                    return { success: false, error, path: assetPath, notFound: error.status === 404 };
                }
            },
            async getRef(ref = `heads/${AppState.branch}`) {
                if (!AppState.octokit || !AppState.owner || !AppState.repo) throw new Error(i18next.t('errors.missingContext'));
                try {
                    const { data } = await AppState.octokit.rest.git.getRef({
                        owner: AppState.owner,
                        repo: AppState.repo,
                        ref
                    });
                    return { success: true, sha: data.object.sha, ref: data.ref };
                } catch (error) {
                    return { success: false, error };
                }
            },
            async getCommit(commitSha) {
                if (!AppState.octokit || !AppState.owner || !AppState.repo) throw new Error(i18next.t('errors.missingContext'));
                try {
                    const { data } = await AppState.octokit.rest.git.getCommit({
                        owner: AppState.owner,
                        repo: AppState.repo,
                        commit_sha: commitSha
                    });
                    return { success: true, treeSha: data.tree.sha, commit: data };
                } catch (error) {
                    return { success: false, error };
                }
            },
            async createBlob(content, encoding = 'utf-8') {
                if (!AppState.octokit || !AppState.owner || !AppState.repo) throw new Error(i18next.t('errors.missingContext'));
                try {
                    const { data } = await AppState.octokit.rest.git.createBlob({
                        owner: AppState.owner,
                        repo: AppState.repo,
                        content,
                        encoding
                    });
                    return { success: true, sha: data.sha };
                } catch (error) {
                    return { success: false, error };
                }
            },
            async createTree(baseTreeSha, treeDefinition) {
                if (!AppState.octokit || !AppState.owner || !AppState.repo) throw new Error(i18next.t('errors.missingContext'));
                try {
                    const { data } = await AppState.octokit.rest.git.createTree({
                        owner: AppState.owner,
                        repo: AppState.repo,
                        base_tree: baseTreeSha,
                        tree: treeDefinition
                    });
                    return { success: true, sha: data.sha };
                } catch (error) {
                    return { success: false, error };
                }
            },
            async createCommit(treeSha, parentCommitSha, message) {
                if (!AppState.octokit || !AppState.owner || !AppState.repo) throw new Error(i18next.t('errors.missingContext'));
                try {
                    const { data } = await AppState.octokit.rest.git.createCommit({
                        owner: AppState.owner,
                        repo: AppState.repo,
                        message,
                        tree: treeSha,
                        parents: [parentCommitSha]
                    });
                    return { success: true, sha: data.sha };
                } catch (error) {
                    return { success: false, error };
                }
            },
            async updateRef(commitSha, ref = `heads/${AppState.branch}`) {
                if (!AppState.octokit || !AppState.owner || !AppState.repo) throw new Error(i18next.t('errors.missingContext'));
                try {
                    await AppState.octokit.rest.git.updateRef({
                        owner: AppState.owner,
                        repo: AppState.repo,
                        ref,
                        sha: commitSha,
                        force: false
                    });
                    return { success: true };
                } catch (error) {
                    return { success: false, error };
                }
            },
            async getFolderContentsRecursive(folderPath) {
                if (!AppState.octokit || !AppState.owner || !AppState.repo) {
                    throw new Error(i18next.t('errors.missingContext'));
                }
                let allItems = [];
                const stack = [folderPath];
                const processedPaths = new Set();
                while (stack.length > 0) {
                    const currentPath = stack.pop();
                    if (processedPaths.has(currentPath)) continue;
                    processedPaths.add(currentPath);
                    try {
                        const { data } = await AppState.octokit.rest.repos.getContent({
                            owner: AppState.owner,
                            repo: AppState.repo,
                            path: currentPath,
                            ref: AppState.branch,
                            headers: { 'If-None-Match': '' }
                        });
                        if (Array.isArray(data)) {
                            data.forEach(item => {
                                allItems.push({ path: item.path, sha: item.sha, type: item.type });
                                if (item.type === 'dir') {
                                    stack.push(item.path);
                                }
                            });
                        } else if (data && data.type === 'file') {
                            allItems.push({ path: data.path, sha: data.sha, type: 'file' });
                        }
                    } catch (error) {
                        if (error.status === 404) {
                            return null;
                        } else {
                            throw error;
                        }
                    }
                }
                return allItems;
            },
        };
        const App = {
            elements: {},
            themeMediaQuery: null,
            reverseDraftAssetMap: {},
            init() {
                AppState.currentLang = UserSettings.DEFAULT_LANGUAGE;
                document.documentElement.lang = AppState.currentLang;
                i18next.init({
                    lng: AppState.currentLang,
                    fallbackLng: UserSettings.DEFAULT_LANGUAGE,
                    debug: false,
                    resources: resources,
                    interpolation: { escapeValue: false, prefix: '__', suffix: '__' }
                }).then(() => {
                    UIManager.init();
                    this.elements = UIManager.elements;
                    UIManager.updateAllText();
                    AppState.parseUrlQuery();
                    this.setupThemeHandling();
                    this.setupEventListeners();
                    const localeKey = UserSettings.DEFAULT_LANGUAGE;
                    let localeObj;
                    switch (localeKey) {
                        case 'ko': localeObj = Korean; break;
                        case 'zh': localeObj = Chinese; break;
                        case 'ja': localeObj = Japanese; break;
                        case 'es': localeObj = Spanish; break;
                        case 'de': localeObj = German; break;
                        case 'fr': localeObj = French; break;
                        case 'pt': localeObj = Portuguese; break;
                        case 'ru': localeObj = Russian; break;
                        default: localeObj = flatpickr.l10ns.default; break;
                    }
                    flatpickr.localize(localeObj);
                    const storedPat = localStorage.getItem(AppConstants.PAT_STORAGE_KEY);
                    if (storedPat) {
                        this.autoLogin(storedPat);
                    } else {
                        UIManager.resetLoginScreen();
                        UIManager.updateStatus(i18next.t('statusBar.waiting'));
                    }
                }).catch(err => {
                    this.handleGenericError(err, "i18n init failed.", "App Initialization");
                    document.body.innerHTML = `<h1 style="color: red;">${resources.en.translation['errors.appLoad']}</h1><p>${resources.en.translation['errors.scriptError']}</p><p>i18n init failed.</p>`;
                });
            },
            setBaseTag(href) {
                let baseTag = document.getElementById('dynamic-base-tag');
                const head = document.head;
                if (href) {
                    if (!baseTag) {
                        baseTag = document.createElement('base');
                        baseTag.id = 'dynamic-base-tag';
                        const existingBase = head.querySelector('base');
                        if (existingBase) {
                            head.insertBefore(baseTag, existingBase);
                        } else {
                            head.prepend(baseTag);
                        }
                    }
                    try {
                        const finalHref = href.startsWith('http')
                            ? href
                            : new URL(href, window.location.origin).href;
                        baseTag.href = finalHref.endsWith('/') ? finalHref : finalHref + '/';
                    } catch (e) {
                        this.handleGenericError(e, "Error setting base tag href", "Base Tag Handling", { inputHref: href });
                        if (baseTag) baseTag.remove();
                    }
                } else if (baseTag) {
                    baseTag.remove();
                }
            },
            handleApiError(error, contextMessageKey, details = {}) {
                let userMessage, errorCode = error?.status, shouldLogout = false;
                let messageOptions = {
                    context: i18next.t(contextMessageKey),
                    code: errorCode,
                    message: error?.message || i18next.t('errors.unknownError'),
                    path: details.path || 'N/A',
                    slug: details.slug || 'N/A',
                    dirPath: details.dirPath || 'N/A'
                };
                if (errorCode) {
                    switch (errorCode) {
                        case 401:
                            userMessage = i18next.t('errors.authError', messageOptions);
                            shouldLogout = true;
                            break;
                        case 403:
                            userMessage = i18next.t('errors.permissionError', messageOptions);
                            if (error.message?.toLowerCase().includes("rate limit exceeded")) {
                                userMessage += i18next.t('errors.rateLimit');
                            } else if (error.message?.toLowerCase().includes("resource not accessible") || error.message?.toLowerCase().includes("repository access denied")) {
                                userMessage += i18next.t('errors.repoAccessDenied');
                            }
                            break;
                        case 404:
                            userMessage = i18next.t('errors.notFoundError', messageOptions);
                            break;
                        case 409:
                            userMessage = i18next.t('errors.conflictError', messageOptions);
                            break;
                        case 422:
                            userMessage = i18next.t('errors.unprocessableError', messageOptions);
                            break;
                        default:
                            userMessage = i18next.t('errors.genericApiError', messageOptions);
                    }
                } else if (error?.message?.toLowerCase().includes('fetch') || (error instanceof TypeError && error.message.includes('NetworkError'))) {
                    userMessage = i18next.t('errors.contextualNetworkError', { context: i18next.t(contextMessageKey) });
                } else {
                    userMessage = i18next.t('errors.unexpectedErrorContext', messageOptions);
                }
                UIManager.updateStatus(`${userMessage}`, true);
                UIManager.setEditorSaving(false);
                UIManager.setRepoLoading(false);
                UIManager.setFileListLoading(false, AppState.currentPath);
                if (shouldLogout) {
                    this.handleLogout();
                }
            },
            handleGenericError(error, userMessageOrKey, context = "General Error", details = {}) {
                let message = i18next.exists(userMessageOrKey)
                    ? i18next.t(userMessageOrKey, details)
                    : (userMessageOrKey || i18next.t('errors.unknownError', { message: error?.message || 'Unknown' }));
                UIManager.updateStatus(message, true);
            },
            async loadDraftStatus() {
                AppState.draftPathsSet.clear();
                if (UIManager.elements.draftFilterContainer) {
                    UIManager.elements.draftFilterContainer.classList.add('hidden');
                }
                if (!AppState.octokit || !AppState.owner || !AppState.repo) return;
                const draftFilePath = 'drafts.json';
                try {
                    const { data } = await AppState.octokit.request('GET /repos/{owner}/{repo}/contents/{path}', {
                        owner: AppState.owner,
                        repo: AppState.repo,
                        path: draftFilePath,
                        ref: AppState.branch,
                        headers: { 'If-None-Match': '' }
                    });
                    if (data && data.type === 'file' && data.content) {
                        const decodedContent = EncodingUtils.b64DecodeUnicode(data.content);
                        let draftPaths = null;
                        try {
                            draftPaths = JSON.parse(decodedContent);
                        } catch (parseError) {
                            this.handleGenericError(parseError, i18next.t('errors.apiError', { message: `Failed to parse ${draftFilePath}: ${parseError.message}` }), "Draft Status Parsing");
                            AppState.draftPathsSet.clear();
                            return;
                        }
                        if (Array.isArray(draftPaths)) {
                            AppState.draftPathsSet = new Set(draftPaths.map(p => PathUtils.normalizePath(p)));
                            if (UIManager.elements.draftFilterContainer) {
                                UIManager.elements.draftFilterContainer.classList.remove('hidden');
                            }
                        } else {
                            AppState.draftPathsSet.clear();
                        }
                    } else {
                        AppState.draftPathsSet.clear();
                    }
                } catch (error) {
                    if (error.status !== 404) {
                        this.handleApiError(error, `Failed to load ${draftFilePath}`, { path: draftFilePath });
                    }
                    AppState.draftPathsSet.clear();
                }
            },
            handleLocalLink: (href, markdownFilePath, localAssetSubdir) => {
                const normalizedHref = PathUtils.normalizePath(href);
                const normalizedSubdir = PathUtils.normalizePath(localAssetSubdir);
                const markdownDir = PathUtils.getDirname(markdownFilePath);
                if (normalizedSubdir && (normalizedHref.startsWith(normalizedSubdir + '/') || normalizedHref === normalizedSubdir)) {
                    return PathUtils.joinPaths(markdownDir, normalizedHref);
                } else {
                    let pathSegments = [markdownDir];
                    if (normalizedSubdir) {
                        pathSegments.push(normalizedSubdir);
                    }
                    pathSegments.push(normalizedHref.startsWith('./') ? normalizedHref.substring(2) : normalizedHref);
                    return PathUtils.joinPaths(...pathSegments);
                }
            },
            handleGlobalLink(href, markdownFilePath, globalRootDir, globalAssetSubpath) {
                const normalizedRootDir = PathUtils.normalizePath(globalRootDir);
                const normalizedAssetSubpath = PathUtils.normalizePath(globalAssetSubpath);
                const baseBrowsePath = PathUtils.normalizePath(UserSettings.BASE_BROWSE_PATH);
                const markdownDir = PathUtils.getDirname(markdownFilePath);
                const postSlug = PathUtils.getSlugFromFilename(markdownFilePath);
                let subFolderPath = (markdownDir.startsWith(baseBrowsePath) && markdownDir.length > baseBrowsePath.length && markdownDir !== baseBrowsePath)
                    ? markdownDir.substring(baseBrowsePath.length + 1)
                    : '';
                let webPathPrefix = '/' + PathUtils.normalizePath(PathUtils.joinPaths(
                    UserSettings.OMIT_GLOBAL_ROOT_DIR_FROM_URL ? '' : normalizedRootDir,
                    normalizedAssetSubpath,
                    subFolderPath,
                    postSlug
                )) + '/';
                webPathPrefix = webPathPrefix.replace(/\/+/g, '/');
                return href.startsWith(webPathPrefix)
                    ? PathUtils.normalizePath(PathUtils.joinPaths(
                        normalizedRootDir,
                        normalizedAssetSubpath,
                        subFolderPath,
                        postSlug,
                        PathUtils.getBasename(href)
                    ))
                    : null;
            },
            parseManagedUploadLinks(markdownBody, markdownFilePath = null) {
                const links = new Set();
                if (!markdownBody || typeof marked === 'undefined' || !markdownFilePath) return links;
                const isAssetStrategyLocal = UserSettings.ASSET_STRATEGY === 'local';
                const isEditingBundleFile = PathUtils.isAnyBundlePath(markdownFilePath);
                const markdownLinkRegex = /(!?\[[^\]]*\]\()([^)]+)\)/g;
                let match;
                while ((match = markdownLinkRegex.exec(markdownBody)) !== null) {
                    let href = match[2] ? String(match[2]).trim() : null;
                    if (!href) continue;
                    try {
                        href = Utils.cleanUrl(href);
                        let githubPath = null;
                        const isPotentiallyRelative = !href.startsWith('/') &&
                            !href.startsWith('http') &&
                            !href.startsWith('#') &&
                            !href.startsWith('mailto:') &&
                            !href.includes(':') &&
                            !href.startsWith('blob:') &&
                            !href.startsWith('upload-placeholder:');
                        if (isPotentiallyRelative && isEditingBundleFile) {
                            githubPath = this.handleLocalLink(href, markdownFilePath, UserSettings.LOCAL_ASSET_SUBDIR);
                        } else if (href.startsWith('/') && !isEditingBundleFile && !isAssetStrategyLocal) {
                            githubPath = this.handleGlobalLink(href, markdownFilePath, UserSettings.GLOBAL_ROOT_DIR, UserSettings.GLOBAL_ASSET_SUBPATH);
                        }
                        if (githubPath) {
                            links.add(githubPath);
                        }
                    } catch (e) {
                    }
                }
                return links;
            },
            determineSaveTarget(isUpdate, newSlug, userEnteredPathValue, originalPath, currentDirectoryPath, userSettings) {
                let targetPath, targetFilename, isTargetLocalActual;
                const isConfigAssetStrategyLocal = userSettings.ASSET_STRATEGY === 'local';
                if (isUpdate) {
                    isTargetLocalActual = PathUtils.isAnyBundlePath(originalPath);
                    targetPath = PathUtils.normalizePath(originalPath);
                    targetFilename = PathUtils.getBasename(targetPath);
                } else {
                    isTargetLocalActual = isConfigAssetStrategyLocal;
                    const baseDirForLocal = PathUtils.joinPaths(currentDirectoryPath, newSlug);
                    if (isTargetLocalActual) {
                        let desiredFilename = PathUtils.getBasename(userEnteredPathValue).toLowerCase();
                        if (desiredFilename === 'index.md' || desiredFilename === '_index.md') {
                            targetFilename = desiredFilename;
                        } else {
                            targetFilename = 'index.md';
                        }
                        let dirPartFromUser = PathUtils.getDirname(userEnteredPathValue);
                        const finalBaseDir = (dirPartFromUser && dirPartFromUser !== '.' && dirPartFromUser !== '')
                            ? PathUtils.joinPaths(currentDirectoryPath, dirPartFromUser)
                            : baseDirForLocal;
                        targetPath = PathUtils.normalizePath(PathUtils.joinPaths(finalBaseDir, targetFilename));
                    } else {
                        targetFilename = `${newSlug}.md`;
                        targetPath = PathUtils.normalizePath(PathUtils.joinPaths(currentDirectoryPath, targetFilename));
                    }
                }
                return { targetPath, targetFilename, isTargetLocalActual };
            },
            async identifyResourcesToDelete(filePathToDelete, isBranchBundleIndexDelete, isLeafBundleIndexDelete, initialLinksSet, userSettings, gitHubService) {
                const allPathsToDelete = new Set();
                const addPathToDelete = (p) => { if (p) allPathsToDelete.add(PathUtils.normalizePath(p)); };
                if (isBranchBundleIndexDelete) {
                    UIManager.updateStatus(i18next.t('statusBar.identifyingBranchIndexResources', { filePath: filePathToDelete }), false, false, true);
                    addPathToDelete(filePathToDelete);
                    UIManager.updateStatus(i18next.t('statusBar.markedFileForDeletion', { filename: PathUtils.getBasename(filePathToDelete) }), false, false, true);
                    if (initialLinksSet?.size > 0) {
                        UIManager.updateStatus(i18next.t('statusBar.checkingAssocImages'), false, false, true);
                        let assetCount = 0;
                        initialLinksSet.forEach(assetPath => {
                            addPathToDelete(assetPath);
                            UIManager.updateStatus(i18next.t('statusBar.deletingUnusedImage', { image: PathUtils.getBasename(assetPath) }), false, false, true);
                            assetCount++;
                        });
                        UIManager.updateStatus(i18next.t('statusBar.imageCleanupSuccess', { count: assetCount }), false, assetCount > 0);
                    } else {
                        UIManager.updateStatus(i18next.t('statusBar.noInitialLinksFound'), false, false);
                    }
                } else if (isLeafBundleIndexDelete) {
                    const bundleDir = PathUtils.getDirname(filePathToDelete);
                    if (bundleDir) {
                        UIManager.updateStatus(i18next.t('statusBar.checkingBundleContents', { path: bundleDir }), false, false, true);
                        try {
                            const bundleContents = await gitHubService.getFolderContentsRecursive(bundleDir);
                            if (bundleContents?.length > 0) {
                                bundleContents.forEach(item => addPathToDelete(item.path));
                                UIManager.updateStatus(i18next.t('statusBar.bundleContentsIdentified', { count: bundleContents.length, path: bundleDir }), false, true);
                            } else if (bundleContents === null) {
                                this.handleGenericError(new Error("Folder not found"), i18next.t('statusBar.bundleContentsCheckFailed', { path: bundleDir, message: "Folder not found" }), "Delete Prep");
                                addPathToDelete(filePathToDelete);
                            } else {
                                UIManager.updateStatus(i18next.t('statusBar.bundleContentsIdentified', { count: 0, path: bundleDir }), false, true);
                                addPathToDelete(filePathToDelete);
                            }
                        } catch (error) {
                            this.handleGenericError(error, i18next.t('errors.bundleContentsCheckFailed', { path: bundleDir, message: error.message }), "Delete Prep");
                            throw new Error(i18next.t('errors.deleteBundleException', { path: bundleDir }));
                        }
                    }
                    addPathToDelete(filePathToDelete);
                } else {
                    addPathToDelete(filePathToDelete);
                    const unusedAssetPaths = await this.getFilesToDeleteBasedOnLinks(new Set(), initialLinksSet);
                    if (unusedAssetPaths.length > 0) {
                        UIManager.updateStatus(i18next.t('statusBar.cleaningImages', { count: unusedAssetPaths.length }), false, false, true);
                        unusedAssetPaths.forEach(p => {
                            addPathToDelete(p);
                            UIManager.updateStatus(i18next.t('statusBar.deletingUnusedImage', { image: PathUtils.getBasename(p) }), false, false, true);
                        });
                        UIManager.updateStatus(i18next.t('statusBar.imageCleanupSuccess', { count: unusedAssetPaths.length }), false, true);
                    } else {
                        UIManager.updateStatus(i18next.t('statusBar.noAssociatedAssetsFound'), false, false);
                    }
                    if (userSettings.ASSET_STRATEGY === 'global') {
                        const slugToDelete = PathUtils.getSlugFromFilename(filePathToDelete);
                        const baseBrowsePath = PathUtils.normalizePath(userSettings.BASE_BROWSE_PATH);
                        const contentDir = PathUtils.getDirname(filePathToDelete);
                        let contentRelativeDir = (contentDir.startsWith(baseBrowsePath + '/'))
                            ? contentDir.substring(baseBrowsePath.length + 1)
                            : (contentDir !== baseBrowsePath && contentDir !== '' ? contentDir : '');
                        const globalAssetDirPath = PathUtils.normalizePath(PathUtils.joinPaths(
                            userSettings.GLOBAL_ROOT_DIR,
                            userSettings.GLOBAL_ASSET_SUBPATH,
                            contentRelativeDir,
                            slugToDelete
                        ));
                        if (globalAssetDirPath) {
                            UIManager.updateStatus(i18next.t('statusBar.deletingLegacyDir', { path: globalAssetDirPath }), false, false, true);
                            try {
                                const globalContents = await gitHubService.getFolderContentsRecursive(globalAssetDirPath);
                                if (globalContents?.length > 0) {
                                    globalContents.forEach(item => addPathToDelete(item.path));
                                    UIManager.updateStatus(i18next.t('statusBar.legacyDirContentsIdentified', { count: globalContents.length, path: globalAssetDirPath }), false, true);
                                } else if (globalContents === null) {
                                    UIManager.updateStatus(i18next.t('statusBar.legacyAssetDirNotFound', { path: globalAssetDirPath }), false, false);
                                } else {
                                    UIManager.updateStatus(i18next.t('statusBar.legacyAssetDirEmpty', { path: globalAssetDirPath }), false, false);
                                }
                            } catch (globalError) {
                                this.handleGenericError(globalError, i18next.t('errors.legacyDirCheckFailed', { path: globalAssetDirPath, message: globalError.message }), "Global Asset Deletion Check");
                            }
                        }
                    }
                }
                return allPathsToDelete;
            },
            setupThemeHandling() {
                this.themeMediaQuery = window.matchMedia('(prefers-color-scheme: dark)');
                const applyTheme = (isDark) => {
                    document.body.classList.toggle('dark-mode', isDark);
                    if (VditorManager.instance && VditorManager.isReady) {
                        VditorManager.setTheme(isDark ? 'dark' : 'classic', isDark ? 'dark' : 'light');
                    }
                };
                applyTheme(this.themeMediaQuery.matches);
                this.themeMediaQuery.addEventListener('change', (e) => applyTheme(e.matches));
            },
            initializeVditor(initialValue = '') {
                VditorManager.init('fileContentInput', initialValue, this.themeMediaQuery, () => this.refreshEditorUIState())
                    .catch(error => this.handleGenericError(error, 'errors.vditorInitFailed', "Vditor Initialization"));
            },
            setupEventListeners() {
                this.elements.loginButton.addEventListener('click', () => this.handleLogin());
                this.elements.logoutButton.addEventListener('click', () => this.handleLogout());
                this.elements.repoSelect.addEventListener('change', () => {
                    this.elements.loadRepoButton.disabled = this.elements.repoSelect.value === '';
                });
                this.elements.loadRepoButton.addEventListener('click', () => this.loadSelectedRepo());
                this.elements.createNewFileButton.addEventListener('click', () => this.createNewFile());
                this.elements.saveDraftButton.addEventListener('click', () => this.saveFile('draft'));
                this.elements.publishButton.addEventListener('click', () => this.saveFile('publish'));
                this.elements.deleteFileButton.addEventListener('click', () => this.deleteFile());
                this.elements.cancelEditButton.addEventListener('click', () => this.cancelEdit());
                const editorInputHandler = () => this.refreshEditorUIState();
                this.elements.fmTitleInput.addEventListener('input', () => {
                    if (!AppState.currentFileSha) {
                        const title = this.elements.fmTitleInput.value;
                        const slug = PathUtils.generateFilename(title);
                        const isLocal = AppState.isCurrentOperationTargetingLocal();
                        const fullFilename = slug ? (isLocal ? `${slug}/index.md` : `${slug}.md`) : '';
                        this.elements.fileNameInput.value = fullFilename;
                        UIManager.setFilenameInputMode(isLocal);
                    }
                    this.updateGeneratedCommitMessage();
                    editorInputHandler();
                });
                this.elements.fileNameInput.addEventListener('input', () => {
                    this.updateGeneratedCommitMessage();
                    editorInputHandler();
                });
                this.elements.commitMessageInput.addEventListener('input', editorInputHandler);
                FM_FIELD_CONFIG.forEach(field => {
                    if (this.elements[field.elementId] && field.type !== 'datetime' && field.type !== 'array') {
                        this.elements[field.elementId].addEventListener('input', editorInputHandler);
                    }
                    if (this.elements[field.autoCheckboxId]) {
                        this.elements[field.autoCheckboxId].addEventListener('change', editorInputHandler);
                    }
                });
                this.elements.customFrontMatterContainer.addEventListener('input', (event) => {
                    if (event.target.matches('.custom-fm-key, .custom-fm-value')) {
                        editorInputHandler();
                    }
                });
                 this.elements.customFrontMatterContainer.addEventListener('change', (event) => {
                    if (event.target.matches('.custom-fm-type, .custom-fm-value[type="checkbox"]')) {
                        editorInputHandler();
                    }
                });
                if (this.elements.fileFilterInput) {
                    this.elements.fileFilterInput.addEventListener('input', this.handleFileFilter.bind(this));
                }
                if (this.elements.draftFilterCheckbox) {
                    this.elements.draftFilterCheckbox.addEventListener('change', this.handleFileFilter.bind(this));
                }
                window.addEventListener('storage', (event) => {
                    if (event.key === AppConstants.PAT_STORAGE_KEY && event.newValue === null && AppState.octokit) {
                        UIManager.updateStatus(i18next.t('statusBar.patChangedLogout'), false);
                        this.handleLogout();
                    }
                });
            },
            handleFileFilter() {
                if (!this.elements.fileFilterInput || !this.elements.draftFilterCheckbox || !this.elements.fileListUl || !this.elements.fileListEmptyMessage) return;
                const filterText = this.elements.fileFilterInput.value.toLowerCase().trim();
                const showOnlyDrafts = this.elements.draftFilterCheckbox.checked;
                const listItems = this.elements.fileListUl.querySelectorAll('li');
                let visibleCount = 0;
                let hasItemsOtherThanParent = false;
                listItems.forEach(li => {
                    const isParentLink = li.classList.contains('parent-dir');
                    const isErrorOrLoading = li.classList.contains('error') || li.querySelector('em.no-hover');
                    let shouldBeVisible = false;
                    if (!isParentLink && !isErrorOrLoading) {
                        hasItemsOtherThanParent = true;
                    }
                    if (isParentLink) {
                        shouldBeVisible = true;
                    } else if (isErrorOrLoading) {
                        shouldBeVisible = !showOnlyDrafts;
                    } else {
                        const itemName = (li.querySelector('.file-item-name')?.textContent || '').toLowerCase();
                        const isDraftItem = !!li.querySelector('.draft-indicator');
                        shouldBeVisible = (filterText === '' || itemName.includes(filterText)) &&
                            (!showOnlyDrafts || isDraftItem);
                    }
                    li.style.display = shouldBeVisible ? 'flex' : 'none';
                    if (shouldBeVisible && !isParentLink && !isErrorOrLoading) {
                        visibleCount++;
                    }
                });
                this.elements.fileListEmptyMessage.classList.toggle('hidden', !(
                    (filterText !== '' || showOnlyDrafts) &&
                    hasItemsOtherThanParent &&
                    visibleCount === 0
                ));
            },
            resetFileFilter() {
                if (this.elements.fileFilterInput) {
                    this.elements.fileFilterInput.value = '';
                }
                if (this.elements.draftFilterCheckbox) {
                    this.elements.draftFilterCheckbox.checked = false;
                }
                if (this.elements.fileListEmptyMessage) {
                    this.elements.fileListEmptyMessage.classList.add('hidden');
                }
                if (this.elements.fileListUl) {
                    this.elements.fileListUl.querySelectorAll('li').forEach(li => {
                        li.style.display = 'flex';
                    });
                }
            },
            async proceedAfterLogin() {
                UIManager.updateStatus(i18next.t('statusBar.authSuccess'), false, true);
                const storedRepo = localStorage.getItem(AppConstants.SELECTED_REPO_KEY);
                if (storedRepo && storedRepo.includes('/')) {
                    UIManager.updateStatus(i18next.t('statusBar.loadingStoredRepo', { repo: storedRepo }), false, false, true);
                    const [owner, repo] = storedRepo.split('/');
                    AppState.setRepo(owner, repo);
                    this.elements.currentBranchName.textContent = AppState.branch;
                    this.elements.currentRepoSpan.textContent = storedRepo;
                    UIManager.showSection('main');
                    try {
                        await this.loadDraftStatus();
                        if (AppState.urlActionPath) {
                            UIManager.updateStatus(i18next.t('statusBar.urlAction', { path: AppState.urlActionPath }), false, false, true);
                            await this.handleUrlAction(AppState.urlActionPath);
                        } else {
                            UIManager.updateStatus(i18next.t('statusBar.loadingRepo', { repo: storedRepo, path: UserSettings.BASE_BROWSE_PATH }), false, false, true);
                            await this.browsePath(UserSettings.BASE_BROWSE_PATH);
                        }
                        return;
                    } catch (error) {
                        this.handleGenericError(error, i18next.t('errors.storedRepoLoadFailed', { repo: storedRepo }), "Stored Repo Load");
                        localStorage.removeItem(AppConstants.SELECTED_REPO_KEY);
                        AppState.owner = null;
                        AppState.repo = null;
                        UIManager.showSection('repo');
                    }
                } else {
                    UIManager.updateStatus(i18next.t('statusBar.loadingRepoList'), false, false, true);
                    const repoResult = await GitHubService.listRepos();
                    if (repoResult.success) {
                        UIManager.populateRepoSelect(repoResult.repos);
                        UIManager.setLoginSuccess(true);
                        UIManager.showSection('repo');
                        UIManager.updateStatus(
                            repoResult.repos.length > 0
                                ? i18next.t('statusBar.repoLoaded', { count: repoResult.repos.length })
                                : i18next.t('errors.noAccessibleRepos'),
                            !repoResult.repos.length,
                            repoResult.repos.length > 0
                        );
                    } else {
                        this.handleApiError(repoResult.error, i18next.t('errors.repoListFailed'));
                        UIManager.setLoginSuccess(true);
                        UIManager.showSection('repo');
                    }
                }
                UIManager.setRepoLoading(false);
            },
            async handleLogin() {
                const token = this.elements.patInput.value.trim();
                if (!token) {
                    this.handleGenericError(null, 'errors.patRequired', "Login");
                    this.elements.patInput.focus();
                    return;
                }
                UIManager.setLoginLoading(true);
                UIManager.updateStatus(i18next.t('statusBar.authInProgress'), false, false, true);
                const authResult = await GitHubService.authenticate(token);
                if (authResult.success) {
                    UIManager.setLoginSuccess(true);
                    localStorage.setItem(AppConstants.PAT_STORAGE_KEY, token);
                    await this.proceedAfterLogin();
                } else {
                    localStorage.removeItem(AppConstants.PAT_STORAGE_KEY);
                    AppState.octokit = null;
                    this.handleApiError(authResult.error, i18next.t('errors.authFailed'));
                    UIManager.resetLoginScreen();
                    UIManager.setLoginLoading(false);
                }
            },
            async autoLogin(token) {
                UIManager.setLoginLoading(true);
                UIManager.updateStatus(i18next.t('statusBar.autoLoginInProgress'), false, false, true);
                this.elements.patInput.value = '********';
                const authResult = await GitHubService.authenticate(token);
                if (authResult.success) {
                    UIManager.setLoginSuccess(true);
                    await this.proceedAfterLogin();
                } else {
                    this.handleApiError(authResult.error, i18next.t('errors.authFailed'));
                    localStorage.removeItem(AppConstants.PAT_STORAGE_KEY);
                    UIManager.resetLoginScreen();
                    UIManager.updateStatus(i18next.t('statusBar.autoLoginFailed'), true);
                }
            },
            handleLogout() {
                this.setBaseTag(null);
                localStorage.removeItem(AppConstants.PAT_STORAGE_KEY);
                localStorage.removeItem(AppConstants.SELECTED_REPO_KEY);
                AppState.octokit = null;
                AppState.owner = null;
                AppState.repo = null;
                AppState.urlActionPath = null;
                UIManager.removeActiveFileHighlight();
                AppState.clearEditingFile();
                if (VditorManager.instance) {
                    VditorManager.destroy();
                }
                UIManager.resetLoginScreen();
                UIManager.updateStatus(i18next.t('statusBar.logout'), false, true);
                history.replaceState(null, '', location.pathname);
            },
            async loadSelectedRepo() {
                this.setBaseTag(null);
                UIManager.removeActiveFileHighlight();
                const selectedRepoFullName = this.elements.repoSelect.value;
                if (!selectedRepoFullName || !selectedRepoFullName.includes('/')) {
                    this.handleGenericError(null, 'errors.invalidRepo', "Load Repo");
                    return;
                }
                if (!AppState.octokit) {
                    this.handleLogout();
                    return;
                }
                const [owner, repo] = selectedRepoFullName.split('/');
                AppState.setRepo(owner, repo);
                this.elements.currentBranchName.textContent = AppState.branch;
                this.elements.currentRepoSpan.textContent = selectedRepoFullName;
                UIManager.setRepoLoading(true, selectedRepoFullName);
                localStorage.setItem(AppConstants.SELECTED_REPO_KEY, selectedRepoFullName);
                UIManager.showSection('main');
                await this.loadDraftStatus();
                if (AppState.urlActionPath) {
                    await this.handleUrlAction(AppState.urlActionPath);
                } else {
                    UIManager.updateStatus(i18next.t('statusBar.loadingRepo', { repo: selectedRepoFullName, path: UserSettings.BASE_BROWSE_PATH }), false, false, true);
                    await this.browsePath(UserSettings.BASE_BROWSE_PATH);
                }
            },
            async handleUrlAction(actionPath) {
                if (!AppState.owner || !AppState.repo) {
                    this.handleGenericError(null, 'errors.repoNotSet', "URL Action");
                    UIManager.showSection('repo');
                    UIManager.setRepoLoading(false);
                    return;
                }
                const normalizedActionPath = PathUtils.normalizePath(actionPath);
                const fullBasePath = PathUtils.normalizePath(UserSettings.BASE_BROWSE_PATH);
                UIManager.removeActiveFileHighlight();
                try {
                    if (normalizedActionPath === 'new' || normalizedActionPath.endsWith('/new')) {
                        let targetPath = fullBasePath;
                        if (normalizedActionPath !== 'new') {
                            targetPath = PathUtils.normalizePath(PathUtils.joinPaths(fullBasePath, PathUtils.getDirname(normalizedActionPath)));
                        }
                        UIManager.updateStatus(i18next.t('statusBar.urlActionNew', { path: targetPath }), false, true);
                        AppState.setCurrentPath(targetPath);
                        this.createNewFile();
                    } else {
                        UIManager.updateStatus(i18next.t('statusBar.searchingContent', { slug: normalizedActionPath }), false, false, true);
                        await this.findAndEditContentBySlug(normalizedActionPath);
                    }
                } catch (error) {
                    this.handleGenericError(error, i18next.t('errors.urlActionFailed'), "URL Action Handling");
                    await this.browsePath(AppState.currentPath || UserSettings.BASE_BROWSE_PATH);
                } finally {
                    AppState.urlActionPath = null;
                    history.replaceState(null, '', location.pathname);
                    UIManager.setRepoLoading(false);
                }
            },
            async findAndEditContentBySlug(baseSlug) {
                const fullBasePath = PathUtils.normalizePath(UserSettings.BASE_BROWSE_PATH);
                const normalizedSlug = PathUtils.normalizePath(baseSlug);
                const pathsToTry = [
                    PathUtils.joinPaths(fullBasePath, normalizedSlug, 'index.md'),
                    PathUtils.joinPaths(fullBasePath, normalizedSlug, '_index.md'),
                    PathUtils.joinPaths(fullBasePath, normalizedSlug + '.md')
                ];
                let foundFile = null;
                let fallbackPath = PathUtils.joinPaths(fullBasePath, normalizedSlug);
                if (!fallbackPath.startsWith(fullBasePath)) {
                    fallbackPath = fullBasePath;
                }
                for (const filePath of pathsToTry) {
                    const dirPath = PathUtils.getDirname(filePath);
                    UIManager.updateStatus(i18next.t('statusBar.searchAttempt', { path: filePath }), false, false, true);
                    const dirResult = await GitHubService.getContent(dirPath);
                    if (dirResult.success) {
                       if(PathUtils.normalizePath(dirPath) !== PathUtils.normalizePath(fallbackPath) && !fallbackPath.startsWith(PathUtils.normalizePath(dirPath))) {
                           fallbackPath = dirPath;
                       }
                       const fileInDir = dirResult.items.find(item => item.type === 'file' && PathUtils.normalizePath(item.path) === PathUtils.normalizePath(filePath));
                        if (fileInDir) {
                            foundFile = fileInDir;
                            break;
                        }
                    } else if (!dirResult.notFound) {
                        throw dirResult.error;
                    }
                }
                if (foundFile) {
                    UIManager.updateStatus(i18next.t('statusBar.fileFound', { filename: PathUtils.getBasename(foundFile.path) }), false, false, true);
                    await this.editFile(foundFile.path, foundFile.sha);
                } else {
                    UIManager.updateStatus(i18next.t('statusBar.contentNotFound', { slug: baseSlug }), true);
                    await this.browsePath(fallbackPath);
                }
            },
            async requestBrowseAction(targetPath) {
                 if (AppState.currentView === 'edit' && VditorManager.isReady) {
                    const processedFormData = await this.getProcessedEditorFormData();
                    if (AppState.isModified(processedFormData)) {
                        if (confirm(i18next.t('prompts.confirmCancel'))) {
                            UIManager.removeActiveFileHighlight();
                            await this.browsePath(targetPath);
                        } else {
                           UIManager.updateStatus(i18next.t('prompts.cancelAbort'));
                        }
                    } else {
                        UIManager.removeActiveFileHighlight();
                        await this.browsePath(targetPath);
                    }
                } else {
                    UIManager.removeActiveFileHighlight();
                    await this.browsePath(targetPath);
                }
            },
             async requestEditAction(filePath, fileSha) {
                 if (AppState.currentView === 'edit' && VditorManager.isReady) {
                     const processedFormData = await this.getProcessedEditorFormData();
                     if (AppState.isModified(processedFormData)) {
                         if (confirm(i18next.t('prompts.confirmCancel'))) {
                            UIManager.removeActiveFileHighlight();
                            await this.editFile(filePath, fileSha);
                        } else {
                            UIManager.updateStatus(i18next.t('prompts.cancelAbort'));
                        }
                    } else {
                        UIManager.removeActiveFileHighlight();
                        await this.editFile(filePath, fileSha);
                    }
                } else {
                    await this.editFile(filePath, fileSha);
                }
            },
            async refreshFileBrowserForPath(p) {
                if (!AppState.octokit) { this.handleLogout(); return; }
                let normalizedPath = PathUtils.normalizePath(p || UserSettings.BASE_BROWSE_PATH);
                const normalizedBasePath = PathUtils.normalizePath(UserSettings.BASE_BROWSE_PATH);
                if (normalizedPath !== normalizedBasePath && !normalizedPath.startsWith(normalizedBasePath + '/')) {
                    normalizedPath = normalizedBasePath;
                }
                AppState.setCurrentPath(normalizedPath);
                UIManager.updateBreadcrumb(normalizedPath);
                UIManager.setFileListLoading(true, normalizedPath);
                try {
                    const result = await GitHubService.getContent(normalizedPath);
                    UIManager.setFileListLoading(false, normalizedPath);
                    if (result.success) {
                        UIManager.renderFileList(result.items, normalizedPath);
                    } else {
                        const errorMsgKey = result.notFound ? 'browser.errorNotFound' : 'browser.errorLoading';
                        const errorMsg = i18next.t(errorMsgKey, { path: normalizedPath });
                        UIManager.renderFileList([], normalizedPath);
                        if (this.elements.fileListUl) {
                            this.elements.fileListUl.innerHTML += `<li class="error no-hover">âŒ ${errorMsg}</li>`;
                        }
                    }
                } catch (error) {
                    UIManager.setFileListLoading(false, normalizedPath);
                    this.handleGenericError(error, i18next.t('errors.folderBrowseException', { path: normalizedPath }), "Refresh File Browser", { path: normalizedPath });
                    UIManager.renderFileList([], normalizedPath);
                    if (this.elements.fileListUl) {
                        this.elements.fileListUl.innerHTML += `<li class="error no-hover">âŒ ${i18next.t('errors.browserErrorLoadingSevere')}</li>`;
                    }
                } finally {
                    App.updateNewFileButtonUI();
                    this.resetFileFilter();
                }
            },
            async browsePath(p) {
                if (!AppState.octokit) {
                    this.handleLogout();
                    return;
                }
                UIManager.setEditorSaving(false);
                UIManager.removeActiveFileHighlight();
                AppState.clearEditingFile();
                UIManager.setBrowseOnlyState();
                await this.refreshFileBrowserForPath(p);
                UIManager.updateStatus(i18next.t('statusBar.folderLoaded', { path: `${AppState.owner}/${AppState.repo}/${AppState.currentPath}` }), false, true);
                UIManager.setRepoLoading(false);
            },
            async editFile(filePath, fileSha) {
                if (!AppState.octokit) {
                    this.handleLogout();
                    return;
                }
                UIManager.removeActiveFileHighlight();
                AppState.clearEditingFile();
                UIManager.updateStatus(i18next.t('statusBar.loadingFile', { path: filePath }), false, false, true);
                this.elements.createNewFileButton.disabled = true;
                if (this.elements.fileListUl) {
                    this.elements.fileListUl.style.pointerEvents = 'none';
                    this.elements.fileListUl.style.opacity = 0.6;
                }
                UIManager.setEditorSaving(false);
                try {
                    const result = await GitHubService.getFileContent(filePath, fileSha);
                    if (result.success) {
                        await this.initializeEditorForFile(result);
                        UIManager.setEditState();
                        this.elements.createNewFileButton.disabled = false;
                        if (this.elements.fileListUl) {
                            this.elements.fileListUl.style.pointerEvents = 'auto';
                            this.elements.fileListUl.style.opacity = 1.0;
                        }
                        const fileDir = PathUtils.getDirname(filePath) || UserSettings.BASE_BROWSE_PATH;
                        await this.refreshFileBrowserForPath(fileDir);
                    } else {
                        this.handleApiError(result.error, i18next.t('errors.fileLoadFailed', { path: result.path }), { path: result.path, sha: result.sha });
                        UIManager.setBrowseOnlyState();
                        await this.browsePath(PathUtils.getDirname(filePath) || AppState.currentPath || UserSettings.BASE_BROWSE_PATH);
                        this.elements.createNewFileButton.disabled = false;
                        if (this.elements.fileListUl) {
                            this.elements.fileListUl.style.pointerEvents = 'auto';
                            this.elements.fileListUl.style.opacity = 1.0;
                        }
                    }
                } catch (error) {
                    this.elements.createNewFileButton.disabled = false;
                    if (this.elements.fileListUl) {
                        this.elements.fileListUl.style.pointerEvents = 'auto';
                        this.elements.fileListUl.style.opacity = 1.0;
                    }
                    this.handleGenericError(error, i18next.t('errors.fileEditPrepException', { path: filePath }), "Edit File Prep", { path: filePath });
                    UIManager.setBrowseOnlyState();
                    await this.browsePath(PathUtils.getDirname(filePath) || AppState.currentPath || UserSettings.BASE_BROWSE_PATH);
                } finally {
                    UIManager.setRepoLoading(false);
                }
            },
            async initializeEditorForFile(fileData) {
                const { path: filePath, sha: fileSha, frontMatter: parsedFrontMatter, body: rawBody, type: fmType } = fileData;
                AppState.clearDraftAssets();
                this.reverseDraftAssetMap = {};
                AppState.setCurrentPath(PathUtils.normalizePath(PathUtils.getDirname(filePath) || UserSettings.BASE_BROWSE_PATH));
                let currentBodyForEditor = rawBody;
                if (PathUtils.isAnyBundlePath(filePath)) {
                    const isDraftBundle = AppState.isDraft(filePath);
                    if (isDraftBundle && UserSettings.ASSET_STRATEGY === 'local') {
                        this.setBaseTag(null);
                        const assetRelativePaths = new Set();
                        const mdLinkRegex = /(!?\[[^\]]*\]\()(?!(?:[a-z]+:|\/|#|blob:))([^")\s]+)((?:["'](?:[^"']*)["'])?\))/g;
                        let match;
                        while ((match = mdLinkRegex.exec(rawBody)) !== null) {
                            if (match[2]) {
                                const cleanRelativePath = match[2].split(/[?#]/)[0];
                                assetRelativePaths.add(cleanRelativePath);
                            }
                        }
                        for (const relativeAssetPath of assetRelativePaths) {
                            const fullAssetPathInRepo = PathUtils.joinPaths(PathUtils.getDirname(filePath), relativeAssetPath);
                            try {
                                const assetContentResult = await GitHubService.getRawAssetContent(fullAssetPathInRepo);
                                if (assetContentResult.success && assetContentResult.content) {
                                    const mimeType = PathUtils.getMimeTypeFromPath(fullAssetPathInRepo);
                                    const assetBlob = Utils.base64ToBlob(assetContentResult.content, mimeType);
                                    const blobUrl = URL.createObjectURL(assetBlob);
                                    AppState.draftAssets[relativeAssetPath] = blobUrl;
                                    this.reverseDraftAssetMap[blobUrl] = relativeAssetPath;
                                }
                            } catch (assetError) {
                            this.handleGenericError(assetError, `Failed to load draft asset: ${relativeAssetPath}`, "Draft Asset Load");
                            }
                        }
                        if (UserSettings.VDITOR_EDIT_MODE === 'ir' || UserSettings.VDITOR_EDIT_MODE === 'wysiwyg') {
                        currentBodyForEditor = this.replaceRelativePathsWithDraftAssetBlobs(rawBody);
                        }
                    } else if (!isDraftBundle) {
                        try {
                            const mapKey = PathUtils.getMapKeyFromFilePath(filePath);
                            let webPathForBase = (window.hugoPermalinkMap && typeof window.hugoPermalinkMap === 'object' && window.hugoPermalinkMap.hasOwnProperty(mapKey))
                                ? ('/' + PathUtils.normalizePath(window.hugoPermalinkMap[mapKey]) + '/').replace(/\/+/g, '/')
                                : PathUtils.calculateBaseTagPath(filePath);
                            this.setBaseTag(new URL(webPathForBase, window.location.origin).href);
                        } catch (e) {
                            this.handleGenericError(e, "Error setting base href", "Base Tag", { filePath });
                            this.setBaseTag(null);
                        }
                    } else {
                        this.setBaseTag(null);
                    }
                } else {
                    this.setBaseTag(null);
                }
                try {
                    if (!VditorManager.instance) {
                        await VditorManager.init('fileContentInput', currentBodyForEditor, this.themeMediaQuery, () => this.refreshEditorUIState());
                    } else {
                        await VditorManager.setValue(currentBodyForEditor);
                    }
                    await VditorManager.awaitReady();
                } catch (initError) {
                    this.handleGenericError(initError, 'errors.vditorInitFailed', "Vditor Init (Edit)");
                    await this.browsePath(PathUtils.getDirname(filePath) || AppState.currentPath || UserSettings.BASE_BROWSE_PATH);
                    return;
                }
                const initialDraftStateFromFM = parsedFrontMatter.draft === true;
                const initialHasLastmodFromFM = parsedFrontMatter.hasOwnProperty('lastmod') && parsedFrontMatter.lastmod != null && String(parsedFrontMatter.lastmod).trim() !== '';
                await UIManager.populateEditor(filePath, parsedFrontMatter, fmType, initialDraftStateFromFM, initialHasLastmodFromFM);
                const initialVditorBodyContent = await VditorManager.getValue();
                const initialLinks = this.parseManagedUploadLinks(this.restoreBlobURLsToRelativePathsInBody(initialVditorBodyContent), filePath);
                const initialFmDataForState = this.prepareInitialFmDataForState(parsedFrontMatter);
                AppState.setEditingFile(filePath, fileSha, initialFmDataForState, rawBody, initialLinks, initialDraftStateFromFM, initialHasLastmodFromFM);
                UIManager.setFilenameInputMode(AppState.isEditingAnyBundle);
                this.elements.fileNameInput.disabled = true;
                this.elements.fileNameInput.title = i18next.t('editor.fm.fileNameDisabledTooltip');
                this.updateGeneratedCommitMessage();
                await this.refreshEditorUIState();
                let fmInfoKey = fmType === 'yaml' ? 'statusBar.fmInfoYAML'
                            : fmType === 'toml' ? 'statusBar.fmInfoTOML'
                            : (fmType === 'none' ? 'statusBar.fmInfoNone' : '');
                UIManager.updateStatus(i18next.t(
                    fmType === 'error' ? 'statusBar.fileLoadedWithError' : 'statusBar.fileLoaded',
                    { path: filePath, fmInfo: fmInfoKey ? i18next.t(fmInfoKey) : '' }
                ), fmType === 'error', true);
                VditorManager.focus();
            },
            prepareInitialFmDataForState(parsedFrontMatter) {
                const initialFmData = { custom: {} };
                FM_FIELD_CONFIG.forEach(field => {
                    const value = parsedFrontMatter[field.key];
                    if (field.type === 'datetime') {
                        let dateString = '';
                        if (value) {
                            try {
                                let dateInput = (typeof value === 'number') ? new Date(value) : value;
                                let parsedDate = (dateInput instanceof Date)
                                    ? dateInput
                                    : (flatpickr.parseDate(String(dateInput), "Z") || flatpickr.parseDate(String(dateInput), "Y-m-d H:i:S") || flatpickr.parseDate(String(dateInput), "Y-m-d H:i") || flatpickr.parseDate(String(dateInput), "Y-m-d") || new Date(dateInput));
                                if (parsedDate && !isNaN(parsedDate.getTime())) {
                                    dateString = flatpickr.formatDate(parsedDate, "Y-m-d H:i");
                                } else {
                                    dateString = String(value);
                                }
                            } catch (e) { dateString = String(value); }
                        }
                        initialFmData[field.key] = dateString;
                    } else if (field.type === 'array') {
                        initialFmData[field.key] = (Array.isArray(value) ? value.map(String) : (value ? String(value).split(',').map(t => t.trim()) : []))
                            .filter(t => t)
                            .sort();
                    } else {
                        initialFmData[field.key] = value || '';
                    }
                });
                const standardKeysLower = AppConstants.STANDARD_FM_KEYS.map(k => k.toLowerCase());
                for (const key in parsedFrontMatter) {
                    if (Object.hasOwnProperty.call(parsedFrontMatter, key) && !standardKeysLower.includes(key.toLowerCase())) {
                        let val = parsedFrontMatter[key];
                        if (Array.isArray(val)) {
                            initialFmData.custom[key] = val.map(String).filter(Boolean).sort();
                        } else {
                            initialFmData.custom[key] = val;
                        }
                    }
                }
                initialFmData.draft = parsedFrontMatter.draft === true;
                return initialFmData;
            },
            async createNewFile() {
                if (!AppState.octokit) {
                    this.handleLogout();
                    return;
                }
                AppState.clearDraftAssets();
                this.reverseDraftAssetMap = {};
                UIManager.removeActiveFileHighlight();
                this.elements.createNewFileButton.disabled = true;
                const isLocalMode = AppState.isCurrentOperationTargetingLocal();
                UIManager.setFilenameInputMode(isLocalMode);
                this.elements.fileNameInput.disabled = false;
                this.elements.fileNameInput.title = '';
                this.setBaseTag(null);
                UIManager.updateStatus(i18next.t(
                    isLocalMode ? 'statusBar.newFileCreationReadyBundle' : 'statusBar.newFileCreationReady',
                    { path: AppState.currentPath }
                ), false, false, true);
                UIManager.setEditState();
                UIManager.clearEditorFields(true);
                UIManager.initDateField(UIManager.elements.fmDateInput, 'date', '', true, true);
                UIManager.elements.fmLastmodContainer.classList.add('hidden');
                UIManager.initDateField(UIManager.elements.fmLastmodInput, 'lastmod', '', true, true);
                ['fmTagsInput', 'fmCategoriesInput'].forEach(elId => {
                    const inputEl = UIManager.elements[elId];
                    if (inputEl) UIManager.manageTagifyInstance(inputEl, true, '');
                });
                AppState.initialDraftState = false;
                AppState.initialHasLastmod = false;
                try {
                    if (!VditorManager.instance) {
                        await VditorManager.init('fileContentInput', ' ', this.themeMediaQuery, () => this.refreshEditorUIState());
                    } else {
                        await VditorManager.setValue(' ');
                    }
                    await VditorManager.awaitReady();
                    UIManager.setEditorButtonLabels(false, false);
                    this.updateGeneratedCommitMessage();
                    this.refreshEditorUIState();
                    UIManager.setEditorSaving(false);
                    try {
                        this.elements.fmTitleInput.focus();
                    } catch(e) {
                        this.handleGenericError(e, 'errors.titleFocus', "Create New File Focus");
                    }
                    await this.refreshFileBrowserForPath(AppState.currentPath);
                } catch (error) {
                    UIManager.setEditorSaving(false);
                    this.handleGenericError(error, 'errors.vditorInitFailed', "Vditor Init (New)");
                    await this.browsePath(AppState.currentPath || UserSettings.BASE_BROWSE_PATH);
                }
            },
            async getProcessedEditorFormData() {
                const rawData = UIManager.getRawEditorFormData();
                const processedData = {
                    custom: [],
                    commitMessage: rawData.commitMessage,
                    fullPathValue: rawData.fullPathValue,
                    date: rawData.date,
                    dateAutoChecked: rawData.dateAutoChecked,
                    lastmod: rawData.lastmod,
                    lastmodAutoChecked: rawData.lastmodAutoChecked,
                    title: rawData.title,
                    author: rawData.author,
                    description: rawData.description,
                    tags: rawData.tags,
                    categories: rawData.categories
                };
                rawData.custom.forEach(customItem => {
                    if (customItem.type === 'array') {
                        processedData.custom.push({
                            ...customItem,
                            value: Array.isArray(customItem.value) ? [...customItem.value] : []
                        });
                    } else {
                        processedData.custom.push(customItem);
                    }
                });
                try {
                    processedData.body = await VditorManager.getValue();
                } catch (e) {
                    this.handleGenericError(e, "Failed to get Vditor content", "Get Form Data");
                    processedData.body = AppState.initialBodyContent;
                }
                const fullPath = rawData.fullPathValue;
                if (PathUtils.isAnyBundlePath(fullPath)) {
                     processedData.slugOrFilename = PathUtils.getSlugFromFilename(fullPath);
                 } else if (fullPath.toLowerCase().endsWith('.md')) {
                    processedData.slugOrFilename = fullPath.substring(0, fullPath.lastIndexOf('.')).split('/').pop();
                } else {
                    processedData.slugOrFilename = fullPath.split('/').pop();
                }
                return processedData;
            },
            updateGeneratedCommitMessage() {
                const rawData = UIManager.getRawEditorFormData();
                const isUpdate = !!AppState.currentFileSha;
                let displayPath = rawData.fullPathValue;
                if (!displayPath && rawData.title) {
                    const slug = PathUtils.generateFilename(Array.isArray(rawData.title) ? rawData.title[0] : rawData.title);
                    displayPath = AppState.isCurrentOperationTargetingLocal()
                        ? `${slug}/index.md`
                        : `${slug}.md`;
                }
                const commitKey = displayPath ? (isUpdate ? 'commit.update' : 'commit.create') : '';
                const msg = commitKey ? i18next.t(commitKey, { path: displayPath }) : '';
                UIManager.setCommitMessage(msg, msg
                    ? `${i18next.t('editor.commitMessagePlaceholder')} (e.g., ${msg})`
                    : i18next.t('editor.commitMessagePlaceholder')
                );
            },
            async refreshEditorUIState() {
                requestAnimationFrame(async () => {
                    const dateInputElement = UIManager.elements.fmDateInput;
                    const dateCheckboxElement = UIManager.elements.fmDateAutoCheckbox;
                    const lastmodInputElement = UIManager.elements.fmLastmodInput;
                    const lastmodCheckboxElement = UIManager.elements.fmLastmodAutoCheckbox;
                    if (dateInputElement && dateCheckboxElement) {
                        const shouldBeDisabled = dateCheckboxElement.checked;
                        if (dateInputElement.disabled !== shouldBeDisabled) {
                            dateInputElement.disabled = shouldBeDisabled;
                        }
                        const dateLabelElement = UIManager.elements.fmDateAutoLabel;
                        if (dateLabelElement) {
                            dateLabelElement.textContent = dateCheckboxElement.checked ? i18next.t('editor.fm.autoSetToNow') : i18next.t('editor.fm.manualInput');
                        }
                    }
                    if (lastmodInputElement && lastmodCheckboxElement && !UIManager.elements.fmLastmodContainer.classList.contains('hidden')) {
                        const shouldBeDisabled = lastmodCheckboxElement.checked;
                        if (lastmodInputElement.disabled !== shouldBeDisabled) {
                            lastmodInputElement.disabled = shouldBeDisabled;
                        }
                        const lastmodLabelElement = UIManager.elements.fmLastmodAutoLabel;
                        if (lastmodLabelElement) {
                            lastmodLabelElement.textContent = lastmodCheckboxElement.checked ? i18next.t('editor.fm.autoSetToNow') : i18next.t('editor.fm.manualInput');
                        }
                    }
                    if (!document.getElementById('fileContentInput') || !VditorManager.isReady) {
                        UIManager.setEditorActionButtonsState(false, false, !!AppState.currentFileSha, true);
                        return;
                    }
                    const formData = await this.getProcessedEditorFormData();
                    const isEditing = !!AppState.currentFileSha;
                    const hasChanges = AppState.isModified(formData);
                    let canSaveDraft, canPublish;
                    if (isEditing) {
                        canSaveDraft = AppState.initialDraftState ? hasChanges : true;
                        canPublish = AppState.initialDraftState ? true : hasChanges;
                    } else {
                        const hasRequiredFields = !!formData.title && !!formData.fullPathValue;
                        canSaveDraft = hasRequiredFields;
                        canPublish = hasRequiredFields;
                    }
                    UIManager.setEditorActionButtonsState(canSaveDraft, canPublish, isEditing, true );
                });
            },
            updateNewFileButtonUI() {
                const dirName = PathUtils.getBasename(AppState.currentPath) || UserSettings.BASE_BROWSE_PATH;
                const text = i18next.t('browser.newFileButtonInFolder', { dirName });
                let title = '', hidden = false, disabled = false;
                const isBrowserVisible = UIManager.elements.fileBrowserSection && !UIManager.elements.fileBrowserSection.classList.contains('hidden');
                const isEditing = AppState.currentView === 'edit';
                const isFileListLoading = UIManager.elements.fileListUl?.querySelector('em.no-hover');
                hidden = (isEditing && !window.matchMedia("(max-width: 63.999rem)").matches) || !!isFileListLoading;
                disabled = hidden;
                if (!hidden && UIManager.elements.fileListUl) {
                    const isLeafBundle = Array.from(UIManager.elements.fileListUl.querySelectorAll('li.file'))
                        .some(li => li.dataset.path && PathUtils.isPageBundlePath(li.dataset.path));
                    if (isLeafBundle && UserSettings.ASSET_STRATEGY === 'local') {
                         hidden = true;
                         disabled = true;
                         title = i18next.t('browser.newFileButtonDisabledLeafBundleTooltip');
                    }
                }
                UIManager.setNewFileButtonUI(text, title, hidden, disabled);
            },
            replaceRelativePathsWithDraftAssetBlobs(markdownContent) {
                if (!markdownContent || Object.keys(AppState.draftAssets).length === 0) {
                    return markdownContent;
                }
                let newContent = markdownContent;
                const mdLinkRegex = /(!?\[[^\]]*\]\()(?!(?:[a-z]+:|\/|#|blob:))([^")\s]+)((?:["'](?:[^"']*)["'])?\))/g;
                newContent = newContent.replace(mdLinkRegex, (match, prefix, relativePath, suffix) => {
                    const cleanRelativePath = relativePath.split(/[?#]/)[0];
                    const blobUrl = AppState.draftAssets[cleanRelativePath];
                    if (blobUrl) {
                        const fragment = relativePath.substring(cleanRelativePath.length);
                        const replacement = `${prefix}${blobUrl}${fragment}${suffix}`;
                        return replacement;
                    }
                    return match;
                });
                return newContent;
            },
            restoreBlobURLsToRelativePathsInBody(markdownContent) {
                if (!markdownContent || Object.keys(this.reverseDraftAssetMap).length === 0) {
                    return markdownContent;
                }
                let newContent = markdownContent;
                for (const blobUrl in this.reverseDraftAssetMap) {
                    if (Object.hasOwnProperty.call(this.reverseDraftAssetMap, blobUrl)) {
                        const relativePath = this.reverseDraftAssetMap[blobUrl];
                        const escapedBlobUrl = PathUtils.escapeRegex(blobUrl);
                        const regex = new RegExp(`(!?\\[[^\\]]*\\]\\()${escapedBlobUrl}([^)]*)(\\))`, 'g');
                        newContent = newContent.replace(regex, (match, prefix, fragment, suffix) => {
                            const replacement = `${prefix}${relativePath}${fragment}${suffix}`;
                            return replacement;
                        });
                    }
                }
                return newContent;
            },
            async prepareUploads(markdownBody, postSlug, markdownDirPath, isTargetLocalActual) {
                const uploadsToCommit = [];
                let updatedBody = markdownBody;
                const markdownLinkRegex = /(!?\[[^\]]*?\]\()((?:upload-placeholder:)?blob:http[^)]+)\)/g;
                const matches = Array.from(markdownBody.matchAll(markdownLinkRegex));
                if (matches.length === 0) {
                    return { updatedBody: markdownBody, uploadsToCommit };
                }
                UIManager.updateStatus(i18next.t('statusBar.uploadingImages', { count: matches.length }), false, false, true);
                const processedPendingKeys = new Set();
                for (const match of matches) {
                    const markdownPrefix = match[1];
                    const originalUrlInMarkdown = match[2];
                    const isPlaceholder = originalUrlInMarkdown.startsWith('upload-placeholder:');
                    const blobPart = isPlaceholder ? originalUrlInMarkdown.substring('upload-placeholder:'.length) : originalUrlInMarkdown;
                    const keyForPendingUploads = Utils.cleanUrl(blobPart);
                    const fileObject = AppState.pendingUploads[keyForPendingUploads];
                    if (!fileObject) {
                        continue;
                    }
                    let finalPathForMarkdownDisplay;
                    if (!processedPendingKeys.has(keyForPendingUploads)) {
                        UIManager.updateStatus(i18next.t('statusBar.uploadingImage', { filename: fileObject.name }), false, false, true);
                        try {
                            const sanitizedFullName = PathUtils.sanitizeFilename(fileObject.name);
                            const ext = path.extname(sanitizedFullName);
                            const baseNameOnly = path.basename(sanitizedFullName, ext);
                            const unixTimestampInMilliseconds = Date.now();
                            const uniqueFilename = `${unixTimestampInMilliseconds}.${baseNameOnly}${ext}`;
                            let githubFilePath;
                            if (isTargetLocalActual) {
                                const normalizedLocalAssetSubdir = PathUtils.normalizePath(UserSettings.LOCAL_ASSET_SUBDIR);
                                githubFilePath = PathUtils.joinPaths(markdownDirPath, normalizedLocalAssetSubdir, uniqueFilename);
                                finalPathForMarkdownDisplay = PathUtils.joinPaths(normalizedLocalAssetSubdir, uniqueFilename);
                            } else {
                                const normalizedGlobalRootDir = PathUtils.normalizePath(UserSettings.GLOBAL_ROOT_DIR);
                                const normalizedGlobalAssetSubpath = PathUtils.normalizePath(UserSettings.GLOBAL_ASSET_SUBPATH);
                                const baseBrowsePath = PathUtils.normalizePath(UserSettings.BASE_BROWSE_PATH);
                                const normalizedMarkdownDir = PathUtils.normalizePath(markdownDirPath);
                                let subFolderPath = (normalizedMarkdownDir.startsWith(baseBrowsePath + '/') && normalizedMarkdownDir.length > baseBrowsePath.length && normalizedMarkdownDir !== baseBrowsePath)
                                    ? normalizedMarkdownDir.substring(baseBrowsePath.length + 1)
                                    : (normalizedMarkdownDir === baseBrowsePath ? '' : normalizedMarkdownDir) ;
                                githubFilePath = PathUtils.normalizePath(PathUtils.joinPaths(
                                    normalizedGlobalRootDir,
                                    normalizedGlobalAssetSubpath,
                                    subFolderPath,
                                    postSlug,
                                    uniqueFilename
                                ));
                                finalPathForMarkdownDisplay = '/' + PathUtils.normalizePath(PathUtils.joinPaths(
                                    UserSettings.OMIT_GLOBAL_ROOT_DIR_FROM_URL ? '' : normalizedGlobalRootDir,
                                    normalizedGlobalAssetSubpath,
                                    subFolderPath,
                                    postSlug,
                                    uniqueFilename
                                )).replace(/\/\/+/g, '/');
                            }
                            const base64Content = await Utils.readFileAsBase64(fileObject);
                            uploadsToCommit.push({
                                path: githubFilePath,
                                content: base64Content,
                                encoding: 'base64'
                            });
                            processedPendingKeys.add(keyForPendingUploads);
                            fileObject.finalPath = finalPathForMarkdownDisplay;
                        } catch (error) {
                            this.handleGenericError(error, i18next.t('errors.imageUploadFailed', { filename: fileObject.name, message: error.message || 'Unknown' }), "Upload Prep");
                            throw new Error(i18next.t('errors.imageUploadFailedGenericWithMessage', { message: error.message || 'Unknown' }));
                        }
                    } else {
                        finalPathForMarkdownDisplay = fileObject.finalPath;
                    }
                    if (typeof finalPathForMarkdownDisplay === 'undefined') {
                        continue;
                    }
                    let finalLinkContentForMarkdown;
                    if (!isPlaceholder) {
                        const fragment = blobPart.substring(keyForPendingUploads.length);
                        finalLinkContentForMarkdown = finalPathForMarkdownDisplay + fragment;
                    } else {
                        finalLinkContentForMarkdown = finalPathForMarkdownDisplay;
                    }
                    const replacementRegex = new RegExp(PathUtils.escapeRegex(originalUrlInMarkdown), 'g');
                    updatedBody = updatedBody.replace(replacementRegex, finalLinkContentForMarkdown);
                }
                for (const key in AppState.pendingUploads) {
                    if (AppState.pendingUploads[key].finalPath) {
                        delete AppState.pendingUploads[key].finalPath;
                    }
                }
                UIManager.updateStatus(i18next.t('statusBar.uploadComplete', { count: uploadsToCommit.length }), false, true);
                return { updatedBody, uploadsToCommit };
            },
            async getFilesToDeleteBasedOnLinks(currentLinksSet, initialLinksSet) {
                if (!initialLinksSet || initialLinksSet.size === 0) {
                    return [];
                }
                return Array.from(initialLinksSet).filter(initialLinkPath => !currentLinksSet.has(initialLinkPath));
            },
            async executeCommit(commitMessage, filesToCommit, filesToDeletePaths) {
                try {
                     UIManager.updateStatus(i18next.t('statusBar.creatingBlobs', { count: filesToCommit.length }), false, false, true);
                     const blobResults = await Promise.all(filesToCommit.map(async file => {
                        const result = await GitHubService.createBlob(file.content, file.encoding || 'utf-8');
                        if (!result.success) throw result.error;
                        return { path: file.path, sha: result.sha, mode: '100644', type: 'blob' };
                    }));
                    UIManager.updateStatus(i18next.t('statusBar.creatingTree'), false, false, true);
                    const refResult = await GitHubService.getRef();
                    if (!refResult.success) throw refResult.error;
                    const commitResult = await GitHubService.getCommit(refResult.sha);
                    if (!commitResult.success) throw commitResult.error;
                    const treeDefinition = blobResults.map(b => ({
                        path: b.path, mode: b.mode, type: b.type, sha: b.sha
                    }));
                    filesToDeletePaths.forEach(p => treeDefinition.push({
                        path: p, mode: '100644', type: 'blob', sha: null
                    }));
                    const treeResult = await GitHubService.createTree(commitResult.treeSha, treeDefinition);
                    if (!treeResult.success) throw treeResult.error;
                    UIManager.updateStatus(i18next.t('statusBar.creatingCommit'), false, false, true);
                    const newCommitResult = await GitHubService.createCommit(treeResult.sha, refResult.sha, commitMessage);
                    if (!newCommitResult.success) throw newCommitResult.error;
                    UIManager.updateStatus(i18next.t('statusBar.updatingRef'), false, false, true);
                    const updateRefResult = await GitHubService.updateRef(newCommitResult.sha);
                    if (!updateRefResult.success) throw updateRefResult.error;
                    return { success: true, commitSha: newCommitResult.sha };
                } catch (error) {
                    let step = 'Unknown';
                    if (error.message?.includes('Blob')) step = 'Blob Creation';
                    else if (error.message?.includes('Ref')) step = 'Get/Update Reference';
                    else if (error.message?.includes('Commit')) step = 'Get/Create Commit';
                    else if (error.message?.includes('Tree')) step = 'Tree Creation';
                    this.handleApiError(error, i18next.t('errors.commitFailed', { step: step }), { step });
                    return { success: false, error, step };
                }
            },
            validateSaveInputs(formData) {
                if (!formData.title) {
                    this.handleGenericError(null, 'errors.titleRequired', "Save Validation");
                    this.elements.fmTitleInput.focus();
                    return false;
                }
                if (!formData.fullPathValue ||
                    (!formData.fullPathValue.endsWith('.md') && !PathUtils.isAnyBundlePath(formData.fullPathValue)) ||
                    (PathUtils.isAnyBundlePath(formData.fullPathValue) && !formData.slugOrFilename) ||
                    formData.fullPathValue.includes('//') ||
                    formData.fullPathValue.startsWith('/')
                ) {
                    this.handleGenericError(null, 'errors.invalidFilename', "Save Validation");
                    this.elements.fileNameInput.focus();
                    return false;
                }
                if (!formData.commitMessage) {
                    this.handleGenericError(null, 'errors.commitMsgRequired', "Save Validation");
                    this.elements.commitMessageInput.focus();
                    return false;
                }
                const customKeyInputs = this.elements.customFrontMatterContainer.querySelectorAll('.custom-fm-key');
                const standardKeysLower = AppConstants.STANDARD_FM_KEYS.map(k => k.toLowerCase());
                const seenKeys = new Set();
                for (const keyInput of customKeyInputs) {
                    const key = keyInput.value.trim();
                    const keyLower = key.toLowerCase();
                    if (!key) continue;
                    if (standardKeysLower.includes(keyLower)) {
                        this.handleGenericError(null, i18next.t('errors.customKeyConflictSaveBlock', { key: key }), "Custom Field Validation");
                        keyInput.focus();
                        return false;
                    }
                    if (seenKeys.has(keyLower)) {
                        this.handleGenericError(null, i18next.t('errors.customKeyDuplicate', { key: key }), "Custom Field Validation");
                        keyInput.focus();
                        return false;
                    }
                    seenKeys.add(keyLower);
                }
                for (const customField of formData.custom) {
                    const { key, value, type } = customField;
                    if (type === 'number') {
                        if (String(value).trim() !== '' && isNaN(parseFloat(String(value)))) {
                            this.handleGenericError(null, i18next.t('errors.invalidCustomFieldType', { key: key }), "Save Validation");
                            const row = Array.from(customKeyInputs).find(k => k.value.trim() === key)?.closest('.custom-fm-row');
                            row?.querySelector('.custom-fm-value')?.focus();
                            return false;
                        }
                    } else if (type === 'date') {
                         if (String(value).trim() !== '' && isNaN(new Date(String(value).replace(' ', 'T')).getTime()) && !flatpickr.parseDate(String(value), "Y-m-d H:i:S")) {
                            this.handleGenericError(null, i18next.t('errors.invalidCustomFieldType', { key: key }), "Save Validation");
                            const row = Array.from(customKeyInputs).find(k => k.value.trim() === key)?.closest('.custom-fm-row');
                            row?.querySelector('.custom-fm-value')?.focus();
                            return false;
                        }
                    }
                }
                return true;
            },
            getValidatedDateISO(dateStr, isAutoChecked, originalDateStrIfManualAndUnchanged, fieldName = "Date") {
                let dateToProcess;
                if (isAutoChecked) {
                    dateToProcess = new Date();
                } else {
                    if (String(dateStr || '').trim() === '' && originalDateStrIfManualAndUnchanged) {
                        dateStr = originalDateStrIfManualAndUnchanged;
                    }
                    if (String(dateStr || '').trim() === '') {
                        this.handleGenericError(null, 'errors.invalidDate', `${fieldName} Validation (Empty)`);
                        return null;
                    }
                    try {
                        const parsedDate = flatpickr.parseDate(dateStr, "Y-m-d H:i") || new Date(dateStr.replace(' ', 'T'));
                        if (!parsedDate || isNaN(parsedDate.getTime())) {
                            throw new Error("Invalid date format from input");
                        }
                        dateToProcess = parsedDate;
                    } catch (e) {
                        this.handleGenericError(e, 'errors.invalidDate', `${fieldName} Validation (Format)`);
                        return null;
                    }
                }
                dateToProcess.setSeconds(0, 0);
                return dateToProcess.toISOString();
            },
            prepareFrontMatterForSave(formData, saveType, isUpdate) {
                const frontMatterData = { custom: {} };
                let dateValueISO, lastmodValueISO;
                const originalDateValue = AppState.currentFileSha ? AppState.initialFmData.date : null;
                const originalLastmodValue = AppState.currentFileSha ? AppState.initialFmData.lastmod : null;
                dateValueISO = this.getValidatedDateISO(formData.date, formData.dateAutoChecked, originalDateValue, "Date");
                if (!dateValueISO) return null;
                frontMatterData.date = dateValueISO;
                if (formData.dateAutoChecked && saveType !== 'draft') {
                    UIManager.updateStatus(i18next.t('statusBar.dateSetToNow'), false);
                }
                if (isUpdate) {
                    let shouldProcessLastmod = false;
                    if (AppState.initialDraftState) {
                        if (AppState.initialHasLastmod) {
                            shouldProcessLastmod = true;
                        }
                        if (!formData.lastmodAutoChecked || String(formData.lastmod).trim() !== '') {
                           shouldProcessLastmod = true;
                        }
                    } else {
                        shouldProcessLastmod = true;
                    }
                    if (shouldProcessLastmod) {
                        const isLastmodManuallySet = formData.lastmodAutoChecked === false;
                        const lastmodInputStr = String(formData.lastmod).trim();
                        if (isLastmodManuallySet && lastmodInputStr === '') {
                            this.handleGenericError(null, 'errors.invalidDate', "Lastmod Validation (Explicitly Cleared)");
                            return null;
                        }
                        lastmodValueISO = this.getValidatedDateISO(formData.lastmod, formData.lastmodAutoChecked, originalLastmodValue, "Lastmod");
                        if (!lastmodValueISO) {
                            return null;
                        }
                        const dateObj = new Date(dateValueISO);
                        const lastmodObj = new Date(lastmodValueISO);
                        if (lastmodObj < dateObj) {
                            this.handleGenericError(null, 'errors.lastmodBeforeDate', "Date Validation (Lastmod < Date)");
                            return null;
                        }
                        frontMatterData.lastmod = lastmodValueISO;
                        if (formData.lastmodAutoChecked && saveType !== 'draft') {
                             UIManager.updateStatus(i18next.t('statusBar.dateSetToNow'), false);
                        }
                    }
                }
                FM_FIELD_CONFIG.forEach(field => {
                    if (field.key === 'date' || field.key === 'lastmod' || field.key === 'custom') return;
                    if (formData[field.key] !== undefined) {
                        if (field.type === 'array') {
                            if (Array.isArray(formData[field.key]) && formData[field.key].length > 0) {
                                frontMatterData[field.key] = formData[field.key];
                            } else if (typeof formData[field.key] === 'string' && formData[field.key].trim() !== '') {
                                frontMatterData[field.key] = formData[field.key].split(',').map(s => s.trim()).filter(s => s !== '');
                                if (frontMatterData[field.key].length === 0) delete frontMatterData[field.key];
                            }
                        } else {
                            if (String(formData[field.key]).trim() !== '') {
                                frontMatterData[field.key] = formData[field.key];
                            }
                        }
                    }
                });
                if (saveType === 'draft') {
                    frontMatterData.draft = true;
                }
                if (Array.isArray(formData.custom)) {
                    formData.custom.forEach(customField => {
                        let processedValue;
                        const rawValue = customField.value;
                        switch (customField.type) {
                            case 'number':
                                processedValue = parseFloat(String(rawValue));
                                if (isNaN(processedValue) && String(rawValue).trim() !== '') processedValue = String(rawValue);
                                else if (isNaN(processedValue)) processedValue = undefined;
                                break;
                            case 'boolean':
                                processedValue = typeof rawValue === 'boolean' ? rawValue : String(rawValue).toLowerCase() === 'true';
                                break;
                            case 'date':
                                try {
                                    const parsed = flatpickr.parseDate(String(rawValue), "Y-m-d H:i:S") || new Date(String(rawValue).replace(' ', 'T'));
                                    if (parsed && !isNaN(parsed.getTime())) {
                                        parsed.setSeconds(0, 0);
                                        processedValue = parsed.toISOString();
                                    } else if (String(rawValue).trim() !== '') {
                                        processedValue = String(rawValue);
                                    } else {
                                        processedValue = undefined;
                                    }
                                } catch (e) {
                                    processedValue = String(rawValue).trim() !== '' ? String(rawValue) : undefined;
                                }
                                break;
                            case 'array':
                                processedValue = Array.isArray(rawValue) ? rawValue.map(String).filter(s => s !== '') : String(rawValue).split(',').map(s => s.trim()).filter(s => s !== '');
                                if (processedValue.length === 0) processedValue = undefined;
                                break;
                            case 'string':
                            default:
                                processedValue = String(rawValue).trim() !== '' ? String(rawValue) : undefined;
                                break;
                        }
                        if (processedValue !== undefined) {
                            frontMatterData.custom[customField.key] = processedValue;
                        }
                    });
                }
                if (frontMatterData.draft === undefined || frontMatterData.draft === false) delete frontMatterData.draft;
                if (frontMatterData.lastmod === undefined) {
                    delete frontMatterData.lastmod;
                }
                return frontMatterData;
            },
            getSaveOperationTypeKey(saveType, isUpdate) {
                if (!isUpdate) {
                    return saveType === 'publish' ? 'statusBar.opPublishNew' : 'statusBar.opCreateDraft';
                }
                if (AppState.initialDraftState) {
                    return saveType === 'publish' ? 'statusBar.opPublishUpdate' : 'statusBar.opUpdateDraft';
                }
                return saveType === 'draft' ? 'statusBar.opRevertToDraft' : 'statusBar.opUpdatePublished';
            },
            async saveFile(saveType) {
                if (!AppState.octokit) {
                    this.handleLogout();
                    return;
                }
                UIManager.setEditorSaving(true);
                const formData = await this.getProcessedEditorFormData();
                if (!this.validateSaveInputs(formData)) {
                    UIManager.setEditorSaving(false);
                    this.refreshEditorUIState();
                    return;
                }
                const isUpdate = !!AppState.currentFileSha;
                const finalFrontMatterData = this.prepareFrontMatterForSave(formData, saveType, isUpdate);
                if (!finalFrontMatterData) {
                     UIManager.setEditorSaving(false);
                     this.refreshEditorUIState();
                     return;
                }
                const newSlug = formData.slugOrFilename;
                const userEnteredPathValue = formData.fullPathValue;
                const originalPath = AppState.currentFilePath ? PathUtils.normalizePath(AppState.currentFilePath) : null;
                const { targetPath, isTargetLocalActual } = this.determineSaveTarget(
                    isUpdate,
                    newSlug,
                    userEnteredPathValue,
                    originalPath,
                    AppState.currentPath,
                    UserSettings
                );
                const markdownDirPath = PathUtils.getDirname(targetPath);
                let bodyToSave = formData.body;
                if (UserSettings.VDITOR_EDIT_MODE === 'ir' && AppState.isDraft(AppState.currentFilePath) && PathUtils.isAnyBundlePath(AppState.currentFilePath) && UserSettings.ASSET_STRATEGY === 'local') {
                    bodyToSave = this.restoreBlobURLsToRelativePathsInBody(formData.body);
                }
                let uploadsToCommit = [], markdownWithUploadsProcessed = bodyToSave;
                try {
                    const uploadResult = await this.prepareUploads(bodyToSave, newSlug, markdownDirPath, isTargetLocalActual);
                    markdownWithUploadsProcessed = uploadResult.updatedBody;
                    uploadsToCommit = uploadResult.uploadsToCommit;
                } catch (error) {
                    UIManager.setEditorSaving(false);
                    this.refreshEditorUIState();
                    return;
                }
                let filesToDeletePaths = [];
                if (isUpdate && originalPath) {
                     const finalLinks = this.parseManagedUploadLinks(markdownWithUploadsProcessed, targetPath);
                     filesToDeletePaths.push(...await this.getFilesToDeleteBasedOnLinks(finalLinks, AppState.initialUploadLinks));
                     filesToDeletePaths = [...new Set(filesToDeletePaths.filter(p => p))];
                }
                const operationType = i18next.t(this.getSaveOperationTypeKey(saveType, isUpdate));
                let finalContent;
                try {
                    finalContent = FrontMatterUtils.formatFrontMatterAndBody(finalFrontMatterData, markdownWithUploadsProcessed);
                } catch (formatError) {
                    UIManager.setEditorSaving(false);
                    this.refreshEditorUIState();
                    return;
                }
                const filesToCommit = [
                    ...uploadsToCommit,
                    { path: targetPath, content: finalContent, encoding: 'utf-8' }
                ];
                UIManager.updateStatus(i18next.t('statusBar.saving', { path: targetPath, operation: operationType }), false, false, true);
                try {
                    const commitResult = await this.executeCommit(formData.commitMessage, filesToCommit, filesToDeletePaths);
                    if (commitResult.success) {
                        UIManager.updateStatus(i18next.t('statusBar.saveSuccess', {
                            path: targetPath,
                            operation: operationType,
                            commitSha: commitResult.commitSha?.substring(0, 7) || 'N/A'
                        }), false, true, false);
                        const normalizedTargetPath = PathUtils.normalizePath(targetPath);
                        if (finalFrontMatterData.draft === true) {
                           AppState.draftPathsSet.add(normalizedTargetPath);
                        } else {
                            AppState.draftPathsSet.delete(normalizedTargetPath);
                        }
                        this.setBaseTag(null);
                        UIManager.removeActiveFileHighlight();
                        AppState.clearPendingUploads();
                        AppState.clearDraftAssets();
                        AppState.clearEditingFile();
                        UIManager.setBrowseOnlyState();
                        UIManager.updateStatus(i18next.t('statusBar.refreshingList'), false, false, true);
                        await Utils.delay(UserSettings.UI_TRANSITION_DELAY_MS);
                        await this.browsePath(PathUtils.getDirname(targetPath) || UserSettings.BASE_BROWSE_PATH);
                    } else {
                        UIManager.setEditorSaving(false);
                        this.refreshEditorUIState();
                    }
                } catch (error) {
                    UIManager.setEditorSaving(false);
                    this.handleGenericError(error, 'errors.saveException', "Save File");
                    this.refreshEditorUIState();
                }
            },
             confirmDeletion(filePathToDelete) {
                const isBranchBundleIndex = PathUtils.isBranchBundlePath(filePathToDelete);
                const isLeafBundleIndex = PathUtils.isPageBundlePath(filePathToDelete);
                const resourceNameToDelete = (isBranchBundleIndex || isLeafBundleIndex)
                    ? PathUtils.getBasename(PathUtils.getDirname(filePathToDelete))
                    : PathUtils.getBasename(filePathToDelete);
                let confirmMsgKey = 'prompts.confirmDelete';
                if (isBranchBundleIndex) {
                    confirmMsgKey = 'prompts.confirmDeleteBranchBundleIndex';
                } else if (isLeafBundleIndex) {
                    confirmMsgKey = 'prompts.confirmDeleteBundle';
                }
                 return confirm(
                     `${i18next.t(confirmMsgKey, { filename: PathUtils.getBasename(filePathToDelete), bundleName: PathUtils.getDirname(filePathToDelete) })}\n\n` +
                     `${i18next.t('prompts.confirmDeleteDetail')}`
                 );
            },
             getDeleteCommitMessage(resourceNameToDelete) {
                const commitMessage = i18next.t('commit.delete', { path: resourceNameToDelete });
                UIManager.setCommitMessage(commitMessage, '');
                if (!commitMessage) {
                    this.handleGenericError(null, 'errors.commitMsgRequired', "Delete Commit Message");
                    this.elements.commitMessageInput.focus();
                    return null;
                }
                return commitMessage;
            },
            async deleteFile() {
                if (!AppState.octokit) { this.handleLogout(); return; }
                if (!AppState.currentFilePath || !AppState.currentFileSha) {
                    this.handleGenericError(null, 'errors.noFileToDelete', "Delete File");
                    return;
                }
                const filePathToDelete = AppState.currentFilePath;
                if (!this.confirmDeletion(filePathToDelete)) {
                    UIManager.updateStatus(i18next.t('prompts.deleteCancelled'), false);
                    return;
                }
                const isBranchBundleIndex = PathUtils.isBranchBundlePath(filePathToDelete);
                const isLeafBundleIndex = PathUtils.isPageBundlePath(filePathToDelete);
                const resourceNameToDelete = (isBranchBundleIndex || isLeafBundleIndex)
                    ? PathUtils.getBasename(PathUtils.getDirname(filePathToDelete))
                    : PathUtils.getBasename(filePathToDelete);
                const commitMessage = this.getDeleteCommitMessage(resourceNameToDelete);
                if (!commitMessage) return;
                UIManager.setEditorSaving(true);
                UIManager.updateStatus(i18next.t(
                    isBranchBundleIndex ? 'statusBar.deletingBranchIndex' : (isLeafBundleIndex ? 'statusBar.deletingBundle' : 'statusBar.deleting'),
                     { path: resourceNameToDelete }
                 ), false, false, true);
                 let filesToDeletePaths = [];
                 try {
                     const pathsToDeleteSet = await this.identifyResourcesToDelete(
                         filePathToDelete,
                         isBranchBundleIndex,
                         isLeafBundleIndex,
                         AppState.initialUploadLinks,
                         UserSettings,
                         GitHubService
                     );
                     filesToDeletePaths = Array.from(pathsToDeleteSet).filter(p => p);
                     if (filesToDeletePaths.length === 0) {
                        throw new Error("No files identified for deletion.");
                    }
                 } catch (error) {
                     UIManager.setEditorSaving(false);
                     this.handleGenericError(error, 'errors.deleteException', "Delete Preparation");
                     this.refreshEditorUIState();
                     return;
                 }
                try {
                    const commitResult = await this.executeCommit(commitMessage, [], filesToDeletePaths);
                    if (commitResult.success) {
                        UIManager.updateStatus(i18next.t(
                            isBranchBundleIndex ? 'statusBar.deleteBranchIndexSuccess' : 'statusBar.deleteSuccess', {
                                path: resourceNameToDelete,
                                commitSha: commitResult.commitSha?.substring(0, 7) || 'N/A'
                            }
                        ), false, true, false);
                         const normalizedFilePathToDelete = PathUtils.normalizePath(filePathToDelete);
                         AppState.draftPathsSet.delete(normalizedFilePathToDelete);
                         if (isLeafBundleIndex) {
                             const bundleDirPrefix = PathUtils.getDirname(normalizedFilePathToDelete) + '/';
                             AppState.draftPathsSet.forEach(path => {
                                 if (path.startsWith(bundleDirPrefix)) {
                                     AppState.draftPathsSet.delete(path);
                                 }
                             });
                         }
                        this.setBaseTag(null);
                        UIManager.removeActiveFileHighlight();
                        AppState.clearEditingFile();
                        UIManager.setBrowseOnlyState();
                        UIManager.updateStatus(i18next.t('statusBar.navigatingParent'), false, false, true);
                        await Utils.delay(UserSettings.UI_TRANSITION_DELAY_MS);
                         let pathToShowAfterDelete = PathUtils.getDirname(filePathToDelete) || UserSettings.BASE_BROWSE_PATH;
                         if(isBranchBundleIndex || isLeafBundleIndex) {
                             pathToShowAfterDelete = PathUtils.getDirname(PathUtils.getDirname(filePathToDelete)) || UserSettings.BASE_BROWSE_PATH;
                         }
                        const normalizedBasePath = PathUtils.normalizePath(UserSettings.BASE_BROWSE_PATH);
                        if (pathToShowAfterDelete !== normalizedBasePath && !pathToShowAfterDelete.startsWith(normalizedBasePath + '/')) {
                            pathToShowAfterDelete = normalizedBasePath;
                        }
                        await this.browsePath(PathUtils.normalizePath(pathToShowAfterDelete));
                    } else {
                        UIManager.setEditorSaving(false);
                        this.refreshEditorUIState();
                    }
                } catch (error) {
                    UIManager.setEditorSaving(false);
                    this.handleGenericError(error, 'errors.deleteException', "Delete Commit");
                    this.refreshEditorUIState();
                }
            },
            async cancelEdit() {
                if (!AppState.octokit) { this.handleLogout(); return; }
                let hasChanges = false;
                if (VditorManager.isReady) {
                     try {
                         const formData = await this.getProcessedEditorFormData();
                         hasChanges = AppState.isModified(formData);
                     } catch(e) {
                         this.handleGenericError(e, "Error checking modifications", "Cancel Edit");
                         hasChanges = true;
                     }
                 }
                 if (hasChanges ? confirm(i18next.t('prompts.confirmCancel')) : true) {
                    UIManager.setEditorSaving(true);
                    UIManager.updateStatus(i18next.t('statusBar.cancelled'), false, false, true);
                    const pathBeforeCancel = AppState.currentPath || UserSettings.BASE_BROWSE_PATH;
                    UIManager.removeActiveFileHighlight();
                    await Utils.delay(UserSettings.UI_TRANSITION_DELAY_MS / 2);
                    AppState.clearEditingFile();
                    UIManager.clearEditorFields();
                    UIManager.setBrowseOnlyState();
                    UIManager.setEditorSaving(false);
                    await this.browsePath(pathBeforeCancel);
                } else {
                    UIManager.updateStatus(i18next.t('prompts.cancelAbort'));
                }
            },
        };
        document.addEventListener('DOMContentLoaded', () => {
            try {
                if (typeof App !== 'undefined' && typeof App.init === 'function') {
                    App.init();
                } else {
                    throw new Error("App object or init function not found.");
                }
            } catch (error) {
                const sb = document.getElementById('statusBar');
                if (sb) {
                    sb.textContent = resources.en.translation['errors.appInit'];
                    sb.classList.add('status-bar-error');
                }
                document.body.innerHTML = `<h1 style="color: red;">${resources.en.translation['errors.appLoad']}</h1><p>${resources.en.translation['errors.scriptError']}</p><p>${error.message}</p>`;
            }
        });
    </script></body></html>